{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/icon-144x144.jpg","path":"icon-144x144.jpg","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/icon-194x194.jpg","path":"icon-194x194.jpg","modified":1,"renderable":0},{"_id":"themes/inside/source/runtime.9c308a63d02029c20228.js","path":"runtime.9c308a63d02029c20228.js","modified":1,"renderable":1},{"_id":"themes/inside/source/styles.27f292de72d9e7a2cdaf.css","path":"styles.27f292de72d9e7a2cdaf.css","modified":1,"renderable":1},{"_id":"source/avatar.jpg","path":"avatar.jpg","modified":1,"renderable":0},{"_id":"themes/inside/source/polyfills.23aa31104b29f3163090.js","path":"polyfills.23aa31104b29f3163090.js","modified":1,"renderable":1},{"_id":"themes/inside/source/polyfills-es5.613d1909ec381c0aefb7.js","path":"polyfills-es5.613d1909ec381c0aefb7.js","modified":1,"renderable":1},{"_id":"themes/inside/source/main.e8fb83af303ddf146491.zh-Hans.js","path":"main.e8fb83af303ddf146491.zh-Hans.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/icon-144x144.jpg","hash":"af710cc2ccf821fdc620793c1a503a624779341e","modified":1536993363258},{"_id":"source/favicon.ico","hash":"6cee16f547419ac6722b2e24eb6ab7b1ab7970d0","modified":1536993363203},{"_id":"themes/inside/.DS_Store","hash":"efbae13410c622c8729b045d9985aa42eb7f9207","modified":1565246619264},{"_id":"source/icon-194x194.jpg","hash":"c23c16e6c7846e40d65980d89a37dc6c5eab8ade","modified":1536993363285},{"_id":"themes/inside/.gitignore","hash":"f964b070d203c5e8555d4cc0ecafe1ecaac88079","modified":1564135036000},{"_id":"themes/inside/README.md","hash":"17b1c1b93947d6a9be99060702f04cecae804f57","modified":1564135036000},{"_id":"themes/inside/LICENSE","hash":"80e42bdfa4902549136f3a2445f16bff8ec46be8","modified":1564135036000},{"_id":"themes/inside/README_zh-Hans.md","hash":"9c4f4a8c88250629613edf920b57e867615888f6","modified":1564135036000},{"_id":"themes/inside/_config.yml","hash":"a636676d690645cf61ce6e4dc1a5fe48c876c3a0","modified":1565252120173},{"_id":"themes/inside/package.json","hash":"d52ed08824e3c583bd268626d06389515df0c18f","modified":1564135036000},{"_id":"themes/inside/.npmignore","hash":"da713828cf6427eec231c5423ed9c360016a8a80","modified":1564135036000},{"_id":"themes/inside/.travis.yml","hash":"d65a9081075c94b3692b5b3257cd3ade7367f2be","modified":1564135036000},{"_id":"source/_draft/2019-01-04-《CSS世界》阅读笔记.md","hash":"b56fce2622549742278a1d3683db1b361ad7e8f5","modified":1558607475765},{"_id":"source/_posts/2018-05-14-你不知道的JS-1.markdown","hash":"554b90d7f1816bb8b60bf9b1a6493d9ac1cd414e","modified":1565250440014},{"_id":"source/_posts/2018-06-03-你不知道的JS-3.markdown","hash":"9eb7ab8c7343d7e314f6cac5496a6ab7fa807a97","modified":1546418940266},{"_id":"source/_posts/2018-06-10-你不知道的JS-4.markdown","hash":"b41353bef401fd9b33322a4289d1e46e14a8d3a6","modified":1546418940220},{"_id":"source/_posts/2018-06-20-JS机制梳理总结.markdown","hash":"807ec9edeed56569ffa759eaca2b472b2e81bf07","modified":1546418940245},{"_id":"source/_posts/2018-07-23-前端性能优化-1.markdown","hash":"24dfaf1bb4151369d03a55063bcea31c04a72753","modified":1546418940221},{"_id":"source/_posts/2018-07-23-前端性能优化-2.markdown","hash":"2bbe3d772a1bd9683bf7a15a5589e17484f55a9b","modified":1546418940266},{"_id":"source/_posts/2018-07-25-Vuex框架原理与源码分析.markdown","hash":"900c8e89629481ea34f57abcc01d54edf63fe3bd","modified":1546418940261},{"_id":"source/_posts/2018-07-26-Vuex源码分析.markdown","hash":"da3b3cf535cebcc58339441afbe5f876fbe75e65","modified":1546418940262},{"_id":"source/_posts/2018-07-27-Vuex源码读后感.markdown","hash":"c770f68c17e2b4df1a81369fd2e1d715196a084f","modified":1546418940262},{"_id":"source/_posts/2018-08-03-浏览器缓存知识小结及应用.markdown","hash":"03f698bef3b2492214292c5d40f2bf63170daa19","modified":1546418940227},{"_id":"source/_posts/2018-08-06-深浅拷贝.markdown","hash":"8db71669cc64592c530f7a081b8992e647b344fb","modified":1546418940261},{"_id":"source/_posts/2018-08-07-NaN.markdown","hash":"cfc80bd1851dce15fd1ce44b7aef10a531f7600a","modified":1546418940266},{"_id":"source/_posts/2018-08-08-JavaScript模块化七日谈.markdown","hash":"ab680c87f95a00bfe318f56a7d5657326daed00b","modified":1546418940266},{"_id":"source/_posts/2018-11-20-Promise实现详解.md","hash":"df0420f3ffb934a7487bf8f26613247bc9cd31ec","modified":1546418940261},{"_id":"source/_posts/2018-11-21-flex演算法总结.md","hash":"acdb127e9c48e6623f3dc2efc22ede01009383b5","modified":1546418940266},{"_id":"source/_posts/2019-01-03-2018过去了，我决定去怀念她.md","hash":"99c25c18ed7c0f331066c174c317da487d86b005","modified":1546521862300},{"_id":"themes/inside/.github/stale.yml","hash":"cd81583c047c8835799a242566338b48271a67dd","modified":1564135036000},{"_id":"themes/inside/languages/default.yml","hash":"bc83e56a99531ff82dcd7b6f752a4db0980d3dee","modified":1564135036000},{"_id":"themes/inside/languages/en.yml","hash":"bc83e56a99531ff82dcd7b6f752a4db0980d3dee","modified":1564135036000},{"_id":"themes/inside/languages/ja.yml","hash":"6c2c935a56347de087806b1ae7644f484994fe3c","modified":1564135036000},{"_id":"themes/inside/languages/zh-Hans.yml","hash":"c7aaba0d495bd20e09b9063476a183a6d0718f63","modified":1564135036000},{"_id":"themes/inside/languages/zh-Hant.yml","hash":"46ca125b558357420e827b9d276a09777edcd914","modified":1564135036000},{"_id":"themes/inside/layout/index.ejs","hash":"5b03cf6241f786a9c5dc5e574132ff59f165aece","modified":1564135036000},{"_id":"themes/inside/lib/config.js","hash":"5abeff47e3a5180ebcef8f6821bbab378f67acc2","modified":1564135036000},{"_id":"themes/inside/lib/configSchema.json","hash":"5e726a8cabd7d828489015338efb9c34bb839528","modified":1564135036000},{"_id":"themes/inside/lib/utils.js","hash":"a681b537f8d186aa946a85d0485e275cac89e5f6","modified":1564135036000},{"_id":"themes/inside/scripts/index.js","hash":"380f27fb0f1dfb0ec51a2a3c96b9014bff5bf862","modified":1564135036000},{"_id":"themes/inside/source/_resources.json","hash":"e52181273879a30f916d4d2b41cdbe5c0d56a645","modified":1564135036000},{"_id":"themes/inside/source/_theme.js","hash":"11d4f00c738a537823bfc1ee133f015c37d801af","modified":1564135036000},{"_id":"themes/inside/source/runtime.9c308a63d02029c20228.js","hash":"b62956c2192bfe5516d6374e753773901ed50ec5","modified":1564135036000},{"_id":"themes/inside/source/styles.27f292de72d9e7a2cdaf.css","hash":"0727dd630a30047ba5c6edc176dba5c3675e532b","modified":1564135036000},{"_id":"themes/inside/test/README.md","hash":"96cdb8d68278f099ebfc9c7f6a4745da622e34dd","modified":1564135036000},{"_id":"themes/inside/test/index.js","hash":"235de0b2dbcc456c6a7e765e60fe7c36808dc7a4","modified":1564135036000},{"_id":"themes/inside/test/jasmine.json","hash":"8a6ad42f0a1d94c252d041f18ee63669b660b15d","modified":1564135036000},{"_id":"source/_draft/2019-01-07-《一个游荡者的世界》边看边查.md","hash":"b56009e31cff920c8908849cf5189a23a44b10ad","modified":1546856142787},{"_id":"source/_posts/2018-05-25-你不知道的JS-2.markdown","hash":"b4e91a15f36247ffe7af74aaedcdafc2954ae2bc","modified":1546418940266},{"_id":"source/avatar.jpg","hash":"c3e5d063c2e395256c3b1891dce23624e810f542","modified":1536992553477},{"_id":"themes/inside/source/polyfills.23aa31104b29f3163090.js","hash":"a224860833f62a538bb6d17a97e71c72dfca79c1","modified":1564135036000},{"_id":"themes/inside/source/polyfills-es5.613d1909ec381c0aefb7.js","hash":"e3aac0d6ebd3f9f1286da2a0bbb8631c4642986c","modified":1564135036000},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/question.md","hash":"9f8004c63012d6b16b6d93f3f10293b84cbdf3f2","modified":1564135036000},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/bug-report-----.md","hash":"8cb384a909f538c6d22d3362424375d4332d6390","modified":1564135036000},{"_id":"themes/inside/lib/filter/index.js","hash":"aeb29f86ee812ce4d35ac113c6f4b4377a03cf83","modified":1564135036000},{"_id":"themes/inside/lib/filter/templates.js","hash":"86b31cec8512f37824dc4b18c89d0cf7b5987de5","modified":1564135036000},{"_id":"themes/inside/lib/generator/config.js","hash":"2226dcc4c27ad6e6a1c2f99d56c1271bee66dcd5","modified":1564135036000},{"_id":"themes/inside/lib/filter/post.js","hash":"5fdca58163a913ec35242fa2402b67332c9e0e86","modified":1564135036000},{"_id":"themes/inside/lib/generator/index.js","hash":"f22b050066b3da1d3b3c39861c890b73b982fdf9","modified":1564135036000},{"_id":"themes/inside/lib/generator/manifest.js","hash":"32813d40d8f1301bd913b597f649d232e4c5c90a","modified":1565251023362},{"_id":"themes/inside/lib/generator/sitemap.js","hash":"5ab54fccd7a89a4c0e34562b3535120daf37ddc3","modified":1564135036000},{"_id":"themes/inside/lib/generator/theme.js","hash":"416fa83328d9e99ef073813689bbf361eda28344","modified":1564135036000},{"_id":"themes/inside/lib/generator/sw.js","hash":"216cc78d48e0dd3d0cff374c49bdc8e83b2ecd62","modified":1564135036000},{"_id":"themes/inside/lib/helper/ga.js","hash":"adc62bd06443a781d6046d3e78aa57b5e4291611","modified":1564135036000},{"_id":"themes/inside/lib/helper/index.js","hash":"93fbe9d8fe364cf4e2e55cc3d4d3156dde028f56","modified":1564135036000},{"_id":"themes/inside/lib/helper/url_trim.js","hash":"f87e959017740e69dac58cf414a001368680b7b4","modified":1564135036000},{"_id":"themes/inside/lib/tag/canvas.js","hash":"24c02f85506c1f412a3386d14f1ceb074e4864e2","modified":1564135036000},{"_id":"themes/inside/lib/helper/structured_data.js","hash":"682cfb827880ccfe5a972bb326ab4691cd8c470d","modified":1564135036000},{"_id":"themes/inside/lib/tag/gist.js","hash":"4bedda6e6c07e2eeac3a3fc97617181287d77d34","modified":1564135036000},{"_id":"themes/inside/lib/tag/index.js","hash":"bf75dd670a1d6ffffbacb183b406235780d680c6","modified":1564135036000},{"_id":"themes/inside/lib/theme-processor/localized-script.js","hash":"37f6a871a75c8f6230f0cf9d22e133921add6477","modified":1564135036000},{"_id":"themes/inside/lib/theme-processor/index.js","hash":"467e4a90ba6d63d9936868488ce0ef528208cfd5","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/archives.js","hash":"cf630bd902efd92ac710b75f1c63b03a61a27feb","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/categories.js","hash":"7675804a6dcfc0fdb789644be2aa87557c826635","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/index.js","hash":"dabc6ee5324b9864b2030eee79b7ceb22319e63f","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/pages.js","hash":"d7e99c52c7aea9df4e826314ad75dc32e6f544b1","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/posts.js","hash":"aa6017e38f9d841816d4937dce4a7b3f823a5b38","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/search.js","hash":"0ecccc181b0140ead9d99ff11f4e5b43132aefc0","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/properties.js","hash":"92e85ab430294ba0c6fb57347cc0ea977695b25e","modified":1564135036000},{"_id":"themes/inside/lib/generator/entries/tags.js","hash":"e462331c70fa1202e2376bb6a441e2001599f9b4","modified":1564135036000},{"_id":"themes/inside/test/scripts/filters/index.js","hash":"6d3d9f945edeac1041392db2c8a71d8e4ee8f2ad","modified":1564135036000},{"_id":"themes/inside/test/scripts/filters/post.js","hash":"6cfba607a24ccec322d447eaf005ffcd96954b6b","modified":1564135036000},{"_id":"themes/inside/test/scripts/filters/template.js","hash":"fb2af77fa87a9c3bf167d2b99bb255ee982b91a9","modified":1564135036000},{"_id":"themes/inside/test/scripts/helpers/ga.js","hash":"10922cd6920121846c10f00c27d40bdc1707e2c8","modified":1564135036000},{"_id":"themes/inside/test/scripts/helpers/index.js","hash":"bfefb20e24d48ca6a130e655d862f929d7ffb43c","modified":1564135036000},{"_id":"themes/inside/test/scripts/helpers/structured_data.js","hash":"8878e0177631c71515820bb10c1084c21e4de6f8","modified":1564135036000},{"_id":"themes/inside/test/scripts/helpers/url_trim.js","hash":"2cabd9aa7b6eb7058288fb50d4cd707874260df6","modified":1564135036000},{"_id":"themes/inside/test/scripts/tags/canvas.js","hash":"df3fd748c6c5d5414e4f84be127fbbcdb37250de","modified":1564135036000},{"_id":"themes/inside/test/scripts/tags/gist.js","hash":"946b40aa186980524bef5ab5d4c0d8c95153f473","modified":1564135036000},{"_id":"themes/inside/test/scripts/tags/index.js","hash":"4ce8c76c53c05fba25bc49fa90a80b75afffa052","modified":1564135036000},{"_id":"themes/inside/test/scripts/utils/index.js","hash":"2bf714d761741f4a4d2e0fb611bcd5155fc69a3d","modified":1564135036000},{"_id":"themes/inside/test/scripts/utils/parseConfig.js","hash":"922aa8f4d7b2cdc29de07d14c1ade62f53759ec8","modified":1564135036000},{"_id":"themes/inside/test/scripts/utils/rest.js","hash":"833c708fca1b129cf20ea08a22203f9317ea5fb3","modified":1564135036000},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/feature_request.md","hash":"4a5ec7b77092bf55fab55b3a8221197e21d34f35","modified":1564135036000},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/bug_report.md","hash":"551a4ed855c1e3ae3f1ad6176a529caacab70f52","modified":1564135036000},{"_id":"themes/inside/source/main.99f2ed354d17ddb7e297.en.js","hash":"519c70d4bab01307a41d7df89883865e85694e8d","modified":1564135036000},{"_id":"themes/inside/source/main.dbd6cdb5a87dffb7779f.ja.js","hash":"7b42a362c9035d48d2335a008b0a5532df1fed85","modified":1564135036000},{"_id":"themes/inside/source/main.2ce44af30eb8436e5d50.zh-Hant.js","hash":"5a84732e99815b5975bcc1a8044fe53a534b2417","modified":1564135036000},{"_id":"themes/inside/source/main.e8fb83af303ddf146491.zh-Hans.js","hash":"8704a8cd26a96351f7ec7cc1e7636aea5f6a1d28","modified":1564135036000},{"_id":"public/api/cG9zdC8yMDE5LTAxLTAzLTIwMTjov4fljrvkuobvvIzmiJHlhrPlrprljrvmgIDlv7Xlpbk.json","hash":"db62787f4356679ca73849504f1882ba1b4f70cb","modified":1565252138971},{"_id":"public/api/cG9zdC8yMDE4LTExLTIxLWZsZXjmvJTnrpfms5XmgLvnu5M.json","hash":"dcd64005be10d9f1719271da5c1118108edf2448","modified":1565252138974},{"_id":"public/api/cG9zdC8yMDE4LTExLTIwLVByb21pc2Xlrp7njrDor6bop6M.json","hash":"f84cc5ddc4a7804665956aa815dcffa19369684a","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA4LTA4LUphdmFTY3JpcHTmqKHlnZfljJbkuIPml6XosIg.json","hash":"447ad1ee0c26ca5381010e886ec4cd3d3b8d2a37","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA4LTA3LU5hTg.json","hash":"7de150479d1cc073027938bc3243156c821f442e","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA4LTA2Lea3sea1heaLt+i0nQ.json","hash":"a5040176a9e6e65a85307fb7327506e96561fafe","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA4LTAzLea1j+iniOWZqOe8k+WtmOefpeivhuWwj+e7k+WPiuW6lOeUqA.json","hash":"2b12fb5dab1af1a37129fd27feda0d44075ac0d6","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA3LTI3LVZ1ZXjmupDnoIHor7vlkI7mhJ8.json","hash":"548a7f43e40bcdd6c4002f067c22721a5ad195e3","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA3LTI2LVZ1ZXjmupDnoIHliIbmnpA.json","hash":"1f6b708714176baa8c712771867e83aa03a6913a","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA3LTI1LVZ1ZXjmoYbmnrbljp/nkIbkuI7mupDnoIHliIbmnpA.json","hash":"ec7daa17343899d5b0aff2b8dafae950c3f5c0b4","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA3LTIzLeWJjeerr+aAp+iDveS8mOWMli0y.json","hash":"01c0d59f45015623a93bc871013e95a56669dd87","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA3LTIzLeWJjeerr+aAp+iDveS8mOWMli0x.json","hash":"9934408d1d0fecf3e07167cf8bb29e71cb5ec840","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA2LTIwLUpT5py65Yi25qKz55CG5oC757uT.json","hash":"b038a3bb8c9898d97acb1201db3e93ebb3a1a2a3","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA2LTEwLeS9oOS4jeefpemBk+eahEpTLTQ.json","hash":"be277fe2bdf958d598938f73bcc9c2e77c81dce6","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA2LTAzLeS9oOS4jeefpemBk+eahEpTLTM.json","hash":"afff93e33840bfcc02c2339c35bebee78640508c","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA1LTI1LeS9oOS4jeefpemBk+eahEpTLTI.json","hash":"057afe8e91c0b7120b881ff6aeb10b5e0ce555a0","modified":1565252138975},{"_id":"public/api/cG9zdC8yMDE4LTA1LTE0LeS9oOS4jeefpemBk+eahEpTLTE.json","hash":"d76205139cd4b68eb7baaac0a4386df9109237b5","modified":1565252138976},{"_id":"public/api/cG9zdHM.json","hash":"b672ce30e15e763f6b6d020b7225a6f5c3bef76d","modified":1565252138976},{"_id":"public/api/cG9zdHMvMg.json","hash":"7612c02093f3df420d5f30962ca77dca1827858b","modified":1565252138976},{"_id":"public/api/dGFncw.json","hash":"f69cc4ecbe92a236b474cbf6e65b3ea866beac5e","modified":1565252138976},{"_id":"public/api/dGFncy9DU1M.json","hash":"1eb750729dbf17c18790f9fdd30912be677f88db","modified":1565252138976},{"_id":"public/api/dGFncy9FUzY.json","hash":"d539b580f832aac296d8a3fe3310c24180c3265a","modified":1565252138976},{"_id":"public/api/dGFncy9KU+acuuWItg.json","hash":"0418673743b649bcaafaeb3daa553e57509ae9cc","modified":1565252138976},{"_id":"public/api/dGFncy9KYXZhU2NyaXB0.json","hash":"3750a4e906e72794d814a712351a9a533e8efe17","modified":1565252138976},{"_id":"public/api/dGFncy9Qcm9taXNl.json","hash":"b50f1e58d2031ae705b22ebdd65e88bf11513ff8","modified":1565252138976},{"_id":"public/api/dGFncy9mbGV45biD5bGA.json","hash":"376a9a8eda0801b814019170a44bda87d327c539","modified":1565252138976},{"_id":"public/api/dGFncy92dWU.json","hash":"9d5b0229d85be454774ca12e9412b022255f4eb7","modified":1565252138976},{"_id":"public/api/dGFncy/kvaDkuI3nn6XpgZPnmoRKUw.json","hash":"7b32c187ecec1eb300f21219b038388b0bc64b23","modified":1565252138976},{"_id":"public/api/dGFncy/liY3nq6/lvIDlj5E.json","hash":"8f7be180ec4b3ef3d8dbc3e3f77902884d0c5a89","modified":1565252138976},{"_id":"public/api/dGFncy/liY3nq6/lvIDlj5EvMg.json","hash":"264884393fc602016b6ba8b5ee1dcd41a795e2d0","modified":1565252138976},{"_id":"public/api/dGFncy/liY3nq6/mqKHlnZfljJY.json","hash":"9a97cf9e5a29fdf632d5bcec7a761ad3888c3214","modified":1565252138976},{"_id":"public/api/dGFncy/lubTluqbmgLvnu5M.json","hash":"b94f31c13ba362021e3736b876ed2b18a36a2c15","modified":1565252138976},{"_id":"public/api/dGFncy/mgKfog73kvJjljJY.json","hash":"c91f1a43d8a152d7ce7bf0322934411733f5937d","modified":1565252138976},{"_id":"public/api/dGFncy/noo7noo7lv7U.json","hash":"ae6b88483483c0a567289d7201e4b04097c7d139","modified":1565252138977},{"_id":"public/api/dGFncy/nvJPlrZg.json","hash":"4b8743c6d41e628b946bdd62c4683a8dfe22732f","modified":1565252138977},{"_id":"public/api/YXJjaGl2ZXM.json","hash":"36c5088d553bc94db467750c90fb1fe52bd1dc93","modified":1565252138977},{"_id":"public/api/YXJjaGl2ZXMvMg.json","hash":"c007218e574a6e75bf9da5e568c54e77f1f0c0e2","modified":1565252138977},{"_id":"public/sitemap.xml","hash":"8d6f5fd9ca4fee5f91dcd644c07954f6a0b23c19","modified":1565252138977},{"_id":"public/manifest.json","hash":"864fb01b6c88878a821515221040df789dd693d8","modified":1565252138977},{"_id":"public/404/index.html","hash":"9e0591b864e1cf528c5e29dfdf4b979933ea2c23","modified":1565252138985},{"_id":"public/post/2019-01-03-2018过去了，我决定去怀念她/index.html","hash":"e38e0a8a2ebf792a85e6e2d390675942797ed2da","modified":1565252138985},{"_id":"public/post/2018-11-21-flex演算法总结/index.html","hash":"c5874dede7326c888441d8fbf3a7b1f846e03e71","modified":1565252138985},{"_id":"public/post/2018-11-20-Promise实现详解/index.html","hash":"d801e27c09d71e06606701fd453b211eccc9b266","modified":1565252138985},{"_id":"public/post/2018-08-08-JavaScript模块化七日谈/index.html","hash":"459492f382d5fb25967cc91a6574b801d9731977","modified":1565252138985},{"_id":"public/post/2018-08-07-NaN/index.html","hash":"c698f791a02c82784fb6b4e38dc680e6bab3ad9b","modified":1565252138985},{"_id":"public/post/2018-08-06-深浅拷贝/index.html","hash":"ff057e13e589128c16343ded899c578699a957b2","modified":1565252138986},{"_id":"public/post/2018-08-03-浏览器缓存知识小结及应用/index.html","hash":"f3772343707f8131b998d26344ddbe79e4f24bf6","modified":1565252138986},{"_id":"public/post/2018-07-27-Vuex源码读后感/index.html","hash":"3c764ef401d68bef05585a61029aea9dc6ac5ce9","modified":1565252138986},{"_id":"public/post/2018-07-26-Vuex源码分析/index.html","hash":"c75b018bf544267b8ab5c09d5152adc987a94488","modified":1565252138986},{"_id":"public/post/2018-07-25-Vuex框架原理与源码分析/index.html","hash":"6e6302385383d6a9a3c9a965fd2003d6038dc988","modified":1565252138986},{"_id":"public/post/2018-07-23-前端性能优化-1/index.html","hash":"641391fa2939cb02f4e8217a9b218955f6912507","modified":1565252138986},{"_id":"public/post/2018-06-20-JS机制梳理总结/index.html","hash":"441f3f959dc4a02bfe7de3a912eaaf67f98083b6","modified":1565252138986},{"_id":"public/post/2018-07-23-前端性能优化-2/index.html","hash":"703a701f8146fa9f4b52f75ed5df94569e1c8132","modified":1565252138986},{"_id":"public/post/2018-06-10-你不知道的JS-4/index.html","hash":"bd90f671d6901281a929113fd4b5bfec9088045b","modified":1565252138986},{"_id":"public/post/2018-06-03-你不知道的JS-3/index.html","hash":"78e492743bbfc545ce5a592d0d032b478daf2d7c","modified":1565252138986},{"_id":"public/post/2018-05-25-你不知道的JS-2/index.html","hash":"0f7631ff71e12aa146fdbde62e36c8f5c177cfa4","modified":1565252138986},{"_id":"public/post/2018-05-14-你不知道的JS-1/index.html","hash":"86d37295be70603c43b9b53fc05aebac9bcbd8e0","modified":1565252138986},{"_id":"public/index.html","hash":"8323ae26f6012f69844efd52e5e048262ef0bac9","modified":1565252138986},{"_id":"public/tags/index.html","hash":"1a4d78cb89be0578d3c0587ff22b84a1eb2f4979","modified":1565252138986},{"_id":"public/page/2/index.html","hash":"797e746544c967c1e3b27496556e74859c0e7b96","modified":1565252138986},{"_id":"public/tags/CSS/index.html","hash":"1c0ceecf69394775b0e7b2ebfacb65cc4d957ead","modified":1565252138986},{"_id":"public/tags/ES6/index.html","hash":"1969f9bd89f947b5cba943a160dd956c9370fdeb","modified":1565252138986},{"_id":"public/tags/JS机制/index.html","hash":"43bda84264087c4e83c639a7a31af05f25a2204e","modified":1565252138986},{"_id":"public/tags/JavaScript/index.html","hash":"154a912000d9ab937ba03559efb09ebf4c742f19","modified":1565252138987},{"_id":"public/tags/Promise/index.html","hash":"b92fc05296718902911b962e39a5423378988439","modified":1565252138987},{"_id":"public/tags/flex布局/index.html","hash":"3e4d09ba17aa1c35a9ed2fe474f0bbfe47d64d2a","modified":1565252138987},{"_id":"public/tags/vue/index.html","hash":"d7b195422fa6bacc252d53026e1f53431e0f5c4e","modified":1565252138987},{"_id":"public/tags/你不知道的JS/index.html","hash":"40db2554dead462edfbdafa3cf03057f4077bc70","modified":1565252138987},{"_id":"public/tags/前端开发/index.html","hash":"4c2d9af979f98b72b9e090786e93ddfadba79eaa","modified":1565252138987},{"_id":"public/tags/前端开发/2/index.html","hash":"60fe898d7cbbb9b1653ffb4ea44c439528ff71d6","modified":1565252138987},{"_id":"public/tags/前端模块化/index.html","hash":"e351912e5ea01efd06d1f15bf6c5bd4168a5792f","modified":1565252138987},{"_id":"public/tags/年度总结/index.html","hash":"dfa1d07e983c822bcafc81c1c6b4bb0917a547de","modified":1565252138987},{"_id":"public/tags/性能优化/index.html","hash":"637b6cd1c8bdd8fbe0bc261be38701158b4cbc1d","modified":1565252138987},{"_id":"public/tags/碎碎念/index.html","hash":"ec753c06548b832250d947b57f44650bf9e5334e","modified":1565252138987},{"_id":"public/tags/缓存/index.html","hash":"81cee59ae194bd1de37b010706b3ffdd830dfad0","modified":1565252138989},{"_id":"public/archives/index.html","hash":"66443c0421f2b20fa7825093feb86c2c264d1424","modified":1565252138989},{"_id":"public/archives/2/index.html","hash":"95b0046aa14e5f80575f21853a57bac819a8291f","modified":1565252138989},{"_id":"public/config.999103777409c45e32aa.js","hash":"4bf112e3bf3bd8d7e59b19ab8ac8acf2fa3412aa","modified":1565252138989},{"_id":"public/theme.5b328618ffa2dc24bbbb.css","hash":"50c27942500c208bf2d340128913de5b194af69e","modified":1565252138989},{"_id":"public/favicon.ico","hash":"6cee16f547419ac6722b2e24eb6ab7b1ab7970d0","modified":1565252139001},{"_id":"public/icon-144x144.jpg","hash":"af710cc2ccf821fdc620793c1a503a624779341e","modified":1565252139001},{"_id":"public/icon-194x194.jpg","hash":"c23c16e6c7846e40d65980d89a37dc6c5eab8ade","modified":1565252139001},{"_id":"public/avatar.jpg","hash":"c3e5d063c2e395256c3b1891dce23624e810f542","modified":1565252139001},{"_id":"public/runtime.9c308a63d02029c20228.js","hash":"b62956c2192bfe5516d6374e753773901ed50ec5","modified":1565252139008},{"_id":"public/styles.27f292de72d9e7a2cdaf.css","hash":"0727dd630a30047ba5c6edc176dba5c3675e532b","modified":1565252139066},{"_id":"public/polyfills-es5.613d1909ec381c0aefb7.js","hash":"e3aac0d6ebd3f9f1286da2a0bbb8631c4642986c","modified":1565252139069},{"_id":"public/polyfills.23aa31104b29f3163090.js","hash":"a224860833f62a538bb6d17a97e71c72dfca79c1","modified":1565252139071},{"_id":"public/main.e8fb83af303ddf146491.zh-Hans.js","hash":"8704a8cd26a96351f7ec7cc1e7636aea5f6a1d28","modified":1565252139077}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"你不知道的JS-异步与性能","date":"2018-06-09T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n### 异步: 现在与稍后\n\n每当你将一部分代码包进 function 并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax应答等等），你就创建了一个**稍后**代码块儿，也因此在你的程序中引入了异步。\n\n#### 异步控制台\n\n使用 console 可能会遇到这样的情况：\n\n```js\nvar a = {\n\tindex: 1\n};\n\n// 稍后\nconsole.log( a ); // 可能{ index: 1 }，也可能{ index: 2 }。\n\n// 再稍后\na.index++;\n```\n\nconsole 不是 JavaScript 官方的一部分，而是由宿主环境添加到JS上的。所以关于它如何工作，没有相应的语言规范或一组需求。某些条件下，有些浏览器为了更好的性能选择在后台异步地处理 console I/O。所以有时候 console.log(..) 实际上不会立即输出它得到的东西。\n\n> 如果你遇到了这种罕见的情况，最好的选择是使用JS调试器的断点，而不是依赖console的输出。第二好的选择是通过将目标对象序列化为一个string强制取得一个它的快照，比如用JSON.stringify(..)。\n\n#### 事件轮询（Event Loop）\n\nJS 引擎对时间没有天生的感觉，反而是一个任意 JS 代码段的按需执行环境。是它周围的环境在不停地安排“事件”。\n\n通过一些伪代码来对它形成一个概念：\n\n```js\n// `eventLoop`是一个像队列一样的数组（先进先出）\nvar eventLoop = [ ];\nvar event;\n\n// “永远”执行\nwhile (true) {\n\t// 执行一个\"tick\"\n\tif (eventLoop.length > 0) {\n\t\t// 在队列中取得下一个事件\n\t\tevent = eventLoop.shift();\n\n\t\t// 现在执行下一个事件\n\t\ttry {\n\t\t\tevent();\n\t\t}\n\t\tcatch (err) {\n\t\t\treportError(err);\n\t\t}\n\t}\n}\n```\n\n有一个通过 while 循环来表现的持续不断的循环，这个循环的每一次迭代称为一个“tick”。在每一个“tick”中，如果队列中有一个事件在等待，它就会被取出执行。这些事件就是你的函数回调。\n\n#### 协作并发\n\n将一个长时间运行的“进程”打断为许多步骤或批处理，使得其他的并发“进程”有机会将它们的操作穿插进事件轮询队列。\n\n想象这种场景：\n\n```js\nvar res = [];\n\n// `response(..)`从Ajax调用收到一个结果数组\nfunction response(data) {\n\t// 连接到既存的`res`数组上\n\tres = res.concat(\n\t\t// 制造一个新的变形过的数组，所有的`data`值都翻倍\n\t\tdata.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n}\n\n// ajax(..) 是某个包中任意的Ajax函数\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n如果 \"http://some.url.1\" 首先返回它的结果，整个结果列表将会一次性映射进 res。如果只有几千或更少的结果记录，一般来说不是什么大事。但假如有1千万个记录，那么就可能会花一段时间运行。当这样的“处理”运行时，页面上没有任何事情可以发生，包括不能有另一个 response(..) 调用，不能有 UI 更新，甚至不能有用户事件比如滚动，打字，按钮点击等。非常痛苦。\n\n为了制造协作性更强、更友好而且不独占事件轮询队列的并发系统，你可以在一个异步批处理中处理这些结果，在批处理的每一步都“让出”事件轮询来让其他等待的事件发生：\n\n```js\nvar res = [];\n\n// `response(..)`从Ajax调用收到一个结果数组\nfunction response(data) {\n\t// 我们一次只处理1000件\n\tvar chunk = data.splice( 0, 1000 );\n\n\t// 连接到既存的`res`数组上\n\tres = res.concat(\n\t\t// 制造一个新的变形过的数组，所有的`data`值都翻倍\n\t\tchunk.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n\n\t// 还有东西要处理吗？\n\tif (data.length > 0) {\n\t\t// 异步规划下一个批处理\n\t\tsetTimeout( function(){\n\t\t\tresponse( data );\n\t\t}, 0 );\n\t}\n}\n\n// ajax(..) 是某个包中任意的Ajax函数\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n> 从技术上讲，setTimeout(..0) 没有直接将一条记录插入事件轮询队列。计时器将会在下一个运行机会将事件插入。比如，两个连续的 setTimeout(..0) 调用不会严格保证以调用的顺序被处理，所以我们可能看到各种时间偏移的情况，使这样的事件的顺序是不可预知的。\n\n### 回调","source":"_posts/2018-06-10-你不知道的JS-4.markdown","raw":"---\nlayout:     post\ntitle:      \"你不知道的JS-异步与性能\"\ndate:       2018-06-10\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - 你不知道的JS\n---\n\n### 异步: 现在与稍后\n\n每当你将一部分代码包进 function 并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax应答等等），你就创建了一个**稍后**代码块儿，也因此在你的程序中引入了异步。\n\n#### 异步控制台\n\n使用 console 可能会遇到这样的情况：\n\n```js\nvar a = {\n\tindex: 1\n};\n\n// 稍后\nconsole.log( a ); // 可能{ index: 1 }，也可能{ index: 2 }。\n\n// 再稍后\na.index++;\n```\n\nconsole 不是 JavaScript 官方的一部分，而是由宿主环境添加到JS上的。所以关于它如何工作，没有相应的语言规范或一组需求。某些条件下，有些浏览器为了更好的性能选择在后台异步地处理 console I/O。所以有时候 console.log(..) 实际上不会立即输出它得到的东西。\n\n> 如果你遇到了这种罕见的情况，最好的选择是使用JS调试器的断点，而不是依赖console的输出。第二好的选择是通过将目标对象序列化为一个string强制取得一个它的快照，比如用JSON.stringify(..)。\n\n#### 事件轮询（Event Loop）\n\nJS 引擎对时间没有天生的感觉，反而是一个任意 JS 代码段的按需执行环境。是它周围的环境在不停地安排“事件”。\n\n通过一些伪代码来对它形成一个概念：\n\n```js\n// `eventLoop`是一个像队列一样的数组（先进先出）\nvar eventLoop = [ ];\nvar event;\n\n// “永远”执行\nwhile (true) {\n\t// 执行一个\"tick\"\n\tif (eventLoop.length > 0) {\n\t\t// 在队列中取得下一个事件\n\t\tevent = eventLoop.shift();\n\n\t\t// 现在执行下一个事件\n\t\ttry {\n\t\t\tevent();\n\t\t}\n\t\tcatch (err) {\n\t\t\treportError(err);\n\t\t}\n\t}\n}\n```\n\n有一个通过 while 循环来表现的持续不断的循环，这个循环的每一次迭代称为一个“tick”。在每一个“tick”中，如果队列中有一个事件在等待，它就会被取出执行。这些事件就是你的函数回调。\n\n#### 协作并发\n\n将一个长时间运行的“进程”打断为许多步骤或批处理，使得其他的并发“进程”有机会将它们的操作穿插进事件轮询队列。\n\n想象这种场景：\n\n```js\nvar res = [];\n\n// `response(..)`从Ajax调用收到一个结果数组\nfunction response(data) {\n\t// 连接到既存的`res`数组上\n\tres = res.concat(\n\t\t// 制造一个新的变形过的数组，所有的`data`值都翻倍\n\t\tdata.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n}\n\n// ajax(..) 是某个包中任意的Ajax函数\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n如果 \"http://some.url.1\" 首先返回它的结果，整个结果列表将会一次性映射进 res。如果只有几千或更少的结果记录，一般来说不是什么大事。但假如有1千万个记录，那么就可能会花一段时间运行。当这样的“处理”运行时，页面上没有任何事情可以发生，包括不能有另一个 response(..) 调用，不能有 UI 更新，甚至不能有用户事件比如滚动，打字，按钮点击等。非常痛苦。\n\n为了制造协作性更强、更友好而且不独占事件轮询队列的并发系统，你可以在一个异步批处理中处理这些结果，在批处理的每一步都“让出”事件轮询来让其他等待的事件发生：\n\n```js\nvar res = [];\n\n// `response(..)`从Ajax调用收到一个结果数组\nfunction response(data) {\n\t// 我们一次只处理1000件\n\tvar chunk = data.splice( 0, 1000 );\n\n\t// 连接到既存的`res`数组上\n\tres = res.concat(\n\t\t// 制造一个新的变形过的数组，所有的`data`值都翻倍\n\t\tchunk.map( function(val){\n\t\t\treturn val * 2;\n\t\t} )\n\t);\n\n\t// 还有东西要处理吗？\n\tif (data.length > 0) {\n\t\t// 异步规划下一个批处理\n\t\tsetTimeout( function(){\n\t\t\tresponse( data );\n\t\t}, 0 );\n\t}\n}\n\n// ajax(..) 是某个包中任意的Ajax函数\najax( \"http://some.url.1\", response );\najax( \"http://some.url.2\", response );\n```\n\n> 从技术上讲，setTimeout(..0) 没有直接将一条记录插入事件轮询队列。计时器将会在下一个运行机会将事件插入。比如，两个连续的 setTimeout(..0) 调用不会严格保证以调用的顺序被处理，所以我们可能看到各种时间偏移的情况，使这样的事件的顺序是不可预知的。\n\n### 回调","slug":"2018-06-10-你不知道的JS-4","published":1,"updated":"2019-01-02T08:49:00.220Z","comments":0,"photos":[],"link":"post/2018-06-10-你不知道的JS-4","_id":"cjz2epjdt0000n3w51nhm1125","content":"<h3 id=\"异步-现在与稍后\">异步: 现在与稍后<a href=\"post/2018-06-10-你不知道的JS-4#异步-现在与稍后\"></a></h3><p>每当你将一部分代码包进 function 并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax应答等等），你就创建了一个<strong>稍后</strong>代码块儿，也因此在你的程序中引入了异步。</p>\n<h4 id=\"异步控制台\">异步控制台<a href=\"post/2018-06-10-你不知道的JS-4#异步控制台\"></a></h4><p>使用 console 可能会遇到这样的情况：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\tindex: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 稍后</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 可能&#123; index: 1 &#125;，也可能&#123; index: 2 &#125;。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再稍后</span></span><br><span class=\"line\">a.index++;</span><br></pre></td></tr></table></div></figure>\n<p>console 不是 JavaScript 官方的一部分，而是由宿主环境添加到JS上的。所以关于它如何工作，没有相应的语言规范或一组需求。某些条件下，有些浏览器为了更好的性能选择在后台异步地处理 console I/O。所以有时候 console.log(..) 实际上不会立即输出它得到的东西。</p>\n<blockquote>\n<p>如果你遇到了这种罕见的情况，最好的选择是使用JS调试器的断点，而不是依赖console的输出。第二好的选择是通过将目标对象序列化为一个string强制取得一个它的快照，比如用JSON.stringify(..)。</p>\n</blockquote>\n<h4 id=\"事件轮询（Event-Loop）\">事件轮询（Event Loop）<a href=\"post/2018-06-10-你不知道的JS-4#事件轮询（Event-Loop）\"></a></h4><p>JS 引擎对时间没有天生的感觉，反而是一个任意 JS 代码段的按需执行环境。是它周围的环境在不停地安排“事件”。</p>\n<p>通过一些伪代码来对它形成一个概念：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `eventLoop`是一个像队列一样的数组（先进先出）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> eventLoop = [ ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> event;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// “永远”执行</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行一个\"tick\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (eventLoop.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 在队列中取得下一个事件</span></span><br><span class=\"line\">\t\tevent = eventLoop.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 现在执行下一个事件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tevent();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">\t\t\treportError(err);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>有一个通过 while 循环来表现的持续不断的循环，这个循环的每一次迭代称为一个“tick”。在每一个“tick”中，如果队列中有一个事件在等待，它就会被取出执行。这些事件就是你的函数回调。</p>\n<h4 id=\"协作并发\">协作并发<a href=\"post/2018-06-10-你不知道的JS-4#协作并发\"></a></h4><p>将一个长时间运行的“进程”打断为许多步骤或批处理，使得其他的并发“进程”有机会将它们的操作穿插进事件轮询队列。</p>\n<p>想象这种场景：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `response(..)`从Ajax调用收到一个结果数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 连接到既存的`res`数组上</span></span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t<span class=\"comment\">// 制造一个新的变形过的数组，所有的`data`值都翻倍</span></span><br><span class=\"line\">\t\tdata.map( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.1\"</span>, response );</span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.2\"</span>, response );</span><br></pre></td></tr></table></div></figure>\n<p>如果 “<a href=\"http://some.url.1&quot;\" target=\"_blank\" rel=\"noopener\">http://some.url.1&quot;</a> 首先返回它的结果，整个结果列表将会一次性映射进 res。如果只有几千或更少的结果记录，一般来说不是什么大事。但假如有1千万个记录，那么就可能会花一段时间运行。当这样的“处理”运行时，页面上没有任何事情可以发生，包括不能有另一个 response(..) 调用，不能有 UI 更新，甚至不能有用户事件比如滚动，打字，按钮点击等。非常痛苦。</p>\n<p>为了制造协作性更强、更友好而且不独占事件轮询队列的并发系统，你可以在一个异步批处理中处理这些结果，在批处理的每一步都“让出”事件轮询来让其他等待的事件发生：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `response(..)`从Ajax调用收到一个结果数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 我们一次只处理1000件</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> chunk = data.splice( <span class=\"number\">0</span>, <span class=\"number\">1000</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 连接到既存的`res`数组上</span></span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t<span class=\"comment\">// 制造一个新的变形过的数组，所有的`data`值都翻倍</span></span><br><span class=\"line\">\t\tchunk.map( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 还有东西要处理吗？</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (data.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 异步规划下一个批处理</span></span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\tresponse( data );</span><br><span class=\"line\">\t\t&#125;, <span class=\"number\">0</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.1\"</span>, response );</span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.2\"</span>, response );</span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>从技术上讲，setTimeout(..0) 没有直接将一条记录插入事件轮询队列。计时器将会在下一个运行机会将事件插入。比如，两个连续的 setTimeout(..0) 调用不会严格保证以调用的顺序被处理，所以我们可能看到各种时间偏移的情况，使这样的事件的顺序是不可预知的。</p>\n</blockquote>\n<h3 id=\"回调\">回调<a href=\"post/2018-06-10-你不知道的JS-4#回调\"></a></h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"异步-现在与稍后\"><a href=\"#异步-现在与稍后\" class=\"headerlink\" title=\"异步: 现在与稍后\"></a>异步: 现在与稍后</h3><p>每当你将一部分代码包进 function 并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax应答等等），你就创建了一个<strong>稍后</strong>代码块儿，也因此在你的程序中引入了异步。</p>\n<h4 id=\"异步控制台\"><a href=\"#异步控制台\" class=\"headerlink\" title=\"异步控制台\"></a>异步控制台</h4><p>使用 console 可能会遇到这样的情况：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\tindex: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 稍后</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 可能&#123; index: 1 &#125;，也可能&#123; index: 2 &#125;。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再稍后</span></span><br><span class=\"line\">a.index++;</span><br></pre></td></tr></table></figure>\n<p>console 不是 JavaScript 官方的一部分，而是由宿主环境添加到JS上的。所以关于它如何工作，没有相应的语言规范或一组需求。某些条件下，有些浏览器为了更好的性能选择在后台异步地处理 console I/O。所以有时候 console.log(..) 实际上不会立即输出它得到的东西。</p>\n<blockquote>\n<p>如果你遇到了这种罕见的情况，最好的选择是使用JS调试器的断点，而不是依赖console的输出。第二好的选择是通过将目标对象序列化为一个string强制取得一个它的快照，比如用JSON.stringify(..)。</p>\n</blockquote>\n<h4 id=\"事件轮询（Event-Loop）\"><a href=\"#事件轮询（Event-Loop）\" class=\"headerlink\" title=\"事件轮询（Event Loop）\"></a>事件轮询（Event Loop）</h4><p>JS 引擎对时间没有天生的感觉，反而是一个任意 JS 代码段的按需执行环境。是它周围的环境在不停地安排“事件”。</p>\n<p>通过一些伪代码来对它形成一个概念：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `eventLoop`是一个像队列一样的数组（先进先出）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> eventLoop = [ ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> event;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// “永远”执行</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行一个\"tick\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (eventLoop.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 在队列中取得下一个事件</span></span><br><span class=\"line\">\t\tevent = eventLoop.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 现在执行下一个事件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tevent();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">\t\t\treportError(err);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有一个通过 while 循环来表现的持续不断的循环，这个循环的每一次迭代称为一个“tick”。在每一个“tick”中，如果队列中有一个事件在等待，它就会被取出执行。这些事件就是你的函数回调。</p>\n<h4 id=\"协作并发\"><a href=\"#协作并发\" class=\"headerlink\" title=\"协作并发\"></a>协作并发</h4><p>将一个长时间运行的“进程”打断为许多步骤或批处理，使得其他的并发“进程”有机会将它们的操作穿插进事件轮询队列。</p>\n<p>想象这种场景：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `response(..)`从Ajax调用收到一个结果数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 连接到既存的`res`数组上</span></span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t<span class=\"comment\">// 制造一个新的变形过的数组，所有的`data`值都翻倍</span></span><br><span class=\"line\">\t\tdata.map( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.1\"</span>, response );</span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.2\"</span>, response );</span><br></pre></td></tr></table></figure>\n<p>如果 “<a href=\"http://some.url.1&quot;\" target=\"_blank\" rel=\"noopener\">http://some.url.1&quot;</a> 首先返回它的结果，整个结果列表将会一次性映射进 res。如果只有几千或更少的结果记录，一般来说不是什么大事。但假如有1千万个记录，那么就可能会花一段时间运行。当这样的“处理”运行时，页面上没有任何事情可以发生，包括不能有另一个 response(..) 调用，不能有 UI 更新，甚至不能有用户事件比如滚动，打字，按钮点击等。非常痛苦。</p>\n<p>为了制造协作性更强、更友好而且不独占事件轮询队列的并发系统，你可以在一个异步批处理中处理这些结果，在批处理的每一步都“让出”事件轮询来让其他等待的事件发生：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `response(..)`从Ajax调用收到一个结果数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 我们一次只处理1000件</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> chunk = data.splice( <span class=\"number\">0</span>, <span class=\"number\">1000</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 连接到既存的`res`数组上</span></span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t<span class=\"comment\">// 制造一个新的变形过的数组，所有的`data`值都翻倍</span></span><br><span class=\"line\">\t\tchunk.map( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 还有东西要处理吗？</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (data.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 异步规划下一个批处理</span></span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\tresponse( data );</span><br><span class=\"line\">\t\t&#125;, <span class=\"number\">0</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.1\"</span>, response );</span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.2\"</span>, response );</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从技术上讲，setTimeout(..0) 没有直接将一条记录插入事件轮询队列。计时器将会在下一个运行机会将事件插入。比如，两个连续的 setTimeout(..0) 调用不会严格保证以调用的顺序被处理，所以我们可能看到各种时间偏移的情况，使这样的事件的顺序是不可预知的。</p>\n</blockquote>\n<h3 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h3>","plink":"https://vincentdou.github.io/blog/post/2018-06-10-你不知道的JS-4/","type":"post"},{"layout":"post","title":"前端性能优化-1","date":"2018-07-22T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n## DOM 操作篇\n\n#### 缓存DOM对象\n\n很基本的一个做法，在 for 循环前把要操作的 DOM 节点先获取到，而不是每次遍历都重新获取。\n\n#### 在内存中操作元素\n\n利用`document.createDocumentFragment()`可以创建内存节点。\n\n由于 DOM 操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。\n\n```\nvar ulNode = document.getElementById(\"container\");\nvar liNode, i, m;\nvar fragment = document.createDocumentFragment();\nfor (i = 0, m = data.length; i < m; i++) {\n    liNode = document.createElement(\"li\");\n    liNode.innerText = data[i];\n    fragment.appendChild(liNode);\n}\nulNode.appendChild(fragment);\n```\n\n这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（`cloneNode()`），在内存中进行操作后再替换原来的节点。\n\n避免过多的触发回流，是性能优化的一个思路。\n\n#### 通过事件代理批量操作事件\n\n我们可以通过事件代理的方式，将事件绑定在父节点上，然后通过`event.target`来确定被点击的元素是否是要绑定的子节点。\n\n这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了。\n\n## Javascript\n\n#### 垃圾回收器回收机制\n\n- `delete`这种方式可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化；而通过将变量或对象的属性设为`null`这种方式，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。相对而言，设为`null`这种方式不会改变对象的结构，比使用delete要好。\n- 垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收，而全局对象就是根对象。\n\n#### 对象的优化\n\nJavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 > 数组下标获取（对象的整数索引获取） > 对象属性获取（对象非整数索引获取）。因\b此我们可以通过缓存需要被使用的对象的某属性的方式\b进行优化。\n\n#### 使用原生方法\n\n在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如Math之类的原生对象和方法。\n","source":"_posts/2018-07-23-前端性能优化-1.markdown","raw":"---\nlayout:     post\ntitle:      \"前端性能优化-1\"\ndate:       2018-07-23\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - 性能优化\n---\n\n## DOM 操作篇\n\n#### 缓存DOM对象\n\n很基本的一个做法，在 for 循环前把要操作的 DOM 节点先获取到，而不是每次遍历都重新获取。\n\n#### 在内存中操作元素\n\n利用`document.createDocumentFragment()`可以创建内存节点。\n\n由于 DOM 操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。\n\n```\nvar ulNode = document.getElementById(\"container\");\nvar liNode, i, m;\nvar fragment = document.createDocumentFragment();\nfor (i = 0, m = data.length; i < m; i++) {\n    liNode = document.createElement(\"li\");\n    liNode.innerText = data[i];\n    fragment.appendChild(liNode);\n}\nulNode.appendChild(fragment);\n```\n\n这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（`cloneNode()`），在内存中进行操作后再替换原来的节点。\n\n避免过多的触发回流，是性能优化的一个思路。\n\n#### 通过事件代理批量操作事件\n\n我们可以通过事件代理的方式，将事件绑定在父节点上，然后通过`event.target`来确定被点击的元素是否是要绑定的子节点。\n\n这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了。\n\n## Javascript\n\n#### 垃圾回收器回收机制\n\n- `delete`这种方式可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化；而通过将变量或对象的属性设为`null`这种方式，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。相对而言，设为`null`这种方式不会改变对象的结构，比使用delete要好。\n- 垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收，而全局对象就是根对象。\n\n#### 对象的优化\n\nJavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 > 数组下标获取（对象的整数索引获取） > 对象属性获取（对象非整数索引获取）。因\b此我们可以通过缓存需要被使用的对象的某属性的方式\b进行优化。\n\n#### 使用原生方法\n\n在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如Math之类的原生对象和方法。\n","slug":"2018-07-23-前端性能优化-1","published":1,"updated":"2019-01-02T08:49:00.221Z","comments":0,"photos":[],"link":"post/2018-07-23-前端性能优化-1","_id":"cjz2epjdy0001n3w58wh1d39c","content":"<h2 id=\"DOM-操作篇\">DOM 操作篇<a href=\"post/2018-07-23-前端性能优化-1#DOM-操作篇\"></a></h2><h4 id=\"缓存DOM对象\">缓存DOM对象<a href=\"post/2018-07-23-前端性能优化-1#缓存DOM对象\"></a></h4><p>很基本的一个做法，在 for 循环前把要操作的 DOM 节点先获取到，而不是每次遍历都重新获取。</p>\n<h4 id=\"在内存中操作元素\">在内存中操作元素<a href=\"post/2018-07-23-前端性能优化-1#在内存中操作元素\"></a></h4><p>利用<code>document.createDocumentFragment()</code>可以创建内存节点。</p>\n<p>由于 DOM 操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ulNode = document.getElementById(&quot;container&quot;);</span><br><span class=\"line\">var liNode, i, m;</span><br><span class=\"line\">var fragment = document.createDocumentFragment();</span><br><span class=\"line\">for (i = 0, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    liNode = document.createElement(&quot;li&quot;);</span><br><span class=\"line\">    liNode.innerText = data[i];</span><br><span class=\"line\">    fragment.appendChild(liNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ulNode.appendChild(fragment);</span><br></pre></td></tr></table></div></figure>\n<p>这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（<code>cloneNode()</code>），在内存中进行操作后再替换原来的节点。</p>\n<p>避免过多的触发回流，是性能优化的一个思路。</p>\n<h4 id=\"通过事件代理批量操作事件\">通过事件代理批量操作事件<a href=\"post/2018-07-23-前端性能优化-1#通过事件代理批量操作事件\"></a></h4><p>我们可以通过事件代理的方式，将事件绑定在父节点上，然后通过<code>event.target</code>来确定被点击的元素是否是要绑定的子节点。</p>\n<p>这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了。</p>\n<h2 id=\"Javascript\">Javascript<a href=\"post/2018-07-23-前端性能优化-1#Javascript\"></a></h2><h4 id=\"垃圾回收器回收机制\">垃圾回收器回收机制<a href=\"post/2018-07-23-前端性能优化-1#垃圾回收器回收机制\"></a></h4><ul>\n<li><code>delete</code>这种方式可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化；而通过将变量或对象的属性设为<code>null</code>这种方式，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。相对而言，设为<code>null</code>这种方式不会改变对象的结构，比使用delete要好。</li>\n<li>垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收，而全局对象就是根对象。</li>\n</ul>\n<h4 id=\"对象的优化\">对象的优化<a href=\"post/2018-07-23-前端性能优化-1#对象的优化\"></a></h4><p>JavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 &gt; 数组下标获取（对象的整数索引获取） &gt; 对象属性获取（对象非整数索引获取）。因\b此我们可以通过缓存需要被使用的对象的某属性的方式\b进行优化。</p>\n<h4 id=\"使用原生方法\">使用原生方法<a href=\"post/2018-07-23-前端性能优化-1#使用原生方法\"></a></h4><p>在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如Math之类的原生对象和方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"DOM-操作篇\"><a href=\"#DOM-操作篇\" class=\"headerlink\" title=\"DOM 操作篇\"></a>DOM 操作篇</h2><h4 id=\"缓存DOM对象\"><a href=\"#缓存DOM对象\" class=\"headerlink\" title=\"缓存DOM对象\"></a>缓存DOM对象</h4><p>很基本的一个做法，在 for 循环前把要操作的 DOM 节点先获取到，而不是每次遍历都重新获取。</p>\n<h4 id=\"在内存中操作元素\"><a href=\"#在内存中操作元素\" class=\"headerlink\" title=\"在内存中操作元素\"></a>在内存中操作元素</h4><p>利用<code>document.createDocumentFragment()</code>可以创建内存节点。</p>\n<p>由于 DOM 操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ulNode = document.getElementById(&quot;container&quot;);</span><br><span class=\"line\">var liNode, i, m;</span><br><span class=\"line\">var fragment = document.createDocumentFragment();</span><br><span class=\"line\">for (i = 0, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    liNode = document.createElement(&quot;li&quot;);</span><br><span class=\"line\">    liNode.innerText = data[i];</span><br><span class=\"line\">    fragment.appendChild(liNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ulNode.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<p>这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（<code>cloneNode()</code>），在内存中进行操作后再替换原来的节点。</p>\n<p>避免过多的触发回流，是性能优化的一个思路。</p>\n<h4 id=\"通过事件代理批量操作事件\"><a href=\"#通过事件代理批量操作事件\" class=\"headerlink\" title=\"通过事件代理批量操作事件\"></a>通过事件代理批量操作事件</h4><p>我们可以通过事件代理的方式，将事件绑定在父节点上，然后通过<code>event.target</code>来确定被点击的元素是否是要绑定的子节点。</p>\n<p>这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了。</p>\n<h2 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a>Javascript</h2><h4 id=\"垃圾回收器回收机制\"><a href=\"#垃圾回收器回收机制\" class=\"headerlink\" title=\"垃圾回收器回收机制\"></a>垃圾回收器回收机制</h4><ul>\n<li><code>delete</code>这种方式可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化；而通过将变量或对象的属性设为<code>null</code>这种方式，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。相对而言，设为<code>null</code>这种方式不会改变对象的结构，比使用delete要好。</li>\n<li>垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收，而全局对象就是根对象。</li>\n</ul>\n<h4 id=\"对象的优化\"><a href=\"#对象的优化\" class=\"headerlink\" title=\"对象的优化\"></a>对象的优化</h4><p>JavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 &gt; 数组下标获取（对象的整数索引获取） &gt; 对象属性获取（对象非整数索引获取）。因\b此我们可以通过缓存需要被使用的对象的某属性的方式\b进行优化。</p>\n<h4 id=\"使用原生方法\"><a href=\"#使用原生方法\" class=\"headerlink\" title=\"使用原生方法\"></a>使用原生方法</h4><p>在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如Math之类的原生对象和方法。</p>\n","plink":"https://vincentdou.github.io/blog/post/2018-07-23-前端性能优化-1/","type":"post","toc":[{"title":"DOM 操作篇","id":"DOM-操作篇","index":"1"},{"title":"Javascript","id":"Javascript","index":"2"}]},{"layout":"post","title":"前端性能优化-2","date":"2018-07-22T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n## 动画篇\n\n#### 层？重绘？回流和重布局？图层重组？\n\n首先要了解CSS的图层的概念（Chrome浏览器）\n\n浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染DOM的时候，浏览器所做的工作实际上是：\n\n1. 获取DOM后分割为多个图层\n2. 对每个图层的节点计算样式结果（Recalculate style--样式重计算）\n3. 为每个节点生成图形和位置（Layout--**回流和重布局**）\n4. 将每个节点绘制填充到图层位图中（Paint Setup和Paint--**重绘**）\n5. 图层作为纹理上传至GPU\n6. 符合多个图层到页面上生成最终屏幕图像（Composite Layers--**图层重组**）\n\nChrome中满足以下任意情况就会创建图层：\n\n* 3D或透视变换（perspective transform）CSS属性\n* 使用加速视频解码的`<video>`节点\n* 拥有3D（WebGL）上下文或加速的2D上下文的`<canvas>`节点\n* 混合插件（如Flash）\n* 对自己的opacity做CSS动画或使用一个动画webkit变换的元素\n* 拥有加速CSS过滤器的元素\n* 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）\n* 元素有一个`z-index`较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）\n\n需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制gif图属于自己一个图层（translateZ(0)或者translate3d(0,0,0)），CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）。\n\n#### 触发重布局的属性\n\n有些节点，当你改变他时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。所以需要尽力避免这些属性。\n\n一些常用的改变时会触发重布局的属性：\n\n1. 盒子模型相关属性会触发重布局：\n\n    * width\n    * height\n    * padding\n    * margin\n    * display\n    * border-width\n    * border\n    * min-height\n\n2. 定位属性及浮动也会触发重布局：\n\n    * top\n    * bottom\n    * left\n    * right\n    * position\n    * float\n    * clear\n\n3. 改变节点内部文字结构也会触发重布局：\n\n    * text-align\n    * overflow-y\n    * font-weight\n    * overflow\n    * font-family\n    * line-height\n    * vertival-align\n    * white-space\n    * font-size\n\n这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局。\n\n#### 触发重绘的属性\n\n修改时只触发重绘的属性有：\n\n* color\n* border-style\n* border-radius\n* visibility\n* text-decoration\n* background\n* background-image\n* background-position\n* background-repeat\n* background-size\n* outline-color\n* outline\n* outline-style\n* outline-width\n* box-shadow\n\n这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了。\n\n#### 强迫浏览器创建图层\n\n在 Blink 和 WebKit 的浏览器中，一当一个节点被设定了透明度的相关过渡效果或动画时，浏览器会将其作为一个单独的图层，但很多开发者使用 translateZ(0) 或者 translate3d(0,0,0) 去使浏览器创建图层。这种方式可以消除在动画开始之前的图层创建时间，使得动画尽快开始（创建图层和绘制图层还是比较慢的），而且不会随着抗锯齿而导出突变。不过这种方法需要节制，否则会因为创建过多的图层导致崩溃。","source":"_posts/2018-07-23-前端性能优化-2.markdown","raw":"---\nlayout:     post\ntitle:      \"前端性能优化-2\"\ndate:       2018-07-23\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - 性能优化\n---\n\n## 动画篇\n\n#### 层？重绘？回流和重布局？图层重组？\n\n首先要了解CSS的图层的概念（Chrome浏览器）\n\n浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染DOM的时候，浏览器所做的工作实际上是：\n\n1. 获取DOM后分割为多个图层\n2. 对每个图层的节点计算样式结果（Recalculate style--样式重计算）\n3. 为每个节点生成图形和位置（Layout--**回流和重布局**）\n4. 将每个节点绘制填充到图层位图中（Paint Setup和Paint--**重绘**）\n5. 图层作为纹理上传至GPU\n6. 符合多个图层到页面上生成最终屏幕图像（Composite Layers--**图层重组**）\n\nChrome中满足以下任意情况就会创建图层：\n\n* 3D或透视变换（perspective transform）CSS属性\n* 使用加速视频解码的`<video>`节点\n* 拥有3D（WebGL）上下文或加速的2D上下文的`<canvas>`节点\n* 混合插件（如Flash）\n* 对自己的opacity做CSS动画或使用一个动画webkit变换的元素\n* 拥有加速CSS过滤器的元素\n* 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）\n* 元素有一个`z-index`较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）\n\n需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制gif图属于自己一个图层（translateZ(0)或者translate3d(0,0,0)），CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）。\n\n#### 触发重布局的属性\n\n有些节点，当你改变他时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。所以需要尽力避免这些属性。\n\n一些常用的改变时会触发重布局的属性：\n\n1. 盒子模型相关属性会触发重布局：\n\n    * width\n    * height\n    * padding\n    * margin\n    * display\n    * border-width\n    * border\n    * min-height\n\n2. 定位属性及浮动也会触发重布局：\n\n    * top\n    * bottom\n    * left\n    * right\n    * position\n    * float\n    * clear\n\n3. 改变节点内部文字结构也会触发重布局：\n\n    * text-align\n    * overflow-y\n    * font-weight\n    * overflow\n    * font-family\n    * line-height\n    * vertival-align\n    * white-space\n    * font-size\n\n这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局。\n\n#### 触发重绘的属性\n\n修改时只触发重绘的属性有：\n\n* color\n* border-style\n* border-radius\n* visibility\n* text-decoration\n* background\n* background-image\n* background-position\n* background-repeat\n* background-size\n* outline-color\n* outline\n* outline-style\n* outline-width\n* box-shadow\n\n这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了。\n\n#### 强迫浏览器创建图层\n\n在 Blink 和 WebKit 的浏览器中，一当一个节点被设定了透明度的相关过渡效果或动画时，浏览器会将其作为一个单独的图层，但很多开发者使用 translateZ(0) 或者 translate3d(0,0,0) 去使浏览器创建图层。这种方式可以消除在动画开始之前的图层创建时间，使得动画尽快开始（创建图层和绘制图层还是比较慢的），而且不会随着抗锯齿而导出突变。不过这种方法需要节制，否则会因为创建过多的图层导致崩溃。","slug":"2018-07-23-前端性能优化-2","published":1,"updated":"2019-01-02T08:49:00.266Z","comments":0,"photos":[],"link":"post/2018-07-23-前端性能优化-2","_id":"cjz2epje20003n3w5xl9436aj","content":"<h2 id=\"动画篇\">动画篇<a href=\"post/2018-07-23-前端性能优化-2#动画篇\"></a></h2><h4 id=\"层？重绘？回流和重布局？图层重组？\">层？重绘？回流和重布局？图层重组？<a href=\"post/2018-07-23-前端性能优化-2#层？重绘？回流和重布局？图层重组？\"></a></h4><p>首先要了解CSS的图层的概念（Chrome浏览器）</p>\n<p>浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染DOM的时候，浏览器所做的工作实际上是：</p>\n<ol>\n<li>获取DOM后分割为多个图层</li>\n<li>对每个图层的节点计算样式结果（Recalculate style–样式重计算）</li>\n<li>为每个节点生成图形和位置（Layout–<strong>回流和重布局</strong>）</li>\n<li>将每个节点绘制填充到图层位图中（Paint Setup和Paint–<strong>重绘</strong>）</li>\n<li>图层作为纹理上传至GPU</li>\n<li>符合多个图层到页面上生成最终屏幕图像（Composite Layers–<strong>图层重组</strong>）</li>\n</ol>\n<p>Chrome中满足以下任意情况就会创建图层：</p>\n<ul>\n<li>3D或透视变换（perspective transform）CSS属性</li>\n<li>使用加速视频解码的<code>&lt;video&gt;</code>节点</li>\n<li>拥有3D（WebGL）上下文或加速的2D上下文的<code>&lt;canvas&gt;</code>节点</li>\n<li>混合插件（如Flash）</li>\n<li>对自己的opacity做CSS动画或使用一个动画webkit变换的元素</li>\n<li>拥有加速CSS过滤器的元素</li>\n<li>元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）</li>\n<li>元素有一个<code>z-index</code>较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</li>\n</ul>\n<p>需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制gif图属于自己一个图层（translateZ(0)或者translate3d(0,0,0)），CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）。</p>\n<h4 id=\"触发重布局的属性\">触发重布局的属性<a href=\"post/2018-07-23-前端性能优化-2#触发重布局的属性\"></a></h4><p>有些节点，当你改变他时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。所以需要尽力避免这些属性。</p>\n<p>一些常用的改变时会触发重布局的属性：</p>\n<ol>\n<li><p>盒子模型相关属性会触发重布局：</p>\n<ul>\n<li>width</li>\n<li>height</li>\n<li>padding</li>\n<li>margin</li>\n<li>display</li>\n<li>border-width</li>\n<li>border</li>\n<li>min-height</li>\n</ul>\n</li>\n<li><p>定位属性及浮动也会触发重布局：</p>\n<ul>\n<li>top</li>\n<li>bottom</li>\n<li>left</li>\n<li>right</li>\n<li>position</li>\n<li>float</li>\n<li>clear</li>\n</ul>\n</li>\n<li><p>改变节点内部文字结构也会触发重布局：</p>\n<ul>\n<li>text-align</li>\n<li>overflow-y</li>\n<li>font-weight</li>\n<li>overflow</li>\n<li>font-family</li>\n<li>line-height</li>\n<li>vertival-align</li>\n<li>white-space</li>\n<li>font-size</li>\n</ul>\n</li>\n</ol>\n<p>这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局。</p>\n<h4 id=\"触发重绘的属性\">触发重绘的属性<a href=\"post/2018-07-23-前端性能优化-2#触发重绘的属性\"></a></h4><p>修改时只触发重绘的属性有：</p>\n<ul>\n<li>color</li>\n<li>border-style</li>\n<li>border-radius</li>\n<li>visibility</li>\n<li>text-decoration</li>\n<li>background</li>\n<li>background-image</li>\n<li>background-position</li>\n<li>background-repeat</li>\n<li>background-size</li>\n<li>outline-color</li>\n<li>outline</li>\n<li>outline-style</li>\n<li>outline-width</li>\n<li>box-shadow</li>\n</ul>\n<p>这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了。</p>\n<h4 id=\"强迫浏览器创建图层\">强迫浏览器创建图层<a href=\"post/2018-07-23-前端性能优化-2#强迫浏览器创建图层\"></a></h4><p>在 Blink 和 WebKit 的浏览器中，一当一个节点被设定了透明度的相关过渡效果或动画时，浏览器会将其作为一个单独的图层，但很多开发者使用 translateZ(0) 或者 translate3d(0,0,0) 去使浏览器创建图层。这种方式可以消除在动画开始之前的图层创建时间，使得动画尽快开始（创建图层和绘制图层还是比较慢的），而且不会随着抗锯齿而导出突变。不过这种方法需要节制，否则会因为创建过多的图层导致崩溃。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"动画篇\"><a href=\"#动画篇\" class=\"headerlink\" title=\"动画篇\"></a>动画篇</h2><h4 id=\"层？重绘？回流和重布局？图层重组？\"><a href=\"#层？重绘？回流和重布局？图层重组？\" class=\"headerlink\" title=\"层？重绘？回流和重布局？图层重组？\"></a>层？重绘？回流和重布局？图层重组？</h4><p>首先要了解CSS的图层的概念（Chrome浏览器）</p>\n<p>浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染DOM的时候，浏览器所做的工作实际上是：</p>\n<ol>\n<li>获取DOM后分割为多个图层</li>\n<li>对每个图层的节点计算样式结果（Recalculate style–样式重计算）</li>\n<li>为每个节点生成图形和位置（Layout–<strong>回流和重布局</strong>）</li>\n<li>将每个节点绘制填充到图层位图中（Paint Setup和Paint–<strong>重绘</strong>）</li>\n<li>图层作为纹理上传至GPU</li>\n<li>符合多个图层到页面上生成最终屏幕图像（Composite Layers–<strong>图层重组</strong>）</li>\n</ol>\n<p>Chrome中满足以下任意情况就会创建图层：</p>\n<ul>\n<li>3D或透视变换（perspective transform）CSS属性</li>\n<li>使用加速视频解码的<code>&lt;video&gt;</code>节点</li>\n<li>拥有3D（WebGL）上下文或加速的2D上下文的<code>&lt;canvas&gt;</code>节点</li>\n<li>混合插件（如Flash）</li>\n<li>对自己的opacity做CSS动画或使用一个动画webkit变换的元素</li>\n<li>拥有加速CSS过滤器的元素</li>\n<li>元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）</li>\n<li>元素有一个<code>z-index</code>较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</li>\n</ul>\n<p>需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制gif图属于自己一个图层（translateZ(0)或者translate3d(0,0,0)），CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）。</p>\n<h4 id=\"触发重布局的属性\"><a href=\"#触发重布局的属性\" class=\"headerlink\" title=\"触发重布局的属性\"></a>触发重布局的属性</h4><p>有些节点，当你改变他时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。所以需要尽力避免这些属性。</p>\n<p>一些常用的改变时会触发重布局的属性：</p>\n<ol>\n<li><p>盒子模型相关属性会触发重布局：</p>\n<ul>\n<li>width</li>\n<li>height</li>\n<li>padding</li>\n<li>margin</li>\n<li>display</li>\n<li>border-width</li>\n<li>border</li>\n<li>min-height</li>\n</ul>\n</li>\n<li><p>定位属性及浮动也会触发重布局：</p>\n<ul>\n<li>top</li>\n<li>bottom</li>\n<li>left</li>\n<li>right</li>\n<li>position</li>\n<li>float</li>\n<li>clear</li>\n</ul>\n</li>\n<li><p>改变节点内部文字结构也会触发重布局：</p>\n<ul>\n<li>text-align</li>\n<li>overflow-y</li>\n<li>font-weight</li>\n<li>overflow</li>\n<li>font-family</li>\n<li>line-height</li>\n<li>vertival-align</li>\n<li>white-space</li>\n<li>font-size</li>\n</ul>\n</li>\n</ol>\n<p>这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局。</p>\n<h4 id=\"触发重绘的属性\"><a href=\"#触发重绘的属性\" class=\"headerlink\" title=\"触发重绘的属性\"></a>触发重绘的属性</h4><p>修改时只触发重绘的属性有：</p>\n<ul>\n<li>color</li>\n<li>border-style</li>\n<li>border-radius</li>\n<li>visibility</li>\n<li>text-decoration</li>\n<li>background</li>\n<li>background-image</li>\n<li>background-position</li>\n<li>background-repeat</li>\n<li>background-size</li>\n<li>outline-color</li>\n<li>outline</li>\n<li>outline-style</li>\n<li>outline-width</li>\n<li>box-shadow</li>\n</ul>\n<p>这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了。</p>\n<h4 id=\"强迫浏览器创建图层\"><a href=\"#强迫浏览器创建图层\" class=\"headerlink\" title=\"强迫浏览器创建图层\"></a>强迫浏览器创建图层</h4><p>在 Blink 和 WebKit 的浏览器中，一当一个节点被设定了透明度的相关过渡效果或动画时，浏览器会将其作为一个单独的图层，但很多开发者使用 translateZ(0) 或者 translate3d(0,0,0) 去使浏览器创建图层。这种方式可以消除在动画开始之前的图层创建时间，使得动画尽快开始（创建图层和绘制图层还是比较慢的），而且不会随着抗锯齿而导出突变。不过这种方法需要节制，否则会因为创建过多的图层导致崩溃。</p>\n","plink":"https://vincentdou.github.io/blog/post/2018-07-23-前端性能优化-2/","type":"post","toc":[{"title":"动画篇","id":"动画篇","index":"1"}]},{"layout":"post","title":"Vuex源码读后感","date":"2018-07-26T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> 这是一篇感想，不是 vuex 源码的导读。除了总结几个对 Vuex 的疑问，还有一些阅读源码的方法论可以分享。\n\n## 推荐两篇文章\n\n推荐两篇导读的文章：\n\n1. [Vuex 框架原理与源码分析](https://juejin.im/entry/5af5d048f265da0b7b35f94e)\n\n    > 美团前端团队的一篇文章，这篇文章是提出问题、解决问题的叙事风格，比较容易看的进去。\n\n2. [Vuex 2.0 源码分析](https://github.com/DDFE/DDFE-blog/issues/8)\n   \n    > 相对来说，这篇文章像是记叙文的风格，从暴露出的 API 开始进行接近逐行的分析，十分详细。\n\n## Q&A\n\n> 阅读源码前的几个疑惑，在阅读后得到了答案。\n\n### 1. `Vue.use(Vuex)`发生了什么？\n\n`Vue.use()`是 Vue 安装插件的方法，先看下它的代码：\n\n```js\nfunction (plugin: Function | Object) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    // 实际执行插件的 install 方法\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}\n```\n\n这里核心就是执行`plugin.install.apply(plugin, args)`，所以下一步看 Vuex 的 install 方法：\n\n```js\nfunction install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n\n再看 applyMixin：\n\n```js\nfunction (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n}\n```\n\n所以 Vuex 的 install 方法的核心就是在每个 Vue 组件初始化的时候执行 `vuexInit`，Vue 版本如果在 2.0 以上是在 init 或 beforeCreate 生命周期上，2.0 以下版本是修改 Vue 对象原型的_init方法。\n\n### 2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？\n\n看下 vuexInit 方法：\n\n```js\nfunction vuexInit () {\n  const options = this.$options\n  // store injection\n  if (options.store) {\n    this.$store = options.store\n  } else if (options.parent && options.parent.$store) {\n    this.$store = options.parent.$store\n  }\n}\n```\n\n这个函数将初始化 Vue 根组件时传入的 store 设置到 this 对象的`$store`属性上，子组件从其父组件引用`$store`属性，层层嵌套进行设置。这样，在任意组件中执行`this.$store`都能找到装载的那个 store 对象。这里的 this 指向一个 Vue 组件。\n\n### 3. strict 模式下不能直接修改 state，怎么做到的？\n\n在 resetStoreVM 方法中如果是严格模式会执行`enableStrictMode(store)`，看下这个函数：\n\n```js\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, () => {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)\n    }\n  }, { deep: true, sync: true })\n}\n```\n\n很短的一段代码，主要就是利用 Vue 的 watch 监测 state 的变化，用到断言函数，在 _committing 为`false`的时候进行报错。我们通过 mutation 修改 state 的时候都会经过 _withCommit：\n\n```js\n_withCommit (fn) {\n  const committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n}\n```\n\n这就是通过 mutation 修改 state 不会报错的原因。\n\n### 4. _vm 的主要意义是什么？\n\n_vm 是一个 Vue 组件，它的作用除了上面的 watch 以外，还有：\n\n- 把 state 存在`_vm`的`_data`的`$$state`属性上，并且让 store 的 state 指向这里。\n- 把 getter 存在`_vm`的`computed`上。\n\n## 启发\n\n### 1. `assert`断言函数\n\nassert函数是一个简单的断言函数的实现，一行代码即可实现。\n\n```js\nfunction assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n```\n\n用在条件的检测或者表单的校验上还是很方便的。\n\n### 2. `deepCopy`深拷贝\n\n```js\nfunction deepCopy (obj, cache = []) {\n  // just return if obj is immutable value\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  // if obj is hit, it is in circular structure\n  const hit = find(cache, c => c.original === obj)\n  if (hit) {\n    return hit.copy\n  }\n\n  const copy = Array.isArray(obj) ? [] : {}\n  // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n  cache.push({\n    original: obj,\n    copy\n  })\n\n  Object.keys(obj).forEach(key => {\n    copy[key] = deepCopy(obj[key], cache)\n  })\n\n  return copy\n}\n```\n\n这里的 deepCopy 也是采用构造一个新的对象，遍历原对象或者数组，递归调用自身的方式。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过`find(cache, c => c.original === obj)`发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。\n\n### 3. 阅读源码的方法\n\n一开始图省事，安装了一个叫 octotree 的 chrome 扩展，发现其实很麻烦，最好还是把源码 clone 下来用编辑器打开。另外把实例在控制台 console 出来也是很高效的一个做法。\n\n所以我在看代码的时候开了三个编辑器：看源码、打开一个用到 Vuex 的项目、写 markdown。切来切去有点懵的。","source":"_posts/2018-07-27-Vuex源码读后感.markdown","raw":"---\nlayout:     post\ntitle:      \"Vuex源码读后感\"\ndate:       2018-07-27\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - vue\n---\n\n> 这是一篇感想，不是 vuex 源码的导读。除了总结几个对 Vuex 的疑问，还有一些阅读源码的方法论可以分享。\n\n## 推荐两篇文章\n\n推荐两篇导读的文章：\n\n1. [Vuex 框架原理与源码分析](https://juejin.im/entry/5af5d048f265da0b7b35f94e)\n\n    > 美团前端团队的一篇文章，这篇文章是提出问题、解决问题的叙事风格，比较容易看的进去。\n\n2. [Vuex 2.0 源码分析](https://github.com/DDFE/DDFE-blog/issues/8)\n   \n    > 相对来说，这篇文章像是记叙文的风格，从暴露出的 API 开始进行接近逐行的分析，十分详细。\n\n## Q&A\n\n> 阅读源码前的几个疑惑，在阅读后得到了答案。\n\n### 1. `Vue.use(Vuex)`发生了什么？\n\n`Vue.use()`是 Vue 安装插件的方法，先看下它的代码：\n\n```js\nfunction (plugin: Function | Object) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    // 实际执行插件的 install 方法\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}\n```\n\n这里核心就是执行`plugin.install.apply(plugin, args)`，所以下一步看 Vuex 的 install 方法：\n\n```js\nfunction install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n\n再看 applyMixin：\n\n```js\nfunction (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n}\n```\n\n所以 Vuex 的 install 方法的核心就是在每个 Vue 组件初始化的时候执行 `vuexInit`，Vue 版本如果在 2.0 以上是在 init 或 beforeCreate 生命周期上，2.0 以下版本是修改 Vue 对象原型的_init方法。\n\n### 2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？\n\n看下 vuexInit 方法：\n\n```js\nfunction vuexInit () {\n  const options = this.$options\n  // store injection\n  if (options.store) {\n    this.$store = options.store\n  } else if (options.parent && options.parent.$store) {\n    this.$store = options.parent.$store\n  }\n}\n```\n\n这个函数将初始化 Vue 根组件时传入的 store 设置到 this 对象的`$store`属性上，子组件从其父组件引用`$store`属性，层层嵌套进行设置。这样，在任意组件中执行`this.$store`都能找到装载的那个 store 对象。这里的 this 指向一个 Vue 组件。\n\n### 3. strict 模式下不能直接修改 state，怎么做到的？\n\n在 resetStoreVM 方法中如果是严格模式会执行`enableStrictMode(store)`，看下这个函数：\n\n```js\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, () => {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)\n    }\n  }, { deep: true, sync: true })\n}\n```\n\n很短的一段代码，主要就是利用 Vue 的 watch 监测 state 的变化，用到断言函数，在 _committing 为`false`的时候进行报错。我们通过 mutation 修改 state 的时候都会经过 _withCommit：\n\n```js\n_withCommit (fn) {\n  const committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n}\n```\n\n这就是通过 mutation 修改 state 不会报错的原因。\n\n### 4. _vm 的主要意义是什么？\n\n_vm 是一个 Vue 组件，它的作用除了上面的 watch 以外，还有：\n\n- 把 state 存在`_vm`的`_data`的`$$state`属性上，并且让 store 的 state 指向这里。\n- 把 getter 存在`_vm`的`computed`上。\n\n## 启发\n\n### 1. `assert`断言函数\n\nassert函数是一个简单的断言函数的实现，一行代码即可实现。\n\n```js\nfunction assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n```\n\n用在条件的检测或者表单的校验上还是很方便的。\n\n### 2. `deepCopy`深拷贝\n\n```js\nfunction deepCopy (obj, cache = []) {\n  // just return if obj is immutable value\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  // if obj is hit, it is in circular structure\n  const hit = find(cache, c => c.original === obj)\n  if (hit) {\n    return hit.copy\n  }\n\n  const copy = Array.isArray(obj) ? [] : {}\n  // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n  cache.push({\n    original: obj,\n    copy\n  })\n\n  Object.keys(obj).forEach(key => {\n    copy[key] = deepCopy(obj[key], cache)\n  })\n\n  return copy\n}\n```\n\n这里的 deepCopy 也是采用构造一个新的对象，遍历原对象或者数组，递归调用自身的方式。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过`find(cache, c => c.original === obj)`发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。\n\n### 3. 阅读源码的方法\n\n一开始图省事，安装了一个叫 octotree 的 chrome 扩展，发现其实很麻烦，最好还是把源码 clone 下来用编辑器打开。另外把实例在控制台 console 出来也是很高效的一个做法。\n\n所以我在看代码的时候开了三个编辑器：看源码、打开一个用到 Vuex 的项目、写 markdown。切来切去有点懵的。","slug":"2018-07-27-Vuex源码读后感","published":1,"updated":"2019-01-02T08:49:00.262Z","comments":0,"photos":[],"link":"post/2018-07-27-Vuex源码读后感","_id":"cjz2epje30004n3w50xtxcfm8","content":"<blockquote>\n<p>这是一篇感想，不是 vuex 源码的导读。除了总结几个对 Vuex 的疑问，还有一些阅读源码的方法论可以分享。</p>\n</blockquote>\n<h2 id=\"推荐两篇文章\">推荐两篇文章<a href=\"post/2018-07-27-Vuex源码读后感#推荐两篇文章\"></a></h2><p>推荐两篇导读的文章：</p>\n<ol>\n<li><p><a href=\"https://juejin.im/entry/5af5d048f265da0b7b35f94e\" target=\"_blank\" rel=\"noopener\">Vuex 框架原理与源码分析</a></p>\n<blockquote>\n<p>美团前端团队的一篇文章，这篇文章是提出问题、解决问题的叙事风格，比较容易看的进去。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/DDFE/DDFE-blog/issues/8\" target=\"_blank\" rel=\"noopener\">Vuex 2.0 源码分析</a></p>\n<blockquote>\n<p>相对来说，这篇文章像是记叙文的风格，从暴露出的 API 开始进行接近逐行的分析，十分详细。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Q-amp-A\">Q&amp;A<a href=\"post/2018-07-27-Vuex源码读后感#Q-amp-A\"></a></h2><blockquote>\n<p>阅读源码前的几个疑惑，在阅读后得到了答案。</p>\n</blockquote>\n<h3 id=\"1-Vue-use-Vuex-发生了什么？\">1. <code>Vue.use(Vuex)</code>发生了什么？<a href=\"post/2018-07-27-Vuex源码读后感#1-Vue-use-Vuex-发生了什么？\"></a></h3><p><code>Vue.use()</code>是 Vue 安装插件的方法，先看下它的代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">plugin: Function | Object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.installed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// additional parameters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = toArray(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  args.unshift(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.install === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际执行插件的 install 方法</span></span><br><span class=\"line\">    plugin.install.apply(plugin, args)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    plugin.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  plugin.installed = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里核心就是执行<code>plugin.install.apply(plugin, args)</code>，所以下一步看 Vuex 的 install 方法：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">        <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>再看 applyMixin：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>所以 Vuex 的 install 方法的核心就是在每个 Vue 组件初始化的时候执行 <code>vuexInit</code>，Vue 版本如果在 2.0 以上是在 init 或 beforeCreate 生命周期上，2.0 以下版本是修改 Vue 对象原型的_init方法。</p>\n<h3 id=\"2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？\">2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？<a href=\"post/2018-07-27-Vuex源码读后感#2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？\"></a></h3><p>看下 vuexInit 方法：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">  <span class=\"comment\">// store injection</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个函数将初始化 Vue 根组件时传入的 store 设置到 this 对象的<code>$store</code>属性上，子组件从其父组件引用<code>$store</code>属性，层层嵌套进行设置。这样，在任意组件中执行<code>this.$store</code>都能找到装载的那个 store 对象。这里的 this 指向一个 Vue 组件。</p>\n<h3 id=\"3-strict-模式下不能直接修改-state，怎么做到的？\">3. strict 模式下不能直接修改 state，怎么做到的？<a href=\"post/2018-07-27-Vuex源码读后感#3-strict-模式下不能直接修改-state，怎么做到的？\"></a></h3><p>在 resetStoreVM 方法中如果是严格模式会执行<code>enableStrictMode(store)</code>，看下这个函数：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._data.$$state &#125;, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      assert(store._committing, <span class=\"string\">`do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>很短的一段代码，主要就是利用 Vue 的 watch 监测 state 的变化，用到断言函数，在 _committing 为<code>false</code>的时候进行报错。我们通过 mutation 修改 state 的时候都会经过 _withCommit：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这就是通过 mutation 修改 state 不会报错的原因。</p>\n<h3 id=\"4-vm-的主要意义是什么？\">4. _vm 的主要意义是什么？<a href=\"post/2018-07-27-Vuex源码读后感#4-vm-的主要意义是什么？\"></a></h3><p>_vm 是一个 Vue 组件，它的作用除了上面的 watch 以外，还有：</p>\n<ul>\n<li>把 state 存在<code>_vm</code>的<code>_data</code>的<code>$$state</code>属性上，并且让 store 的 state 指向这里。</li>\n<li>把 getter 存在<code>_vm</code>的<code>computed</code>上。</li>\n</ul>\n<h2 id=\"启发\">启发<a href=\"post/2018-07-27-Vuex源码读后感#启发\"></a></h2><h3 id=\"1-assert断言函数\">1. <code>assert</code>断言函数<a href=\"post/2018-07-27-Vuex源码读后感#1-assert断言函数\"></a></h3><p>assert函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>用在条件的检测或者表单的校验上还是很方便的。</p>\n<h3 id=\"2-deepCopy深拷贝\">2. <code>deepCopy</code>深拷贝<a href=\"post/2018-07-27-Vuex源码读后感#2-deepCopy深拷贝\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span> (<span class=\"params\">obj, cache = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// just return if obj is immutable value</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// if obj is hit, it is in circular structure</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hit = find(cache, c =&gt; c.original === obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hit.copy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// put the copy into cache at first</span></span><br><span class=\"line\">  <span class=\"comment\">// because we want to refer it in recursive deepCopy</span></span><br><span class=\"line\">  cache.push(&#123;</span><br><span class=\"line\">    original: obj,</span><br><span class=\"line\">    copy</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    copy[key] = deepCopy(obj[key], cache)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里的 deepCopy 也是采用构造一个新的对象，遍历原对象或者数组，递归调用自身的方式。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过<code>find(cache, c =&gt; c.original === obj)</code>发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。</p>\n<h3 id=\"3-阅读源码的方法\">3. 阅读源码的方法<a href=\"post/2018-07-27-Vuex源码读后感#3-阅读源码的方法\"></a></h3><p>一开始图省事，安装了一个叫 octotree 的 chrome 扩展，发现其实很麻烦，最好还是把源码 clone 下来用编辑器打开。另外把实例在控制台 console 出来也是很高效的一个做法。</p>\n<p>所以我在看代码的时候开了三个编辑器：看源码、打开一个用到 Vuex 的项目、写 markdown。切来切去有点懵的。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这是一篇感想，不是 vuex 源码的导读。除了总结几个对 Vuex 的疑问，还有一些阅读源码的方法论可以分享。</p>\n</blockquote>\n<h2 id=\"推荐两篇文章\"><a href=\"#推荐两篇文章\" class=\"headerlink\" title=\"推荐两篇文章\"></a>推荐两篇文章</h2><p>推荐两篇导读的文章：</p>\n<ol>\n<li><p><a href=\"https://juejin.im/entry/5af5d048f265da0b7b35f94e\" target=\"_blank\" rel=\"noopener\">Vuex 框架原理与源码分析</a></p>\n<blockquote>\n<p>美团前端团队的一篇文章，这篇文章是提出问题、解决问题的叙事风格，比较容易看的进去。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/DDFE/DDFE-blog/issues/8\" target=\"_blank\" rel=\"noopener\">Vuex 2.0 源码分析</a></p>\n<blockquote>\n<p>相对来说，这篇文章像是记叙文的风格，从暴露出的 API 开始进行接近逐行的分析，十分详细。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><blockquote>\n<p>阅读源码前的几个疑惑，在阅读后得到了答案。</p>\n</blockquote>\n<h3 id=\"1-Vue-use-Vuex-发生了什么？\"><a href=\"#1-Vue-use-Vuex-发生了什么？\" class=\"headerlink\" title=\"1. Vue.use(Vuex)发生了什么？\"></a>1. <code>Vue.use(Vuex)</code>发生了什么？</h3><p><code>Vue.use()</code>是 Vue 安装插件的方法，先看下它的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">plugin: Function | Object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.installed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// additional parameters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = toArray(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  args.unshift(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.install === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际执行插件的 install 方法</span></span><br><span class=\"line\">    plugin.install.apply(plugin, args)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    plugin.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  plugin.installed = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里核心就是执行<code>plugin.install.apply(plugin, args)</code>，所以下一步看 Vuex 的 install 方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">        <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看 applyMixin：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以 Vuex 的 install 方法的核心就是在每个 Vue 组件初始化的时候执行 <code>vuexInit</code>，Vue 版本如果在 2.0 以上是在 init 或 beforeCreate 生命周期上，2.0 以下版本是修改 Vue 对象原型的_init方法。</p>\n<h3 id=\"2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？\"><a href=\"#2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？\" class=\"headerlink\" title=\"2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？\"></a>2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？</h3><p>看下 vuexInit 方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">  <span class=\"comment\">// store injection</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数将初始化 Vue 根组件时传入的 store 设置到 this 对象的<code>$store</code>属性上，子组件从其父组件引用<code>$store</code>属性，层层嵌套进行设置。这样，在任意组件中执行<code>this.$store</code>都能找到装载的那个 store 对象。这里的 this 指向一个 Vue 组件。</p>\n<h3 id=\"3-strict-模式下不能直接修改-state，怎么做到的？\"><a href=\"#3-strict-模式下不能直接修改-state，怎么做到的？\" class=\"headerlink\" title=\"3. strict 模式下不能直接修改 state，怎么做到的？\"></a>3. strict 模式下不能直接修改 state，怎么做到的？</h3><p>在 resetStoreVM 方法中如果是严格模式会执行<code>enableStrictMode(store)</code>，看下这个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._data.$$state &#125;, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      assert(store._committing, <span class=\"string\">`do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很短的一段代码，主要就是利用 Vue 的 watch 监测 state 的变化，用到断言函数，在 _committing 为<code>false</code>的时候进行报错。我们通过 mutation 修改 state 的时候都会经过 _withCommit：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是通过 mutation 修改 state 不会报错的原因。</p>\n<h3 id=\"4-vm-的主要意义是什么？\"><a href=\"#4-vm-的主要意义是什么？\" class=\"headerlink\" title=\"4. _vm 的主要意义是什么？\"></a>4. _vm 的主要意义是什么？</h3><p>_vm 是一个 Vue 组件，它的作用除了上面的 watch 以外，还有：</p>\n<ul>\n<li>把 state 存在<code>_vm</code>的<code>_data</code>的<code>$$state</code>属性上，并且让 store 的 state 指向这里。</li>\n<li>把 getter 存在<code>_vm</code>的<code>computed</code>上。</li>\n</ul>\n<h2 id=\"启发\"><a href=\"#启发\" class=\"headerlink\" title=\"启发\"></a>启发</h2><h3 id=\"1-assert断言函数\"><a href=\"#1-assert断言函数\" class=\"headerlink\" title=\"1. assert断言函数\"></a>1. <code>assert</code>断言函数</h3><p>assert函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用在条件的检测或者表单的校验上还是很方便的。</p>\n<h3 id=\"2-deepCopy深拷贝\"><a href=\"#2-deepCopy深拷贝\" class=\"headerlink\" title=\"2. deepCopy深拷贝\"></a>2. <code>deepCopy</code>深拷贝</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span> (<span class=\"params\">obj, cache = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// just return if obj is immutable value</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// if obj is hit, it is in circular structure</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hit = find(cache, c =&gt; c.original === obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hit.copy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// put the copy into cache at first</span></span><br><span class=\"line\">  <span class=\"comment\">// because we want to refer it in recursive deepCopy</span></span><br><span class=\"line\">  cache.push(&#123;</span><br><span class=\"line\">    original: obj,</span><br><span class=\"line\">    copy</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    copy[key] = deepCopy(obj[key], cache)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 deepCopy 也是采用构造一个新的对象，遍历原对象或者数组，递归调用自身的方式。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过<code>find(cache, c =&gt; c.original === obj)</code>发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。</p>\n<h3 id=\"3-阅读源码的方法\"><a href=\"#3-阅读源码的方法\" class=\"headerlink\" title=\"3. 阅读源码的方法\"></a>3. 阅读源码的方法</h3><p>一开始图省事，安装了一个叫 octotree 的 chrome 扩展，发现其实很麻烦，最好还是把源码 clone 下来用编辑器打开。另外把实例在控制台 console 出来也是很高效的一个做法。</p>\n<p>所以我在看代码的时候开了三个编辑器：看源码、打开一个用到 Vuex 的项目、写 markdown。切来切去有点懵的。</p>\n","plink":"https://vincentdou.github.io/blog/post/2018-07-27-Vuex源码读后感/","type":"post","toc":[{"title":"推荐两篇文章","id":"推荐两篇文章","index":"1"},{"title":"Q&amp;A","id":"Q-amp-A","index":"2","children":[{"title":"1. <code>Vue.use(Vuex)</code>发生了什么？","id":"1-Vue-use-Vuex-发生了什么？","index":"2.1"},{"title":"2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？","id":"2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？","index":"2.2"},{"title":"3. strict 模式下不能直接修改 state，怎么做到的？","id":"3-strict-模式下不能直接修改-state，怎么做到的？","index":"2.3"},{"title":"4. _vm 的主要意义是什么？","id":"4-vm-的主要意义是什么？","index":"2.4"}]},{"title":"启发","id":"启发","index":"3","children":[{"title":"1. <code>assert</code>断言函数","id":"1-assert断言函数","index":"3.1"},{"title":"2. <code>deepCopy</code>深拷贝","id":"2-deepCopy深拷贝","index":"3.2"},{"title":"3. 阅读源码的方法","id":"3-阅读源码的方法","index":"3.3"}]}]},{"layout":"post","title":"JS 中的深浅拷贝","date":"2018-08-05T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n## 前言\n\nJavaScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值是指那些保存堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。\n\n目前基本类型有：Boolean、Null、Undefined、Number、String、Symbol，引用类型有：Object、Array、Function。\n\n对于引用类型，简单的`=`赋值只是调一下指针，如果给\b两个变量赋值同一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。\n\n通常在开发中我们不希望出现这样的问题，这就牵涉到深浅拷贝。\n\n## 浅拷贝\n\n- Array.slice()、Array.concat()、Array.from()、展开运算符（…）能实现数组的浅拷贝；\n- Object.assign()、展开运算符```…```能实现对象的浅拷贝。\n\n> 浅拷贝只解决第一层的问题，如果接下去的值中还有对象的话，就要用到深拷贝。\n\n## 深拷贝\n\n通常有下面两种方法实现深拷贝：\n\n- 序列化反序列化法\n- MessageChannel 法\n- 迭代递归法\n\n都会用到的一个函数：\n\n```js\n// 判断是否为对象\nfunction isObject(o) {\n    return (typeof o === 'object' || typeof o === 'function') && o !== null)\n}\n```\n\n### 序列化反序列化法\n\n先把代码序列化成数据，再反序列化回对象：\n\n```js\n// 序列化反序列化法\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj))\n}\n```\n\n局限性：\n\n- 无法实现对函数、RegExp等特殊对象的克隆\n- 循环引用会造成\b栈溢出\n- 原形链上的属性也不会被追踪以及复制\n\n在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。所以如果你的数据中不含有以下三种情况，这个方法是很好的：\n\n- 有 undefined\n- 有函数、RegExp等特殊对象\n- 有循环引用的对象\n\n### MessageChannel 法\n\nMessageChannel 接口是信道通信 API 的一个接口，它允许我们创建一个新的信道并通过信道的两个 MessagePort 属性来传递数据。简单来说，MessageChannel 创建了一个通信的管道，这个管道有两个口子，每个口子都可以通过 postMessage 发送数据，而一个口子只要绑定了 onmessage 回调方法，就可以接收从另一个口子传过来的数据。\n\n我们可用利用他这个两个口子完成克隆：\n\n```js\nfunction structuralClone(obj) {\n  return new Promise(resolve => {\n    const {port1, port2} = new MessageChannel()\n    port2.onmessage = ev => resolve(ev.data)\n    port1.postMessage(obj)\n  })\n}\n\nvar obj = {a: 1, b: {\n    c: b\n}}\n// 注意该方法是异步的\n// 可以处理 undefined 和循环引用对象\nconst clone = await structuralClone(obj)\n```\n\n局限性：\n\n- 数据中包含函数、Error时会报错\n- 循环引用会造成\b栈溢出\n\n这个方法能很好的保留 RegExp、Error 这些的构造函数。\n\n### 迭代递归法\n\n这是最常规的方法，思想很简单：就是对对象进行迭代操作，对它的每个值进行递归深拷贝。\n\n#### for...in 法\n\n```js\n// 迭代递归法：深拷贝对象与数组\nfunction deepClone(obj) {\n    if (!isObject(obj)) {\n        throw new Error('obj 不是一个对象！')\n    }\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [] : {}\n    for (let key in obj) {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    }\n\n    return cloneObj\n}\n```\n\n局限性：\n\n- 无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆\n- 循环引用会造成\b栈溢出\n\n\bfor...in 会追踪原型链上的属性，而其它三种方法(Object.keys、Reflect.ownKeys 和 JSON 方法)都不会追踪原型链上的属性。\n\n#### Reflect 法\n\n```js\n// 代理法\nfunction deepClone(obj) {\n    if (!isObject(obj)) {\n        throw new Error('obj 不是一个对象！')\n    }\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [...obj] : { ...obj }\n    Reflect.ownKeys(cloneObj).forEach(key => {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    })\n\n    return cloneObj\n}\n```\n\n局限性：\n\n- 无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆\n- 循环引用会造成\b栈溢出\n- 原形链上的属性也不会被追踪以及复制\n\n#### lodash 中的深拷贝\n\n著名的 lodash 中的 cloneDeep 方法同样是使用迭代递归法实现的，它支持的对象种类更多，具体的实现过程读者可以参考 [lodash 的 baseClone](https://github.com/lodash/lodash/blob/master/.internal/baseClone.js) 方法。\n\n局限：\n\n- 不会对 Error 和 Function 类型进行拷贝\n\n### 思考\n\n#### 对象成环怎么办？\n\n我们给 test 加一个 loopObj 键，值指向自身：\n\n```\ntest.loopObj = test\n```\n\n这时我们使用迭代递归法中的 for..in 实现和 Reflect 实现还有序列化反序列化法都会栈溢出，但 lodash 却可以得到正确结果。\n\n为什么呢？我们去 [lodash 源码](https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L200)看看：\n\n![](https://user-gold-cdn.xitu.io/2018/4/18/162d6bbd8d654360?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n因为 lodash 使用的是栈把对象存储起来了，如果有环对象，就会从栈里检测到，从而直接返回结果，悬崖勒马。\n\n当然，设置一个哈希表存储已拷贝过的对象同样可以达到同样的目的：\n\n```js\nfunction deepClone(obj, hash = new WeakMap()) {\n    if (!isObject(obj)) {\n        return obj\n    }\n    // 查表\n    if (hash.has(obj)) return hash.get(obj)\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [] : {}\n    // 哈希表设值\n    hash.set(obj, cloneObj)\n\n    let result = Object.keys(obj).map(key => {\n        return {\n            [key]: deepClone(obj[key], hash)\n        }\n    })\n    return Object.assign(cloneObj, ...result)\n}\n```\n\n这里我们使用 WeakMap 作为哈希表，因为它的键是弱引用的，而我们这个场景里键恰好是对象，需要弱引用。\n\n> 参考：\n[面试官:请你实现一个深克隆](https://juejin.im/post/5abb55ee6fb9a028e33b7e0a?utm_medium=fe&utm_source=weixinqun)\n[低门槛彻底理解JavaScript中的深拷贝和浅拷贝](https://juejin.im/post/5ad5b908f265da23870f540d?utm_medium=fe&utm_source=weixinqun)\n[深入深入再深入 js 深拷贝对象](https://juejin.im/post/5ad6b72f6fb9a028d375ecf6?utm_medium=fe&utm_source=weixinqun)\n[前端面试图谱-深浅拷贝](https://yuchengkai.cn/docs/zh/frontend/#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D)\n","source":"_posts/2018-08-06-深浅拷贝.markdown","raw":"---\nlayout:     post\ntitle:      \"JS 中的深浅拷贝\"\ndate:       2018-08-06\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n---\n\n## 前言\n\nJavaScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值是指那些保存堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。\n\n目前基本类型有：Boolean、Null、Undefined、Number、String、Symbol，引用类型有：Object、Array、Function。\n\n对于引用类型，简单的`=`赋值只是调一下指针，如果给\b两个变量赋值同一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。\n\n通常在开发中我们不希望出现这样的问题，这就牵涉到深浅拷贝。\n\n## 浅拷贝\n\n- Array.slice()、Array.concat()、Array.from()、展开运算符（…）能实现数组的浅拷贝；\n- Object.assign()、展开运算符```…```能实现对象的浅拷贝。\n\n> 浅拷贝只解决第一层的问题，如果接下去的值中还有对象的话，就要用到深拷贝。\n\n## 深拷贝\n\n通常有下面两种方法实现深拷贝：\n\n- 序列化反序列化法\n- MessageChannel 法\n- 迭代递归法\n\n都会用到的一个函数：\n\n```js\n// 判断是否为对象\nfunction isObject(o) {\n    return (typeof o === 'object' || typeof o === 'function') && o !== null)\n}\n```\n\n### 序列化反序列化法\n\n先把代码序列化成数据，再反序列化回对象：\n\n```js\n// 序列化反序列化法\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj))\n}\n```\n\n局限性：\n\n- 无法实现对函数、RegExp等特殊对象的克隆\n- 循环引用会造成\b栈溢出\n- 原形链上的属性也不会被追踪以及复制\n\n在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。所以如果你的数据中不含有以下三种情况，这个方法是很好的：\n\n- 有 undefined\n- 有函数、RegExp等特殊对象\n- 有循环引用的对象\n\n### MessageChannel 法\n\nMessageChannel 接口是信道通信 API 的一个接口，它允许我们创建一个新的信道并通过信道的两个 MessagePort 属性来传递数据。简单来说，MessageChannel 创建了一个通信的管道，这个管道有两个口子，每个口子都可以通过 postMessage 发送数据，而一个口子只要绑定了 onmessage 回调方法，就可以接收从另一个口子传过来的数据。\n\n我们可用利用他这个两个口子完成克隆：\n\n```js\nfunction structuralClone(obj) {\n  return new Promise(resolve => {\n    const {port1, port2} = new MessageChannel()\n    port2.onmessage = ev => resolve(ev.data)\n    port1.postMessage(obj)\n  })\n}\n\nvar obj = {a: 1, b: {\n    c: b\n}}\n// 注意该方法是异步的\n// 可以处理 undefined 和循环引用对象\nconst clone = await structuralClone(obj)\n```\n\n局限性：\n\n- 数据中包含函数、Error时会报错\n- 循环引用会造成\b栈溢出\n\n这个方法能很好的保留 RegExp、Error 这些的构造函数。\n\n### 迭代递归法\n\n这是最常规的方法，思想很简单：就是对对象进行迭代操作，对它的每个值进行递归深拷贝。\n\n#### for...in 法\n\n```js\n// 迭代递归法：深拷贝对象与数组\nfunction deepClone(obj) {\n    if (!isObject(obj)) {\n        throw new Error('obj 不是一个对象！')\n    }\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [] : {}\n    for (let key in obj) {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    }\n\n    return cloneObj\n}\n```\n\n局限性：\n\n- 无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆\n- 循环引用会造成\b栈溢出\n\n\bfor...in 会追踪原型链上的属性，而其它三种方法(Object.keys、Reflect.ownKeys 和 JSON 方法)都不会追踪原型链上的属性。\n\n#### Reflect 法\n\n```js\n// 代理法\nfunction deepClone(obj) {\n    if (!isObject(obj)) {\n        throw new Error('obj 不是一个对象！')\n    }\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [...obj] : { ...obj }\n    Reflect.ownKeys(cloneObj).forEach(key => {\n        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    })\n\n    return cloneObj\n}\n```\n\n局限性：\n\n- 无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆\n- 循环引用会造成\b栈溢出\n- 原形链上的属性也不会被追踪以及复制\n\n#### lodash 中的深拷贝\n\n著名的 lodash 中的 cloneDeep 方法同样是使用迭代递归法实现的，它支持的对象种类更多，具体的实现过程读者可以参考 [lodash 的 baseClone](https://github.com/lodash/lodash/blob/master/.internal/baseClone.js) 方法。\n\n局限：\n\n- 不会对 Error 和 Function 类型进行拷贝\n\n### 思考\n\n#### 对象成环怎么办？\n\n我们给 test 加一个 loopObj 键，值指向自身：\n\n```\ntest.loopObj = test\n```\n\n这时我们使用迭代递归法中的 for..in 实现和 Reflect 实现还有序列化反序列化法都会栈溢出，但 lodash 却可以得到正确结果。\n\n为什么呢？我们去 [lodash 源码](https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L200)看看：\n\n![](https://user-gold-cdn.xitu.io/2018/4/18/162d6bbd8d654360?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n因为 lodash 使用的是栈把对象存储起来了，如果有环对象，就会从栈里检测到，从而直接返回结果，悬崖勒马。\n\n当然，设置一个哈希表存储已拷贝过的对象同样可以达到同样的目的：\n\n```js\nfunction deepClone(obj, hash = new WeakMap()) {\n    if (!isObject(obj)) {\n        return obj\n    }\n    // 查表\n    if (hash.has(obj)) return hash.get(obj)\n\n    let isArray = Array.isArray(obj)\n    let cloneObj = isArray ? [] : {}\n    // 哈希表设值\n    hash.set(obj, cloneObj)\n\n    let result = Object.keys(obj).map(key => {\n        return {\n            [key]: deepClone(obj[key], hash)\n        }\n    })\n    return Object.assign(cloneObj, ...result)\n}\n```\n\n这里我们使用 WeakMap 作为哈希表，因为它的键是弱引用的，而我们这个场景里键恰好是对象，需要弱引用。\n\n> 参考：\n[面试官:请你实现一个深克隆](https://juejin.im/post/5abb55ee6fb9a028e33b7e0a?utm_medium=fe&utm_source=weixinqun)\n[低门槛彻底理解JavaScript中的深拷贝和浅拷贝](https://juejin.im/post/5ad5b908f265da23870f540d?utm_medium=fe&utm_source=weixinqun)\n[深入深入再深入 js 深拷贝对象](https://juejin.im/post/5ad6b72f6fb9a028d375ecf6?utm_medium=fe&utm_source=weixinqun)\n[前端面试图谱-深浅拷贝](https://yuchengkai.cn/docs/zh/frontend/#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D)\n","slug":"2018-08-06-深浅拷贝","published":1,"updated":"2019-01-02T08:49:00.261Z","comments":0,"photos":[],"link":"post/2018-08-06-深浅拷贝","_id":"cjz2epje40005n3w5deq5ok08","content":"<h2 id=\"前言\">前言<a href=\"post/2018-08-06-深浅拷贝#前言\"></a></h2><p>JavaScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值是指那些保存堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。</p>\n<p>目前基本类型有：Boolean、Null、Undefined、Number、String、Symbol，引用类型有：Object、Array、Function。</p>\n<p>对于引用类型，简单的<code>=</code>赋值只是调一下指针，如果给\b两个变量赋值同一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p>\n<p>通常在开发中我们不希望出现这样的问题，这就牵涉到深浅拷贝。</p>\n<h2 id=\"浅拷贝\">浅拷贝<a href=\"post/2018-08-06-深浅拷贝#浅拷贝\"></a></h2><ul>\n<li>Array.slice()、Array.concat()、Array.from()、展开运算符（…）能实现数组的浅拷贝；</li>\n<li>Object.assign()、展开运算符<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; 浅拷贝只解决第一层的问题，如果接下去的值中还有对象的话，就要用到深拷贝。</span><br><span class=\"line\"></span><br><span class=\"line\">## 深拷贝</span><br><span class=\"line\"></span><br><span class=\"line\">通常有下面两种方法实现深拷贝：</span><br><span class=\"line\"></span><br><span class=\"line\">- 序列化反序列化法</span><br><span class=\"line\">- MessageChannel 法</span><br><span class=\"line\">- 迭代递归法</span><br><span class=\"line\"></span><br><span class=\"line\">都会用到的一个函数：</span><br><span class=\"line\"></span><br><span class=\"line\">```js</span><br><span class=\"line\">// 判断是否为对象</span><br><span class=\"line\">function isObject(o) &#123;</span><br><span class=\"line\">    return (typeof o === &apos;object&apos; || typeof o === &apos;function&apos;) &amp;&amp; o !== null)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n<h3 id=\"序列化反序列化法\">序列化反序列化法<a href=\"post/2018-08-06-深浅拷贝#序列化反序列化法\"></a></h3><p>先把代码序列化成数据，再反序列化回对象：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化反序列化法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数、RegExp等特殊对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n<li>原形链上的属性也不会被追踪以及复制</li>\n</ul>\n<p>在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。所以如果你的数据中不含有以下三种情况，这个方法是很好的：</p>\n<ul>\n<li>有 undefined</li>\n<li>有函数、RegExp等特殊对象</li>\n<li>有循环引用的对象</li>\n</ul>\n<h3 id=\"MessageChannel-法\">MessageChannel 法<a href=\"post/2018-08-06-深浅拷贝#MessageChannel-法\"></a></h3><p>MessageChannel 接口是信道通信 API 的一个接口，它允许我们创建一个新的信道并通过信道的两个 MessagePort 属性来传递数据。简单来说，MessageChannel 创建了一个通信的管道，这个管道有两个口子，每个口子都可以通过 postMessage 发送数据，而一个口子只要绑定了 onmessage 回调方法，就可以接收从另一个口子传过来的数据。</p>\n<p>我们可用利用他这个两个口子完成克隆：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">structuralClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;port1, port2&#125; = <span class=\"keyword\">new</span> MessageChannel()</span><br><span class=\"line\">    port2.onmessage = <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> resolve(ev.data)</span><br><span class=\"line\">    port1.postMessage(obj)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: &#123;</span><br><span class=\"line\">    c: b</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意该方法是异步的</span></span><br><span class=\"line\"><span class=\"comment\">// 可以处理 undefined 和循环引用对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"keyword\">await</span> structuralClone(obj)</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>数据中包含函数、Error时会报错</li>\n<li>循环引用会造成\b栈溢出</li>\n</ul>\n<p>这个方法能很好的保留 RegExp、Error 这些的构造函数。</p>\n<h3 id=\"迭代递归法\">迭代递归法<a href=\"post/2018-08-06-深浅拷贝#迭代递归法\"></a></h3><p>这是最常规的方法，思想很简单：就是对对象进行迭代操作，对它的每个值进行递归深拷贝。</p>\n<h4 id=\"for…in-法\">for…in 法<a href=\"post/2018-08-06-深浅拷贝#for…in-法\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代递归法：深拷贝对象与数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'obj 不是一个对象！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [] : &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n</ul>\n<p>\bfor…in 会追踪原型链上的属性，而其它三种方法(Object.keys、Reflect.ownKeys 和 JSON 方法)都不会追踪原型链上的属性。</p>\n<h4 id=\"Reflect-法\">Reflect 法<a href=\"post/2018-08-06-深浅拷贝#Reflect-法\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'obj 不是一个对象！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [...obj] : &#123; ...obj &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Reflect</span>.ownKeys(cloneObj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n<li>原形链上的属性也不会被追踪以及复制</li>\n</ul>\n<h4 id=\"lodash-中的深拷贝\">lodash 中的深拷贝<a href=\"post/2018-08-06-深浅拷贝#lodash-中的深拷贝\"></a></h4><p>著名的 lodash 中的 cloneDeep 方法同样是使用迭代递归法实现的，它支持的对象种类更多，具体的实现过程读者可以参考 <a href=\"https://github.com/lodash/lodash/blob/master/.internal/baseClone.js\" target=\"_blank\" rel=\"noopener\">lodash 的 baseClone</a> 方法。</p>\n<p>局限：</p>\n<ul>\n<li>不会对 Error 和 Function 类型进行拷贝</li>\n</ul>\n<h3 id=\"思考\">思考<a href=\"post/2018-08-06-深浅拷贝#思考\"></a></h3><h4 id=\"对象成环怎么办？\">对象成环怎么办？<a href=\"post/2018-08-06-深浅拷贝#对象成环怎么办？\"></a></h4><p>我们给 test 加一个 loopObj 键，值指向自身：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.loopObj = test</span><br></pre></td></tr></table></div></figure>\n<p>这时我们使用迭代递归法中的 for..in 实现和 Reflect 实现还有序列化反序列化法都会栈溢出，但 lodash 却可以得到正确结果。</p>\n<p>为什么呢？我们去 <a href=\"https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L200\" target=\"_blank\" rel=\"noopener\">lodash 源码</a>看看：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d6bbd8d654360?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>因为 lodash 使用的是栈把对象存储起来了，如果有环对象，就会从栈里检测到，从而直接返回结果，悬崖勒马。</p>\n<p>当然，设置一个哈希表存储已拷贝过的对象同样可以达到同样的目的：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 查表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hash.has(obj)) <span class=\"keyword\">return</span> hash.get(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [] : &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表设值</span></span><br><span class=\"line\">    hash.set(obj, cloneObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"built_in\">Object</span>.keys(obj).map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            [key]: deepClone(obj[key], hash)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(cloneObj, ...result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里我们使用 WeakMap 作为哈希表，因为它的键是弱引用的，而我们这个场景里键恰好是对象，需要弱引用。</p>\n<blockquote>\n<p>参考：<br><a href=\"https://juejin.im/post/5abb55ee6fb9a028e33b7e0a?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">面试官:请你实现一个深克隆</a><br><a href=\"https://juejin.im/post/5ad5b908f265da23870f540d?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">低门槛彻底理解JavaScript中的深拷贝和浅拷贝</a><br><a href=\"https://juejin.im/post/5ad6b72f6fb9a028d375ecf6?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">深入深入再深入 js 深拷贝对象</a><br><a href=\"https://yuchengkai.cn/docs/zh/frontend/#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D\" target=\"_blank\" rel=\"noopener\">前端面试图谱-深浅拷贝</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>JavaScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值是指那些保存堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。</p>\n<p>目前基本类型有：Boolean、Null、Undefined、Number、String、Symbol，引用类型有：Object、Array、Function。</p>\n<p>对于引用类型，简单的<code>=</code>赋值只是调一下指针，如果给\b两个变量赋值同一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p>\n<p>通常在开发中我们不希望出现这样的问题，这就牵涉到深浅拷贝。</p>\n<h2 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h2><ul>\n<li>Array.slice()、Array.concat()、Array.from()、展开运算符（…）能实现数组的浅拷贝；</li>\n<li>Object.assign()、展开运算符<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; 浅拷贝只解决第一层的问题，如果接下去的值中还有对象的话，就要用到深拷贝。</span><br><span class=\"line\"></span><br><span class=\"line\">## 深拷贝</span><br><span class=\"line\"></span><br><span class=\"line\">通常有下面两种方法实现深拷贝：</span><br><span class=\"line\"></span><br><span class=\"line\">- 序列化反序列化法</span><br><span class=\"line\">- MessageChannel 法</span><br><span class=\"line\">- 迭代递归法</span><br><span class=\"line\"></span><br><span class=\"line\">都会用到的一个函数：</span><br><span class=\"line\"></span><br><span class=\"line\">```js</span><br><span class=\"line\">// 判断是否为对象</span><br><span class=\"line\">function isObject(o) &#123;</span><br><span class=\"line\">    return (typeof o === &apos;object&apos; || typeof o === &apos;function&apos;) &amp;&amp; o !== null)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"序列化反序列化法\"><a href=\"#序列化反序列化法\" class=\"headerlink\" title=\"序列化反序列化法\"></a>序列化反序列化法</h3><p>先把代码序列化成数据，再反序列化回对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化反序列化法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数、RegExp等特殊对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n<li>原形链上的属性也不会被追踪以及复制</li>\n</ul>\n<p>在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。所以如果你的数据中不含有以下三种情况，这个方法是很好的：</p>\n<ul>\n<li>有 undefined</li>\n<li>有函数、RegExp等特殊对象</li>\n<li>有循环引用的对象</li>\n</ul>\n<h3 id=\"MessageChannel-法\"><a href=\"#MessageChannel-法\" class=\"headerlink\" title=\"MessageChannel 法\"></a>MessageChannel 法</h3><p>MessageChannel 接口是信道通信 API 的一个接口，它允许我们创建一个新的信道并通过信道的两个 MessagePort 属性来传递数据。简单来说，MessageChannel 创建了一个通信的管道，这个管道有两个口子，每个口子都可以通过 postMessage 发送数据，而一个口子只要绑定了 onmessage 回调方法，就可以接收从另一个口子传过来的数据。</p>\n<p>我们可用利用他这个两个口子完成克隆：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">structuralClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;port1, port2&#125; = <span class=\"keyword\">new</span> MessageChannel()</span><br><span class=\"line\">    port2.onmessage = <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> resolve(ev.data)</span><br><span class=\"line\">    port1.postMessage(obj)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: &#123;</span><br><span class=\"line\">    c: b</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意该方法是异步的</span></span><br><span class=\"line\"><span class=\"comment\">// 可以处理 undefined 和循环引用对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"keyword\">await</span> structuralClone(obj)</span><br></pre></td></tr></table></figure>\n<p>局限性：</p>\n<ul>\n<li>数据中包含函数、Error时会报错</li>\n<li>循环引用会造成\b栈溢出</li>\n</ul>\n<p>这个方法能很好的保留 RegExp、Error 这些的构造函数。</p>\n<h3 id=\"迭代递归法\"><a href=\"#迭代递归法\" class=\"headerlink\" title=\"迭代递归法\"></a>迭代递归法</h3><p>这是最常规的方法，思想很简单：就是对对象进行迭代操作，对它的每个值进行递归深拷贝。</p>\n<h4 id=\"for…in-法\"><a href=\"#for…in-法\" class=\"headerlink\" title=\"for…in 法\"></a>for…in 法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代递归法：深拷贝对象与数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'obj 不是一个对象！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [] : &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n</ul>\n<p>\bfor…in 会追踪原型链上的属性，而其它三种方法(Object.keys、Reflect.ownKeys 和 JSON 方法)都不会追踪原型链上的属性。</p>\n<h4 id=\"Reflect-法\"><a href=\"#Reflect-法\" class=\"headerlink\" title=\"Reflect 法\"></a>Reflect 法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'obj 不是一个对象！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [...obj] : &#123; ...obj &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Reflect</span>.ownKeys(cloneObj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n<li>原形链上的属性也不会被追踪以及复制</li>\n</ul>\n<h4 id=\"lodash-中的深拷贝\"><a href=\"#lodash-中的深拷贝\" class=\"headerlink\" title=\"lodash 中的深拷贝\"></a>lodash 中的深拷贝</h4><p>著名的 lodash 中的 cloneDeep 方法同样是使用迭代递归法实现的，它支持的对象种类更多，具体的实现过程读者可以参考 <a href=\"https://github.com/lodash/lodash/blob/master/.internal/baseClone.js\" target=\"_blank\" rel=\"noopener\">lodash 的 baseClone</a> 方法。</p>\n<p>局限：</p>\n<ul>\n<li>不会对 Error 和 Function 类型进行拷贝</li>\n</ul>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><h4 id=\"对象成环怎么办？\"><a href=\"#对象成环怎么办？\" class=\"headerlink\" title=\"对象成环怎么办？\"></a>对象成环怎么办？</h4><p>我们给 test 加一个 loopObj 键，值指向自身：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.loopObj = test</span><br></pre></td></tr></table></figure>\n<p>这时我们使用迭代递归法中的 for..in 实现和 Reflect 实现还有序列化反序列化法都会栈溢出，但 lodash 却可以得到正确结果。</p>\n<p>为什么呢？我们去 <a href=\"https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L200\" target=\"_blank\" rel=\"noopener\">lodash 源码</a>看看：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d6bbd8d654360?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<p>因为 lodash 使用的是栈把对象存储起来了，如果有环对象，就会从栈里检测到，从而直接返回结果，悬崖勒马。</p>\n<p>当然，设置一个哈希表存储已拷贝过的对象同样可以达到同样的目的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 查表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hash.has(obj)) <span class=\"keyword\">return</span> hash.get(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [] : &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表设值</span></span><br><span class=\"line\">    hash.set(obj, cloneObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"built_in\">Object</span>.keys(obj).map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            [key]: deepClone(obj[key], hash)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(cloneObj, ...result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们使用 WeakMap 作为哈希表，因为它的键是弱引用的，而我们这个场景里键恰好是对象，需要弱引用。</p>\n<blockquote>\n<p>参考：<br><a href=\"https://juejin.im/post/5abb55ee6fb9a028e33b7e0a?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">面试官:请你实现一个深克隆</a><br><a href=\"https://juejin.im/post/5ad5b908f265da23870f540d?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">低门槛彻底理解JavaScript中的深拷贝和浅拷贝</a><br><a href=\"https://juejin.im/post/5ad6b72f6fb9a028d375ecf6?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">深入深入再深入 js 深拷贝对象</a><br><a href=\"https://yuchengkai.cn/docs/zh/frontend/#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D\" target=\"_blank\" rel=\"noopener\">前端面试图谱-深浅拷贝</a></p>\n</blockquote>\n","plink":"https://vincentdou.github.io/blog/post/2018-08-06-深浅拷贝/","type":"post","toc":[{"title":"前言","id":"前言","index":"1"},{"title":"浅拷贝","id":"浅拷贝","index":"2","children":[{"title":"序列化反序列化法","id":"序列化反序列化法","index":"2.1"},{"title":"MessageChannel 法","id":"MessageChannel-法","index":"2.2"},{"title":"迭代递归法","id":"迭代递归法","index":"2.3","children":[{"title":"for…in 法","id":"for…in-法","index":"2.3.1"},{"title":"Reflect 法","id":"Reflect-法","index":"2.3.2"},{"title":"lodash 中的深拷贝","id":"lodash-中的深拷贝","index":"2.3.3"}]},{"title":"思考","id":"思考","index":"2.4","children":[{"title":"对象成环怎么办？","id":"对象成环怎么办？","index":"2.4.1"}]}]}]},{"layout":"post","title":"JS 中的 NaN","date":"2018-08-06T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> NaN 相关的问题应该属于是 JS 的一些缺陷性的知识，但我还是觉得花几分钟搞清楚好一点。\n\n### NaN值的产生\n\n当算术运算返回一个未定义的或无法表示的值时，NaN就产生了。但是，NaN并不一定用于表示某些值超出表示范围的情况。将某些不能强制转换为数值的非数值转换为数值的时候，也会得到NaN。\n\n例如，0 除以0会返回NaN —— 但是其他数除以0则不会返回NaN。\n\n### NaN 和 Number.NaN\n\n- NaN 是一个全局对象的属性，类型为`'string'`；\n- 跟 NaN 相似，Number.NaN 是 Number 的一个静态属性，不必创建一个 Number 实例来访问该属性，可以直接使用 Number.NaN 来访问该静态属性；\n- 在现代浏览器中（ES5中）， NaN 属性是一个不可配置（non-configurable），不可写（non-writable）的属性。但在ES3中，这个属性的值是可以被更改的，但是也应该避免覆盖；\n- NaN 不等于任何值包括它自身，因此等号运算符（`==` 和 `===`）不能被用来判断一个值是否是 NaN。必须使用`Number.isNaN()`或`isNaN()`函数。\n\n### isNaN() 和 Number.isNaN()\n\n- isNaN() 是 JS 的一个内置函数；\n- Number.isNaN() 是 ES6 中定义的；\n- isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值，Number.isNaN() 不会。\n\n#### isNaN() 的怪异行为\n\n由于 **isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值**，因此，对于能被强制转换为有效的非NaN数值来说（空字符串和布尔值分别会被强制转换为数值 0 和 1），返回 false 值也许会让人感觉莫名其妙。比如说，空字符串就明显“不是数值（not a number）”。\n\n示例：\n\n```js\nisNaN(NaN);       // true\nisNaN(undefined); // true\nisNaN({});        // true\n\nisNaN(true);      // false\nisNaN(null);      // false\nisNaN(37);        // false\n\n// strings\nisNaN(\"37\");      // false: 可以被转换成数值37\nisNaN(\"37.37\");   // false: 可以被转换成数值37.37\nisNaN(\"37,5\");    // true\nisNaN('123ABC');  // true:  parseInt(\"123ABC\")的结果是 123, 但是Number(\"123ABC\")结果是 NaN\nisNaN(\"\");        // false: 空字符串被转换成0\nisNaN(\" \");       // false: 包含空格的字符串被转换成0\n\n// dates\nisNaN(new Date());                // false\nisNaN(new Date().toString());     // true\n\nisNaN(\"blabla\")   // true: \"blabla\"不能转换成数值\n                  // 转换成数值失败， 返回NaN\n```\n\n而 Number.isNaN() 不会：\n\n```js\nNumber.isNaN(NaN);        // true\nNumber.isNaN(Number.NaN); // true\nNumber.isNaN(0 / 0)       // true\n\n// 下面这几个如果使用全局的 isNaN() 时，会返回 true。\nNumber.isNaN(\"NaN\");      // false，字符串 \"NaN\" 不会被隐式转换成数字 NaN。\nNumber.isNaN(undefined);  // false\nNumber.isNaN({});         // false\nNumber.isNaN(\"blabla\");   // false\n\n// 下面的都返回 false\nNumber.isNaN(true);\nNumber.isNaN(null);\nNumber.isNaN(37);\nNumber.isNaN(\"37\");\nNumber.isNaN(\"37.37\");\nNumber.isNaN(\"\");\nNumber.isNaN(\" \");\n```\n\n#### 对 isNaN 的 polyfill\n\n```js\nNumber.isNaN = Number.isNaN || function(value) {\n    return typeof value === \"number\" && isNaN(value)\n}\n```\n\n这种是加多一个 typeof 的判断\n\n```js\nNumber.isNaN = Number.isNaN || function(value) {\n    var n = parseInt(value)\n    return n !== value\n}\n```\n\n这种是先对参数 parseInt 再判断 parseInt 前后有无变化，对于非 number 类型肯定有变化所以返回 false，而 NaN 不等于自身也会返回 false。\n\n> 参考：\n> [NaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)\n> [Number.NaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)\n> [isNaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)\n> [Number.isNaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)\n","source":"_posts/2018-08-07-NaN.markdown","raw":"---\nlayout:     post\ntitle:      \"JS 中的 NaN\"\ndate:       2018-08-07\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n---\n\n> NaN 相关的问题应该属于是 JS 的一些缺陷性的知识，但我还是觉得花几分钟搞清楚好一点。\n\n### NaN值的产生\n\n当算术运算返回一个未定义的或无法表示的值时，NaN就产生了。但是，NaN并不一定用于表示某些值超出表示范围的情况。将某些不能强制转换为数值的非数值转换为数值的时候，也会得到NaN。\n\n例如，0 除以0会返回NaN —— 但是其他数除以0则不会返回NaN。\n\n### NaN 和 Number.NaN\n\n- NaN 是一个全局对象的属性，类型为`'string'`；\n- 跟 NaN 相似，Number.NaN 是 Number 的一个静态属性，不必创建一个 Number 实例来访问该属性，可以直接使用 Number.NaN 来访问该静态属性；\n- 在现代浏览器中（ES5中）， NaN 属性是一个不可配置（non-configurable），不可写（non-writable）的属性。但在ES3中，这个属性的值是可以被更改的，但是也应该避免覆盖；\n- NaN 不等于任何值包括它自身，因此等号运算符（`==` 和 `===`）不能被用来判断一个值是否是 NaN。必须使用`Number.isNaN()`或`isNaN()`函数。\n\n### isNaN() 和 Number.isNaN()\n\n- isNaN() 是 JS 的一个内置函数；\n- Number.isNaN() 是 ES6 中定义的；\n- isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值，Number.isNaN() 不会。\n\n#### isNaN() 的怪异行为\n\n由于 **isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值**，因此，对于能被强制转换为有效的非NaN数值来说（空字符串和布尔值分别会被强制转换为数值 0 和 1），返回 false 值也许会让人感觉莫名其妙。比如说，空字符串就明显“不是数值（not a number）”。\n\n示例：\n\n```js\nisNaN(NaN);       // true\nisNaN(undefined); // true\nisNaN({});        // true\n\nisNaN(true);      // false\nisNaN(null);      // false\nisNaN(37);        // false\n\n// strings\nisNaN(\"37\");      // false: 可以被转换成数值37\nisNaN(\"37.37\");   // false: 可以被转换成数值37.37\nisNaN(\"37,5\");    // true\nisNaN('123ABC');  // true:  parseInt(\"123ABC\")的结果是 123, 但是Number(\"123ABC\")结果是 NaN\nisNaN(\"\");        // false: 空字符串被转换成0\nisNaN(\" \");       // false: 包含空格的字符串被转换成0\n\n// dates\nisNaN(new Date());                // false\nisNaN(new Date().toString());     // true\n\nisNaN(\"blabla\")   // true: \"blabla\"不能转换成数值\n                  // 转换成数值失败， 返回NaN\n```\n\n而 Number.isNaN() 不会：\n\n```js\nNumber.isNaN(NaN);        // true\nNumber.isNaN(Number.NaN); // true\nNumber.isNaN(0 / 0)       // true\n\n// 下面这几个如果使用全局的 isNaN() 时，会返回 true。\nNumber.isNaN(\"NaN\");      // false，字符串 \"NaN\" 不会被隐式转换成数字 NaN。\nNumber.isNaN(undefined);  // false\nNumber.isNaN({});         // false\nNumber.isNaN(\"blabla\");   // false\n\n// 下面的都返回 false\nNumber.isNaN(true);\nNumber.isNaN(null);\nNumber.isNaN(37);\nNumber.isNaN(\"37\");\nNumber.isNaN(\"37.37\");\nNumber.isNaN(\"\");\nNumber.isNaN(\" \");\n```\n\n#### 对 isNaN 的 polyfill\n\n```js\nNumber.isNaN = Number.isNaN || function(value) {\n    return typeof value === \"number\" && isNaN(value)\n}\n```\n\n这种是加多一个 typeof 的判断\n\n```js\nNumber.isNaN = Number.isNaN || function(value) {\n    var n = parseInt(value)\n    return n !== value\n}\n```\n\n这种是先对参数 parseInt 再判断 parseInt 前后有无变化，对于非 number 类型肯定有变化所以返回 false，而 NaN 不等于自身也会返回 false。\n\n> 参考：\n> [NaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)\n> [Number.NaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)\n> [isNaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)\n> [Number.isNaN - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)\n","slug":"2018-08-07-NaN","published":1,"updated":"2019-01-02T08:49:00.266Z","comments":0,"photos":[],"link":"post/2018-08-07-NaN","_id":"cjz2epje60007n3w57a5fk9pp","content":"<blockquote>\n<p>NaN 相关的问题应该属于是 JS 的一些缺陷性的知识，但我还是觉得花几分钟搞清楚好一点。</p>\n</blockquote>\n<h3 id=\"NaN值的产生\">NaN值的产生<a href=\"post/2018-08-07-NaN#NaN值的产生\"></a></h3><p>当算术运算返回一个未定义的或无法表示的值时，NaN就产生了。但是，NaN并不一定用于表示某些值超出表示范围的情况。将某些不能强制转换为数值的非数值转换为数值的时候，也会得到NaN。</p>\n<p>例如，0 除以0会返回NaN —— 但是其他数除以0则不会返回NaN。</p>\n<h3 id=\"NaN-和-Number-NaN\">NaN 和 Number.NaN<a href=\"post/2018-08-07-NaN#NaN-和-Number-NaN\"></a></h3><ul>\n<li>NaN 是一个全局对象的属性，类型为<code>&#39;string&#39;</code>；</li>\n<li>跟 NaN 相似，Number.NaN 是 Number 的一个静态属性，不必创建一个 Number 实例来访问该属性，可以直接使用 Number.NaN 来访问该静态属性；</li>\n<li>在现代浏览器中（ES5中）， NaN 属性是一个不可配置（non-configurable），不可写（non-writable）的属性。但在ES3中，这个属性的值是可以被更改的，但是也应该避免覆盖；</li>\n<li>NaN 不等于任何值包括它自身，因此等号运算符（<code>==</code> 和 <code>===</code>）不能被用来判断一个值是否是 NaN。必须使用<code>Number.isNaN()</code>或<code>isNaN()</code>函数。</li>\n</ul>\n<h3 id=\"isNaN-和-Number-isNaN\">isNaN() 和 Number.isNaN()<a href=\"post/2018-08-07-NaN#isNaN-和-Number-isNaN\"></a></h3><ul>\n<li>isNaN() 是 JS 的一个内置函数；</li>\n<li>Number.isNaN() 是 ES6 中定义的；</li>\n<li>isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值，Number.isNaN() 不会。</li>\n</ul>\n<h4 id=\"isNaN-的怪异行为\">isNaN() 的怪异行为<a href=\"post/2018-08-07-NaN#isNaN-的怪异行为\"></a></h4><p>由于 <strong>isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值</strong>，因此，对于能被强制转换为有效的非NaN数值来说（空字符串和布尔值分别会被强制转换为数值 0 和 1），返回 false 值也许会让人感觉莫名其妙。比如说，空字符串就明显“不是数值（not a number）”。</p>\n<p>示例：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>);       <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(&#123;&#125;);        <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">true</span>);      <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">null</span>);      <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">37</span>);        <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// strings</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"37\"</span>);      <span class=\"comment\">// false: 可以被转换成数值37</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"37.37\"</span>);   <span class=\"comment\">// false: 可以被转换成数值37.37</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"37,5\"</span>);    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">'123ABC'</span>);  <span class=\"comment\">// true:  parseInt(\"123ABC\")的结果是 123, 但是Number(\"123ABC\")结果是 NaN</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"\"</span>);        <span class=\"comment\">// false: 空字符串被转换成0</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\" \"</span>);       <span class=\"comment\">// false: 包含空格的字符串被转换成0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dates</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());                <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toString());     <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"blabla\"</span>)   <span class=\"comment\">// true: \"blabla\"不能转换成数值</span></span><br><span class=\"line\">                  <span class=\"comment\">// 转换成数值失败， 返回NaN</span></span><br></pre></td></tr></table></div></figure>\n<p>而 Number.isNaN() 不会：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>);        <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"built_in\">Number</span>.NaN); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">0</span> / <span class=\"number\">0</span>)       <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面这几个如果使用全局的 isNaN() 时，会返回 true。</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>);      <span class=\"comment\">// false，字符串 \"NaN\" 不会被隐式转换成数字 NaN。</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">undefined</span>);  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(&#123;&#125;);         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"blabla\"</span>);   <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的都返回 false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">37</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"37\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"37.37\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\" \"</span>);</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"对-isNaN-的-polyfill\">对 isNaN 的 polyfill<a href=\"post/2018-08-07-NaN#对-isNaN-的-polyfill\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN = <span class=\"built_in\">Number</span>.isNaN || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"number\"</span> &amp;&amp; <span class=\"built_in\">isNaN</span>(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这种是加多一个 typeof 的判断</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN = <span class=\"built_in\">Number</span>.isNaN || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = <span class=\"built_in\">parseInt</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n !== value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这种是先对参数 parseInt 再判断 parseInt 前后有无变化，对于非 number 类型肯定有变化所以返回 false，而 NaN 不等于自身也会返回 false。</p>\n<blockquote>\n<p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" target=\"_blank\" rel=\"noopener\">NaN - JavaScript | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\" target=\"_blank\" rel=\"noopener\">Number.NaN - JavaScript | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN\" target=\"_blank\" rel=\"noopener\">isNaN - JavaScript | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\" target=\"_blank\" rel=\"noopener\">Number.isNaN - JavaScript | MDN</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>NaN 相关的问题应该属于是 JS 的一些缺陷性的知识，但我还是觉得花几分钟搞清楚好一点。</p>\n</blockquote>\n<h3 id=\"NaN值的产生\"><a href=\"#NaN值的产生\" class=\"headerlink\" title=\"NaN值的产生\"></a>NaN值的产生</h3><p>当算术运算返回一个未定义的或无法表示的值时，NaN就产生了。但是，NaN并不一定用于表示某些值超出表示范围的情况。将某些不能强制转换为数值的非数值转换为数值的时候，也会得到NaN。</p>\n<p>例如，0 除以0会返回NaN —— 但是其他数除以0则不会返回NaN。</p>\n<h3 id=\"NaN-和-Number-NaN\"><a href=\"#NaN-和-Number-NaN\" class=\"headerlink\" title=\"NaN 和 Number.NaN\"></a>NaN 和 Number.NaN</h3><ul>\n<li>NaN 是一个全局对象的属性，类型为<code>&#39;string&#39;</code>；</li>\n<li>跟 NaN 相似，Number.NaN 是 Number 的一个静态属性，不必创建一个 Number 实例来访问该属性，可以直接使用 Number.NaN 来访问该静态属性；</li>\n<li>在现代浏览器中（ES5中）， NaN 属性是一个不可配置（non-configurable），不可写（non-writable）的属性。但在ES3中，这个属性的值是可以被更改的，但是也应该避免覆盖；</li>\n<li>NaN 不等于任何值包括它自身，因此等号运算符（<code>==</code> 和 <code>===</code>）不能被用来判断一个值是否是 NaN。必须使用<code>Number.isNaN()</code>或<code>isNaN()</code>函数。</li>\n</ul>\n<h3 id=\"isNaN-和-Number-isNaN\"><a href=\"#isNaN-和-Number-isNaN\" class=\"headerlink\" title=\"isNaN() 和 Number.isNaN()\"></a>isNaN() 和 Number.isNaN()</h3><ul>\n<li>isNaN() 是 JS 的一个内置函数；</li>\n<li>Number.isNaN() 是 ES6 中定义的；</li>\n<li>isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值，Number.isNaN() 不会。</li>\n</ul>\n<h4 id=\"isNaN-的怪异行为\"><a href=\"#isNaN-的怪异行为\" class=\"headerlink\" title=\"isNaN() 的怪异行为\"></a>isNaN() 的怪异行为</h4><p>由于 <strong>isNaN() 在参数不是 Number 类型时会首先尝试将这个参数转换为数值</strong>，因此，对于能被强制转换为有效的非NaN数值来说（空字符串和布尔值分别会被强制转换为数值 0 和 1），返回 false 值也许会让人感觉莫名其妙。比如说，空字符串就明显“不是数值（not a number）”。</p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>);       <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(&#123;&#125;);        <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">true</span>);      <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">null</span>);      <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">37</span>);        <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// strings</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"37\"</span>);      <span class=\"comment\">// false: 可以被转换成数值37</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"37.37\"</span>);   <span class=\"comment\">// false: 可以被转换成数值37.37</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"37,5\"</span>);    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">'123ABC'</span>);  <span class=\"comment\">// true:  parseInt(\"123ABC\")的结果是 123, 但是Number(\"123ABC\")结果是 NaN</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"\"</span>);        <span class=\"comment\">// false: 空字符串被转换成0</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\" \"</span>);       <span class=\"comment\">// false: 包含空格的字符串被转换成0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dates</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());                <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toString());     <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"blabla\"</span>)   <span class=\"comment\">// true: \"blabla\"不能转换成数值</span></span><br><span class=\"line\">                  <span class=\"comment\">// 转换成数值失败， 返回NaN</span></span><br></pre></td></tr></table></figure>\n<p>而 Number.isNaN() 不会：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>);        <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"built_in\">Number</span>.NaN); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">0</span> / <span class=\"number\">0</span>)       <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面这几个如果使用全局的 isNaN() 时，会返回 true。</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>);      <span class=\"comment\">// false，字符串 \"NaN\" 不会被隐式转换成数字 NaN。</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">undefined</span>);  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(&#123;&#125;);         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"blabla\"</span>);   <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的都返回 false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">37</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"37\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"37.37\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\" \"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"对-isNaN-的-polyfill\"><a href=\"#对-isNaN-的-polyfill\" class=\"headerlink\" title=\"对 isNaN 的 polyfill\"></a>对 isNaN 的 polyfill</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN = <span class=\"built_in\">Number</span>.isNaN || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"number\"</span> &amp;&amp; <span class=\"built_in\">isNaN</span>(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种是加多一个 typeof 的判断</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN = <span class=\"built_in\">Number</span>.isNaN || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = <span class=\"built_in\">parseInt</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n !== value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种是先对参数 parseInt 再判断 parseInt 前后有无变化，对于非 number 类型肯定有变化所以返回 false，而 NaN 不等于自身也会返回 false。</p>\n<blockquote>\n<p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" target=\"_blank\" rel=\"noopener\">NaN - JavaScript | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\" target=\"_blank\" rel=\"noopener\">Number.NaN - JavaScript | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN\" target=\"_blank\" rel=\"noopener\">isNaN - JavaScript | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\" target=\"_blank\" rel=\"noopener\">Number.isNaN - JavaScript | MDN</a></p>\n</blockquote>\n","plink":"https://vincentdou.github.io/blog/post/2018-08-07-NaN/","type":"post"},{"layout":"post","title":"flex 演算法总结","date":"2018-11-20T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> 大漠的这篇[聊聊Flexbox布局中的flex的演算法](https://zhuanlan.zhihu.com/p/50449041)是我看过对 flex 布局中的 flex-basis、flex-grow、flex-shrink 三个属性讨论最为深入的一篇文章，这里做一下\b阅读总结。\n\n### min-content 和 max-content\n\nmin-content 和 max-content 是 CSS3 中新的 width 的值，大漠在这里贴了一篇张鑫旭的文章：[理解CSS3 max/min-content及fit-content等width值](https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/)，总结如下：\n\n1. min-content 的大小，从本质上讲，是由字符串中最长的单词决定了大小；\n2. max-content 则和 min-content 相反。它会变得尽可能大, 没有自动换行的机会。\n\n与 flex 布局的关系：\n\n1. flex-basis 为 auto 时，会把 Flex 项目的 max-content 作为 flex-basise 的值；\n2. Flexbox 布局中会阻止 Flex 项目元素宽度缩小至 0，此时 Flex 项目会以 min-content 的大小进行计算。\n\n### flex-basis\n\nflex-basis 属性在任何空间分配发生之前初始化 Flex 项目的尺寸。\n\n- flex-basis 默认值为 auto；\n- 如果 Flex 项目显式的设置了 width 值，同时 flex-basis 为 auto 时，则 Flex 项目的宽度为按 width 来计算，如果未显式设置 width，则按 Flex 项目的内容宽度即 max-content 来计算；\n- 如果 Flex 项目显式的设置了 width 值，同时显式设置了 flex-basis 的具体值，则 Flex 项目会忽略 width 值，会按 flex-basis 来计算 Flex 项目；\n- 当 Flex 容器剩余空间不足时，Flex 项目的实际宽度并不会按 flex-basis 来计算，会根据 flex-grow 和 flex-shrink 设置的值给 Flex 项目分配相应的空间；\n- 对于 Flexbox 布局中，不建议显式的设置 Flex 项目的 width 值，而是通过 flex-basis 来控制 Flex 项目的宽度，这样更具弹性；\n- 如果 Flex 项目显式的设置了 min-width 或 max-width 值时，当 flex-basis 计算出来的值小于 min-width 则按 min-width 值设置 Flex 项目宽度，反之，计算出来的值大于 max-width 值时，则按 max-width 的值设置 Flex 项目宽度。\n\n### flex-grow\n\nflex-grow 是一个扩展因子（扩展比例）。当 Flex 容器有一定的剩余空间时，flex-grow 可以让 Flex 项目分配 Flex 容器剩余的空间，每个 Flex 项目将根据 flex-grow 因子扩展，从而让 Flex 项目布满整个 Flex 容器（有效利用 Flex 容器的剩余空间）。\n\n- flex-grow 的默认值是 0，其接受的值是一个数值，可以是一个小数值，但不支持负值；\n- flex-grow 是指 Flex 项目分配 Flex 容器剩余的空间的占比；\n- \b当 flex-grow 设置为小数，且所有 flex-grow 之和小于 1 时，Flex 项目不会用完 Flex 容器的剩余空间；\n- flex-basis 的值为 auto，且没有给 Flex 项目显式的设置 width 时，Flex 项目的大小都取决于其内容的 max-content 大小，此时 Flex 容器的剩余的空间将由浏览器根据 Flex 项目的内容宽度来计算；\n- 针对上面的场景，如果你想让所有 Flex 项目具有相同的尺寸，可以显式的设置 Flex 项目的 flex-basis 值为0（flex: 1 1 0）。\n\n### flex-shrink\n\nflex-shrink 和 flex-grow 类似，只不过 flex-shrink 是用来控制 Flex 项目缩放因子。当所有 Flex 项目宽度之和大于 Flex 容器时，将会溢出容器（flex-wrap为nowrap时），flex-shrink 就可以根据 Flex 项目设置的数值比例来分配 Flex 容器的不足空间，也就是按比例因子缩小自身的宽度，以免溢出Flex容器。\n\n- flex-shrink 的默认值是 1，其接受的值是一个数值，可以是一个小数值，但不支持负值；\n- flex-shrink 是指 Flex 项目分配 Flex 容器不足空间的占比；\n- 在 Flexbox 布局当中，会阻止 Flex 项目元素宽度缩小至 0。此时 Flex 项目会以 min-content 的大小进行计算，这个大小是它们利用任何可以利用的自动断行机会后所变成的；\n- 当所有 Flex 项目的收缩因子（flex-shrink）总和小于 1 时，Flex 容器不足空间不会完全分配完，依旧会溢出 Flex 容器。\n","source":"_posts/2018-11-21-flex演算法总结.md","raw":"---\nlayout:     post\ntitle:      \"flex 演算法总结\"\ndate:       2018-11-21\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - CSS\n    - flex布局\n---\n\n> 大漠的这篇[聊聊Flexbox布局中的flex的演算法](https://zhuanlan.zhihu.com/p/50449041)是我看过对 flex 布局中的 flex-basis、flex-grow、flex-shrink 三个属性讨论最为深入的一篇文章，这里做一下\b阅读总结。\n\n### min-content 和 max-content\n\nmin-content 和 max-content 是 CSS3 中新的 width 的值，大漠在这里贴了一篇张鑫旭的文章：[理解CSS3 max/min-content及fit-content等width值](https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/)，总结如下：\n\n1. min-content 的大小，从本质上讲，是由字符串中最长的单词决定了大小；\n2. max-content 则和 min-content 相反。它会变得尽可能大, 没有自动换行的机会。\n\n与 flex 布局的关系：\n\n1. flex-basis 为 auto 时，会把 Flex 项目的 max-content 作为 flex-basise 的值；\n2. Flexbox 布局中会阻止 Flex 项目元素宽度缩小至 0，此时 Flex 项目会以 min-content 的大小进行计算。\n\n### flex-basis\n\nflex-basis 属性在任何空间分配发生之前初始化 Flex 项目的尺寸。\n\n- flex-basis 默认值为 auto；\n- 如果 Flex 项目显式的设置了 width 值，同时 flex-basis 为 auto 时，则 Flex 项目的宽度为按 width 来计算，如果未显式设置 width，则按 Flex 项目的内容宽度即 max-content 来计算；\n- 如果 Flex 项目显式的设置了 width 值，同时显式设置了 flex-basis 的具体值，则 Flex 项目会忽略 width 值，会按 flex-basis 来计算 Flex 项目；\n- 当 Flex 容器剩余空间不足时，Flex 项目的实际宽度并不会按 flex-basis 来计算，会根据 flex-grow 和 flex-shrink 设置的值给 Flex 项目分配相应的空间；\n- 对于 Flexbox 布局中，不建议显式的设置 Flex 项目的 width 值，而是通过 flex-basis 来控制 Flex 项目的宽度，这样更具弹性；\n- 如果 Flex 项目显式的设置了 min-width 或 max-width 值时，当 flex-basis 计算出来的值小于 min-width 则按 min-width 值设置 Flex 项目宽度，反之，计算出来的值大于 max-width 值时，则按 max-width 的值设置 Flex 项目宽度。\n\n### flex-grow\n\nflex-grow 是一个扩展因子（扩展比例）。当 Flex 容器有一定的剩余空间时，flex-grow 可以让 Flex 项目分配 Flex 容器剩余的空间，每个 Flex 项目将根据 flex-grow 因子扩展，从而让 Flex 项目布满整个 Flex 容器（有效利用 Flex 容器的剩余空间）。\n\n- flex-grow 的默认值是 0，其接受的值是一个数值，可以是一个小数值，但不支持负值；\n- flex-grow 是指 Flex 项目分配 Flex 容器剩余的空间的占比；\n- \b当 flex-grow 设置为小数，且所有 flex-grow 之和小于 1 时，Flex 项目不会用完 Flex 容器的剩余空间；\n- flex-basis 的值为 auto，且没有给 Flex 项目显式的设置 width 时，Flex 项目的大小都取决于其内容的 max-content 大小，此时 Flex 容器的剩余的空间将由浏览器根据 Flex 项目的内容宽度来计算；\n- 针对上面的场景，如果你想让所有 Flex 项目具有相同的尺寸，可以显式的设置 Flex 项目的 flex-basis 值为0（flex: 1 1 0）。\n\n### flex-shrink\n\nflex-shrink 和 flex-grow 类似，只不过 flex-shrink 是用来控制 Flex 项目缩放因子。当所有 Flex 项目宽度之和大于 Flex 容器时，将会溢出容器（flex-wrap为nowrap时），flex-shrink 就可以根据 Flex 项目设置的数值比例来分配 Flex 容器的不足空间，也就是按比例因子缩小自身的宽度，以免溢出Flex容器。\n\n- flex-shrink 的默认值是 1，其接受的值是一个数值，可以是一个小数值，但不支持负值；\n- flex-shrink 是指 Flex 项目分配 Flex 容器不足空间的占比；\n- 在 Flexbox 布局当中，会阻止 Flex 项目元素宽度缩小至 0。此时 Flex 项目会以 min-content 的大小进行计算，这个大小是它们利用任何可以利用的自动断行机会后所变成的；\n- 当所有 Flex 项目的收缩因子（flex-shrink）总和小于 1 时，Flex 容器不足空间不会完全分配完，依旧会溢出 Flex 容器。\n","slug":"2018-11-21-flex演算法总结","published":1,"updated":"2019-01-02T08:49:00.266Z","comments":0,"photos":[],"link":"post/2018-11-21-flex演算法总结","_id":"cjz2epje70008n3w5if8r2xwf","content":"<blockquote>\n<p>大漠的这篇<a href=\"https://zhuanlan.zhihu.com/p/50449041\" target=\"_blank\" rel=\"noopener\">聊聊Flexbox布局中的flex的演算法</a>是我看过对 flex 布局中的 flex-basis、flex-grow、flex-shrink 三个属性讨论最为深入的一篇文章，这里做一下\b阅读总结。</p>\n</blockquote>\n<h3 id=\"min-content-和-max-content\">min-content 和 max-content<a href=\"post/2018-11-21-flex演算法总结#min-content-和-max-content\"></a></h3><p>min-content 和 max-content 是 CSS3 中新的 width 的值，大漠在这里贴了一篇张鑫旭的文章：<a href=\"https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/\" target=\"_blank\" rel=\"noopener\">理解CSS3 max/min-content及fit-content等width值</a>，总结如下：</p>\n<ol>\n<li>min-content 的大小，从本质上讲，是由字符串中最长的单词决定了大小；</li>\n<li>max-content 则和 min-content 相反。它会变得尽可能大, 没有自动换行的机会。</li>\n</ol>\n<p>与 flex 布局的关系：</p>\n<ol>\n<li>flex-basis 为 auto 时，会把 Flex 项目的 max-content 作为 flex-basise 的值；</li>\n<li>Flexbox 布局中会阻止 Flex 项目元素宽度缩小至 0，此时 Flex 项目会以 min-content 的大小进行计算。</li>\n</ol>\n<h3 id=\"flex-basis\">flex-basis<a href=\"post/2018-11-21-flex演算法总结#flex-basis\"></a></h3><p>flex-basis 属性在任何空间分配发生之前初始化 Flex 项目的尺寸。</p>\n<ul>\n<li>flex-basis 默认值为 auto；</li>\n<li>如果 Flex 项目显式的设置了 width 值，同时 flex-basis 为 auto 时，则 Flex 项目的宽度为按 width 来计算，如果未显式设置 width，则按 Flex 项目的内容宽度即 max-content 来计算；</li>\n<li>如果 Flex 项目显式的设置了 width 值，同时显式设置了 flex-basis 的具体值，则 Flex 项目会忽略 width 值，会按 flex-basis 来计算 Flex 项目；</li>\n<li>当 Flex 容器剩余空间不足时，Flex 项目的实际宽度并不会按 flex-basis 来计算，会根据 flex-grow 和 flex-shrink 设置的值给 Flex 项目分配相应的空间；</li>\n<li>对于 Flexbox 布局中，不建议显式的设置 Flex 项目的 width 值，而是通过 flex-basis 来控制 Flex 项目的宽度，这样更具弹性；</li>\n<li>如果 Flex 项目显式的设置了 min-width 或 max-width 值时，当 flex-basis 计算出来的值小于 min-width 则按 min-width 值设置 Flex 项目宽度，反之，计算出来的值大于 max-width 值时，则按 max-width 的值设置 Flex 项目宽度。</li>\n</ul>\n<h3 id=\"flex-grow\">flex-grow<a href=\"post/2018-11-21-flex演算法总结#flex-grow\"></a></h3><p>flex-grow 是一个扩展因子（扩展比例）。当 Flex 容器有一定的剩余空间时，flex-grow 可以让 Flex 项目分配 Flex 容器剩余的空间，每个 Flex 项目将根据 flex-grow 因子扩展，从而让 Flex 项目布满整个 Flex 容器（有效利用 Flex 容器的剩余空间）。</p>\n<ul>\n<li>flex-grow 的默认值是 0，其接受的值是一个数值，可以是一个小数值，但不支持负值；</li>\n<li>flex-grow 是指 Flex 项目分配 Flex 容器剩余的空间的占比；</li>\n<li>\b当 flex-grow 设置为小数，且所有 flex-grow 之和小于 1 时，Flex 项目不会用完 Flex 容器的剩余空间；</li>\n<li>flex-basis 的值为 auto，且没有给 Flex 项目显式的设置 width 时，Flex 项目的大小都取决于其内容的 max-content 大小，此时 Flex 容器的剩余的空间将由浏览器根据 Flex 项目的内容宽度来计算；</li>\n<li>针对上面的场景，如果你想让所有 Flex 项目具有相同的尺寸，可以显式的设置 Flex 项目的 flex-basis 值为0（flex: 1 1 0）。</li>\n</ul>\n<h3 id=\"flex-shrink\">flex-shrink<a href=\"post/2018-11-21-flex演算法总结#flex-shrink\"></a></h3><p>flex-shrink 和 flex-grow 类似，只不过 flex-shrink 是用来控制 Flex 项目缩放因子。当所有 Flex 项目宽度之和大于 Flex 容器时，将会溢出容器（flex-wrap为nowrap时），flex-shrink 就可以根据 Flex 项目设置的数值比例来分配 Flex 容器的不足空间，也就是按比例因子缩小自身的宽度，以免溢出Flex容器。</p>\n<ul>\n<li>flex-shrink 的默认值是 1，其接受的值是一个数值，可以是一个小数值，但不支持负值；</li>\n<li>flex-shrink 是指 Flex 项目分配 Flex 容器不足空间的占比；</li>\n<li>在 Flexbox 布局当中，会阻止 Flex 项目元素宽度缩小至 0。此时 Flex 项目会以 min-content 的大小进行计算，这个大小是它们利用任何可以利用的自动断行机会后所变成的；</li>\n<li>当所有 Flex 项目的收缩因子（flex-shrink）总和小于 1 时，Flex 容器不足空间不会完全分配完，依旧会溢出 Flex 容器。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>大漠的这篇<a href=\"https://zhuanlan.zhihu.com/p/50449041\" target=\"_blank\" rel=\"noopener\">聊聊Flexbox布局中的flex的演算法</a>是我看过对 flex 布局中的 flex-basis、flex-grow、flex-shrink 三个属性讨论最为深入的一篇文章，这里做一下\b阅读总结。</p>\n</blockquote>\n<h3 id=\"min-content-和-max-content\"><a href=\"#min-content-和-max-content\" class=\"headerlink\" title=\"min-content 和 max-content\"></a>min-content 和 max-content</h3><p>min-content 和 max-content 是 CSS3 中新的 width 的值，大漠在这里贴了一篇张鑫旭的文章：<a href=\"https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/\" target=\"_blank\" rel=\"noopener\">理解CSS3 max/min-content及fit-content等width值</a>，总结如下：</p>\n<ol>\n<li>min-content 的大小，从本质上讲，是由字符串中最长的单词决定了大小；</li>\n<li>max-content 则和 min-content 相反。它会变得尽可能大, 没有自动换行的机会。</li>\n</ol>\n<p>与 flex 布局的关系：</p>\n<ol>\n<li>flex-basis 为 auto 时，会把 Flex 项目的 max-content 作为 flex-basise 的值；</li>\n<li>Flexbox 布局中会阻止 Flex 项目元素宽度缩小至 0，此时 Flex 项目会以 min-content 的大小进行计算。</li>\n</ol>\n<h3 id=\"flex-basis\"><a href=\"#flex-basis\" class=\"headerlink\" title=\"flex-basis\"></a>flex-basis</h3><p>flex-basis 属性在任何空间分配发生之前初始化 Flex 项目的尺寸。</p>\n<ul>\n<li>flex-basis 默认值为 auto；</li>\n<li>如果 Flex 项目显式的设置了 width 值，同时 flex-basis 为 auto 时，则 Flex 项目的宽度为按 width 来计算，如果未显式设置 width，则按 Flex 项目的内容宽度即 max-content 来计算；</li>\n<li>如果 Flex 项目显式的设置了 width 值，同时显式设置了 flex-basis 的具体值，则 Flex 项目会忽略 width 值，会按 flex-basis 来计算 Flex 项目；</li>\n<li>当 Flex 容器剩余空间不足时，Flex 项目的实际宽度并不会按 flex-basis 来计算，会根据 flex-grow 和 flex-shrink 设置的值给 Flex 项目分配相应的空间；</li>\n<li>对于 Flexbox 布局中，不建议显式的设置 Flex 项目的 width 值，而是通过 flex-basis 来控制 Flex 项目的宽度，这样更具弹性；</li>\n<li>如果 Flex 项目显式的设置了 min-width 或 max-width 值时，当 flex-basis 计算出来的值小于 min-width 则按 min-width 值设置 Flex 项目宽度，反之，计算出来的值大于 max-width 值时，则按 max-width 的值设置 Flex 项目宽度。</li>\n</ul>\n<h3 id=\"flex-grow\"><a href=\"#flex-grow\" class=\"headerlink\" title=\"flex-grow\"></a>flex-grow</h3><p>flex-grow 是一个扩展因子（扩展比例）。当 Flex 容器有一定的剩余空间时，flex-grow 可以让 Flex 项目分配 Flex 容器剩余的空间，每个 Flex 项目将根据 flex-grow 因子扩展，从而让 Flex 项目布满整个 Flex 容器（有效利用 Flex 容器的剩余空间）。</p>\n<ul>\n<li>flex-grow 的默认值是 0，其接受的值是一个数值，可以是一个小数值，但不支持负值；</li>\n<li>flex-grow 是指 Flex 项目分配 Flex 容器剩余的空间的占比；</li>\n<li>\b当 flex-grow 设置为小数，且所有 flex-grow 之和小于 1 时，Flex 项目不会用完 Flex 容器的剩余空间；</li>\n<li>flex-basis 的值为 auto，且没有给 Flex 项目显式的设置 width 时，Flex 项目的大小都取决于其内容的 max-content 大小，此时 Flex 容器的剩余的空间将由浏览器根据 Flex 项目的内容宽度来计算；</li>\n<li>针对上面的场景，如果你想让所有 Flex 项目具有相同的尺寸，可以显式的设置 Flex 项目的 flex-basis 值为0（flex: 1 1 0）。</li>\n</ul>\n<h3 id=\"flex-shrink\"><a href=\"#flex-shrink\" class=\"headerlink\" title=\"flex-shrink\"></a>flex-shrink</h3><p>flex-shrink 和 flex-grow 类似，只不过 flex-shrink 是用来控制 Flex 项目缩放因子。当所有 Flex 项目宽度之和大于 Flex 容器时，将会溢出容器（flex-wrap为nowrap时），flex-shrink 就可以根据 Flex 项目设置的数值比例来分配 Flex 容器的不足空间，也就是按比例因子缩小自身的宽度，以免溢出Flex容器。</p>\n<ul>\n<li>flex-shrink 的默认值是 1，其接受的值是一个数值，可以是一个小数值，但不支持负值；</li>\n<li>flex-shrink 是指 Flex 项目分配 Flex 容器不足空间的占比；</li>\n<li>在 Flexbox 布局当中，会阻止 Flex 项目元素宽度缩小至 0。此时 Flex 项目会以 min-content 的大小进行计算，这个大小是它们利用任何可以利用的自动断行机会后所变成的；</li>\n<li>当所有 Flex 项目的收缩因子（flex-shrink）总和小于 1 时，Flex 容器不足空间不会完全分配完，依旧会溢出 Flex 容器。</li>\n</ul>\n","plink":"https://vincentdou.github.io/blog/post/2018-11-21-flex演算法总结/","type":"post"},{"layout":"post","title":"2018年过去了，我决定去怀念她","date":"2019-01-02T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n{% raw %}\n<iframe src=\"//player.bilibili.com/player.html?aid=20352237&cid=33255133&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n{% endraw %}\n\n> 外链：[B站]('https://www.bilibili.com/video/av20352237/') [YouTube]('https://www.youtube.com/watch?v=lO9d-AJai8Q')\n\n我要以这段视频作为开头，事实上也正是这段视频让我\b想要写这篇总结，年初看到这部视频，到现在我仍然想要把它放在这里。这帮人利用 FaceBook 直播的 30 秒延迟，一环套一环的把音乐丰富起来，像是音轨实体化了，玩过 GarageBand 的话应该很懂这种感觉。对这种新奇巧妙的作品，总是缺少抵抗力。\n\n{% raw %}\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=459776592&auto=1&height=66\"></iframe>\n{% endraw %}\n\n似乎介绍直火帮就没法绕过他们的学历，我想免于俗套但又不得不承认他们让我着迷的地方——具有思想性的词 & 舒服的 flow，跟他们的受教育层次以及美国留学经历有蛮大关系。《立秋》、《如果你听到了，那这可能不是写给你的》、《爬墙少年》都很棒，听就完了，他们大概是我 2018 年最喜欢的音乐人。（Hip-Hop 不是 pussy money weed）\n\n2018 年我对世界的看法仍在持续的变化，今年影响我的主要是许知远\b，这个影响直接或间接，传递价值观或者打开一扇窗，很像 2013 年梁欢对于我~~，俩人都充满\b争议:)~~。\b某种未经思考的「虚无主义」以「佛系」的幌子广泛传播的一年，这个蓬头垢面、愤怒的「油腻」中年人迎面走来，坚守着理性思考、人文主义。看了大部分的《十三邀》，读了《时代的稻草人》、《一个游荡者的世界》，开始放弃大部分我曾喜欢的知识节目、反感大部分名为「知识分子」的商人。说回「油腻」，在我现在的评价体系里，高晓松、李诞比许油腻多了。\n\n一年前的规划是多做输出，如果以阅读点赞数为标准，最成功的应该是我在「即刻App」上面一条写李诞的动态，一个多月前的动态这几天还时不时被赞。起初几天给我的虚荣心上的满足还是很舒服的，但到了今天重新审视，我开始怀疑点赞数跟我动态质量有多少关系。话题选了「现在娱乐圈谁比较火」，流量话题；写的是李诞，还是他在酒吧被拍期间，应该算是蹭\b了热点，就很没劲。2019 年，还是想更好的做输出，不过一来不喜欢这种输出环境，二来自己也很浅薄。多看书，少胡想吧。\n\n{% raw %}\n<iframe width=\"330\" height=\"185\" src=\"https://www.youtube.com/embed/aHZ44WRDDR8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n{% endraw %}\n\n喜欢阅后即瞎是因为他们的幽默搞笑，但这部《贫穷，很可能仅仅是因为你缺乏逻辑》我会反复看的原因，大概是它有带给我一些思考并且影响我之后的思考方式。~~B站上的下架了，不能翻墙的想看自行搜索了。~~整理一下里面提到的几种逻辑谬误：\n\n1. 红鲱鱼谬误(Red Herring Fallacy)：指为了混淆视听，将一个不相关的话题强行插入原本议题的逻辑谬误。\n2. 马车与金币谬误(Carriage and Coins Fallacy)：即偷换议题谬误，将原本的话题偷换为另一个对自己有利的话题进行诡辩的逻辑谬误。\n3. 拼图谬误(Taking a Part for Whole)：指那些以偏概全，用片面狭隘的视角看待整体问题的逻辑谬误。\n4. 诉诸名人谬误(Appeal to Celebrity)：指利用“某名人做某事，所以某事是对的”进行诡辩的逻辑谬误。\n5. 伪两难推理谬误(Pseudo-Dilemma Fallacy)：指误导性地表现出一个不存在的两难困境来蒙蔽对方的逻辑谬误。\n\n「为了不被那些正确所左右，为了能够独立作出自己的选择。」","source":"_posts/2019-01-03-2018过去了，我决定去怀念她.md","raw":"---\nlayout:     post\ntitle:      \"2018年过去了，我决定去怀念她\"\ndate:       2019-01-03\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 碎碎念\n    - 年度总结\n---\n\n{% raw %}\n<iframe src=\"//player.bilibili.com/player.html?aid=20352237&cid=33255133&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n{% endraw %}\n\n> 外链：[B站]('https://www.bilibili.com/video/av20352237/') [YouTube]('https://www.youtube.com/watch?v=lO9d-AJai8Q')\n\n我要以这段视频作为开头，事实上也正是这段视频让我\b想要写这篇总结，年初看到这部视频，到现在我仍然想要把它放在这里。这帮人利用 FaceBook 直播的 30 秒延迟，一环套一环的把音乐丰富起来，像是音轨实体化了，玩过 GarageBand 的话应该很懂这种感觉。对这种新奇巧妙的作品，总是缺少抵抗力。\n\n{% raw %}\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=459776592&auto=1&height=66\"></iframe>\n{% endraw %}\n\n似乎介绍直火帮就没法绕过他们的学历，我想免于俗套但又不得不承认他们让我着迷的地方——具有思想性的词 & 舒服的 flow，跟他们的受教育层次以及美国留学经历有蛮大关系。《立秋》、《如果你听到了，那这可能不是写给你的》、《爬墙少年》都很棒，听就完了，他们大概是我 2018 年最喜欢的音乐人。（Hip-Hop 不是 pussy money weed）\n\n2018 年我对世界的看法仍在持续的变化，今年影响我的主要是许知远\b，这个影响直接或间接，传递价值观或者打开一扇窗，很像 2013 年梁欢对于我~~，俩人都充满\b争议:)~~。\b某种未经思考的「虚无主义」以「佛系」的幌子广泛传播的一年，这个蓬头垢面、愤怒的「油腻」中年人迎面走来，坚守着理性思考、人文主义。看了大部分的《十三邀》，读了《时代的稻草人》、《一个游荡者的世界》，开始放弃大部分我曾喜欢的知识节目、反感大部分名为「知识分子」的商人。说回「油腻」，在我现在的评价体系里，高晓松、李诞比许油腻多了。\n\n一年前的规划是多做输出，如果以阅读点赞数为标准，最成功的应该是我在「即刻App」上面一条写李诞的动态，一个多月前的动态这几天还时不时被赞。起初几天给我的虚荣心上的满足还是很舒服的，但到了今天重新审视，我开始怀疑点赞数跟我动态质量有多少关系。话题选了「现在娱乐圈谁比较火」，流量话题；写的是李诞，还是他在酒吧被拍期间，应该算是蹭\b了热点，就很没劲。2019 年，还是想更好的做输出，不过一来不喜欢这种输出环境，二来自己也很浅薄。多看书，少胡想吧。\n\n{% raw %}\n<iframe width=\"330\" height=\"185\" src=\"https://www.youtube.com/embed/aHZ44WRDDR8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n{% endraw %}\n\n喜欢阅后即瞎是因为他们的幽默搞笑，但这部《贫穷，很可能仅仅是因为你缺乏逻辑》我会反复看的原因，大概是它有带给我一些思考并且影响我之后的思考方式。~~B站上的下架了，不能翻墙的想看自行搜索了。~~整理一下里面提到的几种逻辑谬误：\n\n1. 红鲱鱼谬误(Red Herring Fallacy)：指为了混淆视听，将一个不相关的话题强行插入原本议题的逻辑谬误。\n2. 马车与金币谬误(Carriage and Coins Fallacy)：即偷换议题谬误，将原本的话题偷换为另一个对自己有利的话题进行诡辩的逻辑谬误。\n3. 拼图谬误(Taking a Part for Whole)：指那些以偏概全，用片面狭隘的视角看待整体问题的逻辑谬误。\n4. 诉诸名人谬误(Appeal to Celebrity)：指利用“某名人做某事，所以某事是对的”进行诡辩的逻辑谬误。\n5. 伪两难推理谬误(Pseudo-Dilemma Fallacy)：指误导性地表现出一个不存在的两难困境来蒙蔽对方的逻辑谬误。\n\n「为了不被那些正确所左右，为了能够独立作出自己的选择。」","slug":"2019-01-03-2018过去了，我决定去怀念她","published":1,"updated":"2019-01-03T13:24:22.300Z","comments":0,"photos":[],"link":"post/2019-01-03-2018过去了，我决定去怀念她","_id":"cjz2epjf1000yn3w5k0rvng1t","content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=20352237&cid=33255133&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n\n<blockquote>\n<p>外链：<a href=\"&#39;https://www.bilibili.com/video/av20352237/&#39;\">B站</a> <a href=\"&#39;https://www.youtube.com/watch?v=lO9d-AJai8Q&#39;\">YouTube</a></p>\n</blockquote>\n<p>我要以这段视频作为开头，事实上也正是这段视频让我\b想要写这篇总结，年初看到这部视频，到现在我仍然想要把它放在这里。这帮人利用 FaceBook 直播的 30 秒延迟，一环套一环的把音乐丰富起来，像是音轨实体化了，玩过 GarageBand 的话应该很懂这种感觉。对这种新奇巧妙的作品，总是缺少抵抗力。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=459776592&auto=1&height=66\"></iframe>\n\n<p>似乎介绍直火帮就没法绕过他们的学历，我想免于俗套但又不得不承认他们让我着迷的地方——具有思想性的词 &amp; 舒服的 flow，跟他们的受教育层次以及美国留学经历有蛮大关系。《立秋》、《如果你听到了，那这可能不是写给你的》、《爬墙少年》都很棒，听就完了，他们大概是我 2018 年最喜欢的音乐人。（Hip-Hop 不是 pussy money weed）</p>\n<p>2018 年我对世界的看法仍在持续的变化，今年影响我的主要是许知远\b，这个影响直接或间接，传递价值观或者打开一扇窗，很像 2013 年梁欢对于我<del>，俩人都充满\b争议:)</del>。\b某种未经思考的「虚无主义」以「佛系」的幌子广泛传播的一年，这个蓬头垢面、愤怒的「油腻」中年人迎面走来，坚守着理性思考、人文主义。看了大部分的《十三邀》，读了《时代的稻草人》、《一个游荡者的世界》，开始放弃大部分我曾喜欢的知识节目、反感大部分名为「知识分子」的商人。说回「油腻」，在我现在的评价体系里，高晓松、李诞比许油腻多了。</p>\n<p>一年前的规划是多做输出，如果以阅读点赞数为标准，最成功的应该是我在「即刻App」上面一条写李诞的动态，一个多月前的动态这几天还时不时被赞。起初几天给我的虚荣心上的满足还是很舒服的，但到了今天重新审视，我开始怀疑点赞数跟我动态质量有多少关系。话题选了「现在娱乐圈谁比较火」，流量话题；写的是李诞，还是他在酒吧被拍期间，应该算是蹭\b了热点，就很没劲。2019 年，还是想更好的做输出，不过一来不喜欢这种输出环境，二来自己也很浅薄。多看书，少胡想吧。</p>\n\n<iframe width=\"330\" height=\"185\" src=\"https://www.youtube.com/embed/aHZ44WRDDR8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<p>喜欢阅后即瞎是因为他们的幽默搞笑，但这部《贫穷，很可能仅仅是因为你缺乏逻辑》我会反复看的原因，大概是它有带给我一些思考并且影响我之后的思考方式。<del>B站上的下架了，不能翻墙的想看自行搜索了。</del>整理一下里面提到的几种逻辑谬误：</p>\n<ol>\n<li>红鲱鱼谬误(Red Herring Fallacy)：指为了混淆视听，将一个不相关的话题强行插入原本议题的逻辑谬误。</li>\n<li>马车与金币谬误(Carriage and Coins Fallacy)：即偷换议题谬误，将原本的话题偷换为另一个对自己有利的话题进行诡辩的逻辑谬误。</li>\n<li>拼图谬误(Taking a Part for Whole)：指那些以偏概全，用片面狭隘的视角看待整体问题的逻辑谬误。</li>\n<li>诉诸名人谬误(Appeal to Celebrity)：指利用“某名人做某事，所以某事是对的”进行诡辩的逻辑谬误。</li>\n<li>伪两难推理谬误(Pseudo-Dilemma Fallacy)：指误导性地表现出一个不存在的两难困境来蒙蔽对方的逻辑谬误。</li>\n</ol>\n<p>「为了不被那些正确所左右，为了能够独立作出自己的选择。」</p>\n","site":{"data":{}},"excerpt":"","more":"\n<iframe src=\"//player.bilibili.com/player.html?aid=20352237&cid=33255133&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n\n<blockquote>\n<p>外链：<a href=\"&#39;https://www.bilibili.com/video/av20352237/&#39;\">B站</a> <a href=\"&#39;https://www.youtube.com/watch?v=lO9d-AJai8Q&#39;\">YouTube</a></p>\n</blockquote>\n<p>我要以这段视频作为开头，事实上也正是这段视频让我\b想要写这篇总结，年初看到这部视频，到现在我仍然想要把它放在这里。这帮人利用 FaceBook 直播的 30 秒延迟，一环套一环的把音乐丰富起来，像是音轨实体化了，玩过 GarageBand 的话应该很懂这种感觉。对这种新奇巧妙的作品，总是缺少抵抗力。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=459776592&auto=1&height=66\"></iframe>\n\n<p>似乎介绍直火帮就没法绕过他们的学历，我想免于俗套但又不得不承认他们让我着迷的地方——具有思想性的词 &amp; 舒服的 flow，跟他们的受教育层次以及美国留学经历有蛮大关系。《立秋》、《如果你听到了，那这可能不是写给你的》、《爬墙少年》都很棒，听就完了，他们大概是我 2018 年最喜欢的音乐人。（Hip-Hop 不是 pussy money weed）</p>\n<p>2018 年我对世界的看法仍在持续的变化，今年影响我的主要是许知远\b，这个影响直接或间接，传递价值观或者打开一扇窗，很像 2013 年梁欢对于我<del>，俩人都充满\b争议:)</del>。\b某种未经思考的「虚无主义」以「佛系」的幌子广泛传播的一年，这个蓬头垢面、愤怒的「油腻」中年人迎面走来，坚守着理性思考、人文主义。看了大部分的《十三邀》，读了《时代的稻草人》、《一个游荡者的世界》，开始放弃大部分我曾喜欢的知识节目、反感大部分名为「知识分子」的商人。说回「油腻」，在我现在的评价体系里，高晓松、李诞比许油腻多了。</p>\n<p>一年前的规划是多做输出，如果以阅读点赞数为标准，最成功的应该是我在「即刻App」上面一条写李诞的动态，一个多月前的动态这几天还时不时被赞。起初几天给我的虚荣心上的满足还是很舒服的，但到了今天重新审视，我开始怀疑点赞数跟我动态质量有多少关系。话题选了「现在娱乐圈谁比较火」，流量话题；写的是李诞，还是他在酒吧被拍期间，应该算是蹭\b了热点，就很没劲。2019 年，还是想更好的做输出，不过一来不喜欢这种输出环境，二来自己也很浅薄。多看书，少胡想吧。</p>\n\n<iframe width=\"330\" height=\"185\" src=\"https://www.youtube.com/embed/aHZ44WRDDR8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<p>喜欢阅后即瞎是因为他们的幽默搞笑，但这部《贫穷，很可能仅仅是因为你缺乏逻辑》我会反复看的原因，大概是它有带给我一些思考并且影响我之后的思考方式。<del>B站上的下架了，不能翻墙的想看自行搜索了。</del>整理一下里面提到的几种逻辑谬误：</p>\n<ol>\n<li>红鲱鱼谬误(Red Herring Fallacy)：指为了混淆视听，将一个不相关的话题强行插入原本议题的逻辑谬误。</li>\n<li>马车与金币谬误(Carriage and Coins Fallacy)：即偷换议题谬误，将原本的话题偷换为另一个对自己有利的话题进行诡辩的逻辑谬误。</li>\n<li>拼图谬误(Taking a Part for Whole)：指那些以偏概全，用片面狭隘的视角看待整体问题的逻辑谬误。</li>\n<li>诉诸名人谬误(Appeal to Celebrity)：指利用“某名人做某事，所以某事是对的”进行诡辩的逻辑谬误。</li>\n<li>伪两难推理谬误(Pseudo-Dilemma Fallacy)：指误导性地表现出一个不存在的两难困境来蒙蔽对方的逻辑谬误。</li>\n</ol>\n<p>「为了不被那些正确所左右，为了能够独立作出自己的选择。」</p>\n","plink":"https://vincentdou.github.io/blog/post/2019-01-03-2018过去了，我决定去怀念她/","type":"post"},{"layout":"post","title":"你不知道的JS-作用域与闭包","date":"2018-05-13T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> 尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言。\n\n### 什么是作用域？\n\n「编译」\b三步骤：\n\n1. 分词/词法分析： 将一连串字符打断成（对于语言来说）有意义的片段，称为token（记号）。举例来说，考虑这段程序：`var a = 2;`。这段程序很可能会被打断成如下token：`var`，`a`，`=`，`2`，和 `;`。空格也许会被保留为一个 token，这要看它是否是有意义的。\n\n    > 注意： 分词和词法分析之间的区别是微妙和学术上的，其中心在于这些 token 是否以 *无状态* 或 *有状态* 的方式被识别。简而言之，如果分词器去调用有状态的解析规则来弄清a是否应当被考虑为一个不同的 token，还是只是其他 token 的一部分，那么这就是 词法分析。\n\n2. 解析： 将一个 token 的流（数组）转换为一个嵌套元素的树，它总体上表示了程序的语法结构。这棵树称为 “AST”（Abstract Syntax Tree —— 抽象语法树）。\n\n    > `var a = 2;` 的树也许开始于称为 VariableDeclaration（变量声明）顶层节点，带有一个称为 Identifier（标识符）的子节点（它的值为a），和另一个称为 AssignmentExpression（赋值表达式）的子节点，而这个子节点本身带有一个称为 NumericLiteral（数字字面量）的子节点（它的值为2）。\n\n3. 代码生成： 这个处理将 AST 转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。\n\n> 对于一个变量赋值，发生了两个不同的动作：第一，`编译器`声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，`引擎`在`作用域`中查询这个变量并给它赋值，如果找到的话。\n\n#### LHS查询和RHS查询\n\n当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。\n\n> “赋值的目标（LHS）” & “赋值的源（RHS）”\n\n> 将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的\n\n**LHS查询**\n\n- 对变量进行赋值，就会使用 LHS 查询；\n- `=`号操作符或调用函数时传入参数的操作都会导致关联作用域的赋值查询（LHS）；\n- 不成功的 LHS 引用，非严格模式下会导致自动隐式创建一个全局变量，严格模式下或者抛出 ReferenceError 异常。\n\n**RHS查询**\n\n- 如果是获取变量的值，就会使用RHS查询；\n- 不成功的 RHS 引用会导致抛出 ReferenceError异常。（即RHS查询在所有嵌套作用域到没找到所需变量）；\n- 如果 RHS 查询到了一个变量，但是你尝试对这个变量进行不合理操作，比如对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，引擎就会抛出 TypeError 异常。\n\n### 词法作用域\n\n> 词法作用域是 JavaScript 所采用的作用域模型\n\n在 JavaScript 中有两种机制可以“欺骗”词法作用域： `eval(..)` 和 `with` 。\n\n- JavaScript 中的`eval(..)`函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。因此它会欺骗词法作用域。\n\n> 当`eval(..)`被用于一个操作它自己的词法作用域的 strict 模式程序时，在`eval(..)`内部做出的声明不会实际上修改包围它的作用域。\n\n> 在 JavaScript 中还有其他的工具拥有与`eval(..)`非常类似的效果。`setTimeout(..)`和`setInterval(..)`可以为它们各自的第一个参数值接收一个字符串，其内容将会被`eval`为一个动态生成的函数的代码。`new Function(..)`函数构造器类似地为它的最后一个参数值接收一个代码字符串，来把它转换为一个动态生成的函数（前面的参数值，如果有的话，将作为新函数的形式参数）。\n\n- with 的常见方式是作为一种缩写，来引用一个对象的多个属性，而不必每次都重复对象引用本身。\n\n> 尽管一个`with`块儿将一个对象视为一个词法作用域，但是在`with`块儿内部的一个普通`var`声明将不会归于这个`with`块儿的作用域，而是归于包含它的函数作用域。\n> 如果`eval(..)`函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而`with`语句实际上是从你传递给它的对象中凭空制造了一个全新的词法作用域。\n\n> strict 模式下`with`不允许使用\n\n这些机制的缺点是，它压制了*引擎*在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是不合法的。这两种特性的结果就是代码将会运行的更慢。不要使用它们。\n\n### 函数与块儿作用域\n\n在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。\n\n从ES3开始，`try/catch`结构在`catch`子句上拥有块儿作用域。\n\n在ES6中，引入了`let`关键字（var 关键字的表兄弟）允许在任意代码块中声明变量。使用`let`做出的声明将不会在它们所出现的整个块儿的作用域中提升。\n\n**函数声明** **函数表达式**\n\n#### IIFE(立即被调用函数表达)\n\nImmediately Invoked Function Expression\n\n`(function foo(){ .. })()`第一个外围的`()`使这个函数变成表达式，而第二个`()`执行这个函数。\n\n### 提升\n\nJavaScript 引擎会\b将`var a = 2`看作`var a`和`a = 2`两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。\n\n这将导致在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前 首先 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们 **各自** 的作用域顶部（不是程序的顶端），这就是我们所说的“提升”。\n\n> 只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在原处。提升是以作用域为单位的。\n\n> **函数声明会被提升，但是函数表达式不会。**\n\n```js\nfoo(); // TypeError\nbar(); // ReferenceError\n\nvar foo = function bar() {\n    // ...\n};\n```\n\n这个代码段可以（使用提升）更准确地解释为：\n\n```js\nvar foo;\n\nfoo(); // TypeError\nbar(); // ReferenceError\n\nfoo = function() {\n    var bar = ...self...\n    // ...\n}\n```\n\n#### 函数会首先被提升，然后才是变量。\n\n```js\nfoo(); // 1\n\nvar foo;\n\nfunction foo() {\n\tconsole.log( 1 );\n}\n\nfoo = function() {\n\tconsole.log( 2 );\n};\n```\n\n1 被打印了，而不是 2，这个代码段被引擎解释执行为：\n\n```js\nfunction foo() {\n\tconsole.log( 1 );\n}\n\nfoo(); // 1\n\nfoo = function() {\n\tconsole.log( 2 );\n};\n```\n\n`var foo`是一个重复（因此被无视）的声明，即便它出现在`function foo()...`声明之前，因为函数声明是在普通变量之前被提升的。\n\n> 后续的函数声明会覆盖前一个\n\n> 普通的块儿作用域里的函数声明一般会被提升至外围的作用域\n\n### 作用域闭包\n\n- 当函数是在当前词法作用域之外执行，如果函数可以记住并访问所在的词法作用域时，就产生了闭包。\n\n- 计时器、事件处理器、Ajax请求、跨窗口消息、web worker、或者任何其他的异步（或同步！）任务，当你传入一个回调函数，你就在它周围悬挂了一些闭包！\n\n```js\nfor (var i=1; i<=5; i++) {\n\t(function(j){\n\t\tsetTimeout( function timer(){\n\t\t\tconsole.log( j );\n\t\t}, j*1000 );\n\t})( i );\n}\n```\n\n模块要求两个关键性质：\n\n1. 必须有一个外部的外围函数，而且它必须至少被调用一次（每次创建一个新的模块实例）。\n\n2. 外围的函数必须至少返回一个内部函数，这样这个内部函数才拥有私有作用域的闭包，并且可以访问和/或修改这个私有状态。\n\n```js\nvar foo = (function CoolModule() {\n\tvar something = \"cool\";\n\tvar another = [1, 2, 3];\n\n\tfunction doSomething() {\n\t\tconsole.log( something );\n\t}\n\n\tfunction doAnother() {\n\t\tconsole.log( another.join( \" ! \" ) );\n\t}\n\n\treturn {\n\t\tdoSomething: doSomething,\n\t\tdoAnother: doAnother\n\t};\n})();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1 ! 2 ! 3\n```\n\n#### 模块化\n\n```js\nvar MyModules = (function Manager() {\n\tvar modules = {};\n\n\tfunction define(name, deps, impl) {\n\t\tfor (var i=0; i<deps.length; i++) {\n\t\t\tdeps[i] = modules[deps[i]];\n\t\t}\n\t\tmodules[name] = impl.apply( impl, deps );\n\t}\n\n\tfunction get(name) {\n\t\treturn modules[name];\n\t}\n\n\treturn {\n\t\tdefine: define,\n\t\tget: get\n\t};\n})();\n```\n\n```js\nMyModules.define( \"bar\", [], function(){\n\tfunction hello(who) {\n\t\treturn \"Let me introduce: \" + who;\n\t}\n\n\treturn {\n\t\thello: hello\n\t};\n} );\n\nMyModules.define( \"foo\", [\"bar\"], function(bar){\n\tvar hungry = \"hippo\";\n\n\tfunction awesome() {\n\t\tconsole.log( bar.hello( hungry ).toUpperCase() );\n\t}\n\n\treturn {\n\t\tawesome: awesome\n\t};\n} );\n\nvar bar = MyModules.get( \"bar\" );\nvar foo = MyModules.get( \"foo\" );\n\nconsole.log(\n\tbar.hello( \"hippo\" )\n); // Let me introduce: hippo\n\nfoo.awesome(); // LET ME INTRODUCE: HIPPO\n```\n\n#### ES6中的模块\n\n- import 在当前的作用域中导入一个模块的 API 的一个或多个成员，每个都绑定到一个变量；\n- module 将整个模块的 API 导入到一个被绑定的变量；\n- export 为当前模块的公有API导出一个标识符（变量，函数）。在一个模块的定义中，这些操作符可以根据需要使用任意多次。\n\n### 附录\n\n#### 动态作用域\n\n- 词法作用域是一组关于引擎如何查询变量和它在何处能够找到变量的规则。词法作用域的关键性质是，它是在代码编写时被定义的。\n- 动态作用域是在运行时被确定的，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。\n- 两者的关键差异是：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是函数在何处被声明，但是动态作用域关心的是函数从何处被调用。\n- JavaScript 没有动态作用域，但是 this 机制有些像动态作用域。\n\n#### 填补块儿作用域\n\nES6 才提出了 let，而早在 ES3 的`try/catch`就已经有了块儿作用域。我们想在前 ES6 环境中使用块儿作用域可以这样：\n\n```js\n// ES6 let\n{\n\tlet a = 2;\n\tconsole.log( a ); // 2\n}\n\nconsole.log( a ); // ReferenceError\n```\n\n转为：\n\n```js\n// ES3 try/catch\ntry{throw 2}catch(a){\n\tconsole.log( a ); // 2\n}\n\nconsole.log( a ); // ReferenceError\n```\n\nTraceur的转移结果：\n\n```js\n{\n\ttry {\n\t\tthrow undefined;\n\t} catch (a) {\n\t\ta = 2;\n\t\tconsole.log( a );\n\t}\n}\n\nconsole.log( a );\n```\n\n","source":"_posts/2018-05-14-你不知道的JS-1.markdown","raw":"---\nlayout:     post\ntitle:      \"你不知道的JS-作用域与闭包\"\ndate:       2018-05-14\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - 你不知道的JS\n---\n\n> 尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言。\n\n### 什么是作用域？\n\n「编译」\b三步骤：\n\n1. 分词/词法分析： 将一连串字符打断成（对于语言来说）有意义的片段，称为token（记号）。举例来说，考虑这段程序：`var a = 2;`。这段程序很可能会被打断成如下token：`var`，`a`，`=`，`2`，和 `;`。空格也许会被保留为一个 token，这要看它是否是有意义的。\n\n    > 注意： 分词和词法分析之间的区别是微妙和学术上的，其中心在于这些 token 是否以 *无状态* 或 *有状态* 的方式被识别。简而言之，如果分词器去调用有状态的解析规则来弄清a是否应当被考虑为一个不同的 token，还是只是其他 token 的一部分，那么这就是 词法分析。\n\n2. 解析： 将一个 token 的流（数组）转换为一个嵌套元素的树，它总体上表示了程序的语法结构。这棵树称为 “AST”（Abstract Syntax Tree —— 抽象语法树）。\n\n    > `var a = 2;` 的树也许开始于称为 VariableDeclaration（变量声明）顶层节点，带有一个称为 Identifier（标识符）的子节点（它的值为a），和另一个称为 AssignmentExpression（赋值表达式）的子节点，而这个子节点本身带有一个称为 NumericLiteral（数字字面量）的子节点（它的值为2）。\n\n3. 代码生成： 这个处理将 AST 转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。\n\n> 对于一个变量赋值，发生了两个不同的动作：第一，`编译器`声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，`引擎`在`作用域`中查询这个变量并给它赋值，如果找到的话。\n\n#### LHS查询和RHS查询\n\n当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。\n\n> “赋值的目标（LHS）” & “赋值的源（RHS）”\n\n> 将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的\n\n**LHS查询**\n\n- 对变量进行赋值，就会使用 LHS 查询；\n- `=`号操作符或调用函数时传入参数的操作都会导致关联作用域的赋值查询（LHS）；\n- 不成功的 LHS 引用，非严格模式下会导致自动隐式创建一个全局变量，严格模式下或者抛出 ReferenceError 异常。\n\n**RHS查询**\n\n- 如果是获取变量的值，就会使用RHS查询；\n- 不成功的 RHS 引用会导致抛出 ReferenceError异常。（即RHS查询在所有嵌套作用域到没找到所需变量）；\n- 如果 RHS 查询到了一个变量，但是你尝试对这个变量进行不合理操作，比如对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，引擎就会抛出 TypeError 异常。\n\n### 词法作用域\n\n> 词法作用域是 JavaScript 所采用的作用域模型\n\n在 JavaScript 中有两种机制可以“欺骗”词法作用域： `eval(..)` 和 `with` 。\n\n- JavaScript 中的`eval(..)`函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。因此它会欺骗词法作用域。\n\n> 当`eval(..)`被用于一个操作它自己的词法作用域的 strict 模式程序时，在`eval(..)`内部做出的声明不会实际上修改包围它的作用域。\n\n> 在 JavaScript 中还有其他的工具拥有与`eval(..)`非常类似的效果。`setTimeout(..)`和`setInterval(..)`可以为它们各自的第一个参数值接收一个字符串，其内容将会被`eval`为一个动态生成的函数的代码。`new Function(..)`函数构造器类似地为它的最后一个参数值接收一个代码字符串，来把它转换为一个动态生成的函数（前面的参数值，如果有的话，将作为新函数的形式参数）。\n\n- with 的常见方式是作为一种缩写，来引用一个对象的多个属性，而不必每次都重复对象引用本身。\n\n> 尽管一个`with`块儿将一个对象视为一个词法作用域，但是在`with`块儿内部的一个普通`var`声明将不会归于这个`with`块儿的作用域，而是归于包含它的函数作用域。\n> 如果`eval(..)`函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而`with`语句实际上是从你传递给它的对象中凭空制造了一个全新的词法作用域。\n\n> strict 模式下`with`不允许使用\n\n这些机制的缺点是，它压制了*引擎*在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是不合法的。这两种特性的结果就是代码将会运行的更慢。不要使用它们。\n\n### 函数与块儿作用域\n\n在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。\n\n从ES3开始，`try/catch`结构在`catch`子句上拥有块儿作用域。\n\n在ES6中，引入了`let`关键字（var 关键字的表兄弟）允许在任意代码块中声明变量。使用`let`做出的声明将不会在它们所出现的整个块儿的作用域中提升。\n\n**函数声明** **函数表达式**\n\n#### IIFE(立即被调用函数表达)\n\nImmediately Invoked Function Expression\n\n`(function foo(){ .. })()`第一个外围的`()`使这个函数变成表达式，而第二个`()`执行这个函数。\n\n### 提升\n\nJavaScript 引擎会\b将`var a = 2`看作`var a`和`a = 2`两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。\n\n这将导致在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前 首先 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们 **各自** 的作用域顶部（不是程序的顶端），这就是我们所说的“提升”。\n\n> 只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在原处。提升是以作用域为单位的。\n\n> **函数声明会被提升，但是函数表达式不会。**\n\n```js\nfoo(); // TypeError\nbar(); // ReferenceError\n\nvar foo = function bar() {\n    // ...\n};\n```\n\n这个代码段可以（使用提升）更准确地解释为：\n\n```js\nvar foo;\n\nfoo(); // TypeError\nbar(); // ReferenceError\n\nfoo = function() {\n    var bar = ...self...\n    // ...\n}\n```\n\n#### 函数会首先被提升，然后才是变量。\n\n```js\nfoo(); // 1\n\nvar foo;\n\nfunction foo() {\n\tconsole.log( 1 );\n}\n\nfoo = function() {\n\tconsole.log( 2 );\n};\n```\n\n1 被打印了，而不是 2，这个代码段被引擎解释执行为：\n\n```js\nfunction foo() {\n\tconsole.log( 1 );\n}\n\nfoo(); // 1\n\nfoo = function() {\n\tconsole.log( 2 );\n};\n```\n\n`var foo`是一个重复（因此被无视）的声明，即便它出现在`function foo()...`声明之前，因为函数声明是在普通变量之前被提升的。\n\n> 后续的函数声明会覆盖前一个\n\n> 普通的块儿作用域里的函数声明一般会被提升至外围的作用域\n\n### 作用域闭包\n\n- 当函数是在当前词法作用域之外执行，如果函数可以记住并访问所在的词法作用域时，就产生了闭包。\n\n- 计时器、事件处理器、Ajax请求、跨窗口消息、web worker、或者任何其他的异步（或同步！）任务，当你传入一个回调函数，你就在它周围悬挂了一些闭包！\n\n```js\nfor (var i=1; i<=5; i++) {\n\t(function(j){\n\t\tsetTimeout( function timer(){\n\t\t\tconsole.log( j );\n\t\t}, j*1000 );\n\t})( i );\n}\n```\n\n模块要求两个关键性质：\n\n1. 必须有一个外部的外围函数，而且它必须至少被调用一次（每次创建一个新的模块实例）。\n\n2. 外围的函数必须至少返回一个内部函数，这样这个内部函数才拥有私有作用域的闭包，并且可以访问和/或修改这个私有状态。\n\n```js\nvar foo = (function CoolModule() {\n\tvar something = \"cool\";\n\tvar another = [1, 2, 3];\n\n\tfunction doSomething() {\n\t\tconsole.log( something );\n\t}\n\n\tfunction doAnother() {\n\t\tconsole.log( another.join( \" ! \" ) );\n\t}\n\n\treturn {\n\t\tdoSomething: doSomething,\n\t\tdoAnother: doAnother\n\t};\n})();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1 ! 2 ! 3\n```\n\n#### 模块化\n\n```js\nvar MyModules = (function Manager() {\n\tvar modules = {};\n\n\tfunction define(name, deps, impl) {\n\t\tfor (var i=0; i<deps.length; i++) {\n\t\t\tdeps[i] = modules[deps[i]];\n\t\t}\n\t\tmodules[name] = impl.apply( impl, deps );\n\t}\n\n\tfunction get(name) {\n\t\treturn modules[name];\n\t}\n\n\treturn {\n\t\tdefine: define,\n\t\tget: get\n\t};\n})();\n```\n\n```js\nMyModules.define( \"bar\", [], function(){\n\tfunction hello(who) {\n\t\treturn \"Let me introduce: \" + who;\n\t}\n\n\treturn {\n\t\thello: hello\n\t};\n} );\n\nMyModules.define( \"foo\", [\"bar\"], function(bar){\n\tvar hungry = \"hippo\";\n\n\tfunction awesome() {\n\t\tconsole.log( bar.hello( hungry ).toUpperCase() );\n\t}\n\n\treturn {\n\t\tawesome: awesome\n\t};\n} );\n\nvar bar = MyModules.get( \"bar\" );\nvar foo = MyModules.get( \"foo\" );\n\nconsole.log(\n\tbar.hello( \"hippo\" )\n); // Let me introduce: hippo\n\nfoo.awesome(); // LET ME INTRODUCE: HIPPO\n```\n\n#### ES6中的模块\n\n- import 在当前的作用域中导入一个模块的 API 的一个或多个成员，每个都绑定到一个变量；\n- module 将整个模块的 API 导入到一个被绑定的变量；\n- export 为当前模块的公有API导出一个标识符（变量，函数）。在一个模块的定义中，这些操作符可以根据需要使用任意多次。\n\n### 附录\n\n#### 动态作用域\n\n- 词法作用域是一组关于引擎如何查询变量和它在何处能够找到变量的规则。词法作用域的关键性质是，它是在代码编写时被定义的。\n- 动态作用域是在运行时被确定的，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。\n- 两者的关键差异是：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是函数在何处被声明，但是动态作用域关心的是函数从何处被调用。\n- JavaScript 没有动态作用域，但是 this 机制有些像动态作用域。\n\n#### 填补块儿作用域\n\nES6 才提出了 let，而早在 ES3 的`try/catch`就已经有了块儿作用域。我们想在前 ES6 环境中使用块儿作用域可以这样：\n\n```js\n// ES6 let\n{\n\tlet a = 2;\n\tconsole.log( a ); // 2\n}\n\nconsole.log( a ); // ReferenceError\n```\n\n转为：\n\n```js\n// ES3 try/catch\ntry{throw 2}catch(a){\n\tconsole.log( a ); // 2\n}\n\nconsole.log( a ); // ReferenceError\n```\n\nTraceur的转移结果：\n\n```js\n{\n\ttry {\n\t\tthrow undefined;\n\t} catch (a) {\n\t\ta = 2;\n\t\tconsole.log( a );\n\t}\n}\n\nconsole.log( a );\n```\n\n","slug":"2018-05-14-你不知道的JS-1","published":1,"updated":"2019-08-08T07:47:20.014Z","comments":0,"photos":[],"link":"post/2018-05-14-你不知道的JS-1","_id":"cjz2epjf3000zn3w53jskhovh","content":"<blockquote>\n<p>尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言。</p>\n</blockquote>\n<h3 id=\"什么是作用域？\">什么是作用域？<a href=\"post/2018-05-14-你不知道的JS-1#什么是作用域？\"></a></h3><p>「编译」\b三步骤：</p>\n<ol>\n<li><p>分词/词法分析： 将一连串字符打断成（对于语言来说）有意义的片段，称为token（记号）。举例来说，考虑这段程序：<code>var a = 2;</code>。这段程序很可能会被打断成如下token：<code>var</code>，<code>a</code>，<code>=</code>，<code>2</code>，和 <code>;</code>。空格也许会被保留为一个 token，这要看它是否是有意义的。</p>\n<blockquote>\n<p>注意： 分词和词法分析之间的区别是微妙和学术上的，其中心在于这些 token 是否以 <em>无状态</em> 或 <em>有状态</em> 的方式被识别。简而言之，如果分词器去调用有状态的解析规则来弄清a是否应当被考虑为一个不同的 token，还是只是其他 token 的一部分，那么这就是 词法分析。</p>\n</blockquote>\n</li>\n<li><p>解析： 将一个 token 的流（数组）转换为一个嵌套元素的树，它总体上表示了程序的语法结构。这棵树称为 “AST”（Abstract Syntax Tree —— 抽象语法树）。</p>\n<blockquote>\n<p><code>var a = 2;</code> 的树也许开始于称为 VariableDeclaration（变量声明）顶层节点，带有一个称为 Identifier（标识符）的子节点（它的值为a），和另一个称为 AssignmentExpression（赋值表达式）的子节点，而这个子节点本身带有一个称为 NumericLiteral（数字字面量）的子节点（它的值为2）。</p>\n</blockquote>\n</li>\n<li><p>代码生成： 这个处理将 AST 转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。</p>\n</li>\n</ol>\n<blockquote>\n<p>对于一个变量赋值，发生了两个不同的动作：第一，<code>编译器</code>声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，<code>引擎</code>在<code>作用域</code>中查询这个变量并给它赋值，如果找到的话。</p>\n</blockquote>\n<h4 id=\"LHS查询和RHS查询\">LHS查询和RHS查询<a href=\"post/2018-05-14-你不知道的JS-1#LHS查询和RHS查询\"></a></h4><p>当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。</p>\n<blockquote>\n<p>“赋值的目标（LHS）” &amp; “赋值的源（RHS）”</p>\n</blockquote>\n<blockquote>\n<p>将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的</p>\n</blockquote>\n<p><strong>LHS查询</strong></p>\n<ul>\n<li>对变量进行赋值，就会使用 LHS 查询；</li>\n<li><code>=</code>号操作符或调用函数时传入参数的操作都会导致关联作用域的赋值查询（LHS）；</li>\n<li>不成功的 LHS 引用，非严格模式下会导致自动隐式创建一个全局变量，严格模式下或者抛出 ReferenceError 异常。</li>\n</ul>\n<p><strong>RHS查询</strong></p>\n<ul>\n<li>如果是获取变量的值，就会使用RHS查询；</li>\n<li>不成功的 RHS 引用会导致抛出 ReferenceError异常。（即RHS查询在所有嵌套作用域到没找到所需变量）；</li>\n<li>如果 RHS 查询到了一个变量，但是你尝试对这个变量进行不合理操作，比如对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，引擎就会抛出 TypeError 异常。</li>\n</ul>\n<h3 id=\"词法作用域\">词法作用域<a href=\"post/2018-05-14-你不知道的JS-1#词法作用域\"></a></h3><blockquote>\n<p>词法作用域是 JavaScript 所采用的作用域模型</p>\n</blockquote>\n<p>在 JavaScript 中有两种机制可以“欺骗”词法作用域： <code>eval(..)</code> 和 <code>with</code> 。</p>\n<ul>\n<li>JavaScript 中的<code>eval(..)</code>函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。因此它会欺骗词法作用域。</li>\n</ul>\n<blockquote>\n<p>当<code>eval(..)</code>被用于一个操作它自己的词法作用域的 strict 模式程序时，在<code>eval(..)</code>内部做出的声明不会实际上修改包围它的作用域。</p>\n</blockquote>\n<blockquote>\n<p>在 JavaScript 中还有其他的工具拥有与<code>eval(..)</code>非常类似的效果。<code>setTimeout(..)</code>和<code>setInterval(..)</code>可以为它们各自的第一个参数值接收一个字符串，其内容将会被<code>eval</code>为一个动态生成的函数的代码。<code>new Function(..)</code>函数构造器类似地为它的最后一个参数值接收一个代码字符串，来把它转换为一个动态生成的函数（前面的参数值，如果有的话，将作为新函数的形式参数）。</p>\n</blockquote>\n<ul>\n<li>with 的常见方式是作为一种缩写，来引用一个对象的多个属性，而不必每次都重复对象引用本身。</li>\n</ul>\n<blockquote>\n<p>尽管一个<code>with</code>块儿将一个对象视为一个词法作用域，但是在<code>with</code>块儿内部的一个普通<code>var</code>声明将不会归于这个<code>with</code>块儿的作用域，而是归于包含它的函数作用域。<br>如果<code>eval(..)</code>函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而<code>with</code>语句实际上是从你传递给它的对象中凭空制造了一个全新的词法作用域。</p>\n</blockquote>\n<blockquote>\n<p>strict 模式下<code>with</code>不允许使用</p>\n</blockquote>\n<p>这些机制的缺点是，它压制了<em>引擎</em>在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是不合法的。这两种特性的结果就是代码将会运行的更慢。不要使用它们。</p>\n<h3 id=\"函数与块儿作用域\">函数与块儿作用域<a href=\"post/2018-05-14-你不知道的JS-1#函数与块儿作用域\"></a></h3><p>在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。</p>\n<p>从ES3开始，<code>try/catch</code>结构在<code>catch</code>子句上拥有块儿作用域。</p>\n<p>在ES6中，引入了<code>let</code>关键字（var 关键字的表兄弟）允许在任意代码块中声明变量。使用<code>let</code>做出的声明将不会在它们所出现的整个块儿的作用域中提升。</p>\n<p><strong>函数声明</strong> <strong>函数表达式</strong></p>\n<h4 id=\"IIFE-立即被调用函数表达\">IIFE(立即被调用函数表达)<a href=\"post/2018-05-14-你不知道的JS-1#IIFE-立即被调用函数表达\"></a></h4><p>Immediately Invoked Function Expression</p>\n<p><code>(function foo(){ .. })()</code>第一个外围的<code>()</code>使这个函数变成表达式，而第二个<code>()</code>执行这个函数。</p>\n<h3 id=\"提升\">提升<a href=\"post/2018-05-14-你不知道的JS-1#提升\"></a></h3><p>JavaScript 引擎会\b将<code>var a = 2</code>看作<code>var a</code>和<code>a = 2</code>两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。</p>\n<p>这将导致在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前 首先 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们 <strong>各自</strong> 的作用域顶部（不是程序的顶端），这就是我们所说的“提升”。</p>\n<blockquote>\n<p>只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在原处。提升是以作用域为单位的。</p>\n</blockquote>\n<blockquote>\n<p><strong>函数声明会被提升，但是函数表达式不会。</strong></p>\n</blockquote>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">bar(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<p>这个代码段可以（使用提升）更准确地解释为：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">bar(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = ...self...</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"函数会首先被提升，然后才是变量。\">函数会首先被提升，然后才是变量。<a href=\"post/2018-05-14-你不知道的JS-1#函数会首先被提升，然后才是变量。\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<p>1 被打印了，而不是 2，这个代码段被引擎解释执行为：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<p><code>var foo</code>是一个重复（因此被无视）的声明，即便它出现在<code>function foo()...</code>声明之前，因为函数声明是在普通变量之前被提升的。</p>\n<blockquote>\n<p>后续的函数声明会覆盖前一个</p>\n</blockquote>\n<blockquote>\n<p>普通的块儿作用域里的函数声明一般会被提升至外围的作用域</p>\n</blockquote>\n<h3 id=\"作用域闭包\">作用域闭包<a href=\"post/2018-05-14-你不知道的JS-1#作用域闭包\"></a></h3><ul>\n<li><p>当函数是在当前词法作用域之外执行，如果函数可以记住并访问所在的词法作用域时，就产生了闭包。</p>\n</li>\n<li><p>计时器、事件处理器、Ajax请求、跨窗口消息、web worker、或者任何其他的异步（或同步！）任务，当你传入一个回调函数，你就在它周围悬挂了一些闭包！</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>)</span>&#123;</span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">\t\t&#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">\t&#125;)( i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>模块要求两个关键性质：</p>\n<ol>\n<li><p>必须有一个外部的外围函数，而且它必须至少被调用一次（每次创建一个新的模块实例）。</p>\n</li>\n<li><p>外围的函数必须至少返回一个内部函数，这样这个内部函数才拥有私有作用域的闭包，并且可以访问和/或修改这个私有状态。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CoolModule</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> something = <span class=\"string\">\"cool\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( something );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAnother</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( another.join( <span class=\"string\">\" ! \"</span> ) );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tdoSomething: doSomething,</span><br><span class=\"line\">\t\tdoAnother: doAnother</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">foo.doSomething(); <span class=\"comment\">// cool</span></span><br><span class=\"line\">foo.doAnother(); <span class=\"comment\">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></div></figure>\n<h4 id=\"模块化\">模块化<a href=\"post/2018-05-14-你不知道的JS-1#模块化\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyModules = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Manager</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> modules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">define</span>(<span class=\"params\">name, deps, impl</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class=\"line\">\t\t\tdeps[i] = modules[deps[i]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmodules[name] = impl.apply( impl, deps );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> modules[name];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tdefine: define,</span><br><span class=\"line\">\t\tget: get</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyModules.define( <span class=\"string\">\"bar\"</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">who</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Let me introduce: \"</span> + who;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\thello: hello</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">MyModules.define( <span class=\"string\">\"foo\"</span>, [<span class=\"string\">\"bar\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bar</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> hungry = <span class=\"string\">\"hippo\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awesome</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tawesome: awesome</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = MyModules.get( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = MyModules.get( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">\tbar.hello( <span class=\"string\">\"hippo\"</span> )</span><br><span class=\"line\">); <span class=\"comment\">// Let me introduce: hippo</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.awesome(); <span class=\"comment\">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></div></figure>\n<h4 id=\"ES6中的模块\">ES6中的模块<a href=\"post/2018-05-14-你不知道的JS-1#ES6中的模块\"></a></h4><ul>\n<li>import 在当前的作用域中导入一个模块的 API 的一个或多个成员，每个都绑定到一个变量；</li>\n<li>module 将整个模块的 API 导入到一个被绑定的变量；</li>\n<li>export 为当前模块的公有API导出一个标识符（变量，函数）。在一个模块的定义中，这些操作符可以根据需要使用任意多次。</li>\n</ul>\n<h3 id=\"附录\">附录<a href=\"post/2018-05-14-你不知道的JS-1#附录\"></a></h3><h4 id=\"动态作用域\">动态作用域<a href=\"post/2018-05-14-你不知道的JS-1#动态作用域\"></a></h4><ul>\n<li>词法作用域是一组关于引擎如何查询变量和它在何处能够找到变量的规则。词法作用域的关键性质是，它是在代码编写时被定义的。</li>\n<li>动态作用域是在运行时被确定的，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。</li>\n<li>两者的关键差异是：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是函数在何处被声明，但是动态作用域关心的是函数从何处被调用。</li>\n<li>JavaScript 没有动态作用域，但是 this 机制有些像动态作用域。</li>\n</ul>\n<h4 id=\"填补块儿作用域\">填补块儿作用域<a href=\"post/2018-05-14-你不知道的JS-1#填补块儿作用域\"></a></h4><p>ES6 才提出了 let，而早在 ES3 的<code>try/catch</code>就已经有了块儿作用域。我们想在前 ES6 环境中使用块儿作用域可以这样：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 let</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></div></figure>\n<p>转为：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES3 try/catch</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;<span class=\"keyword\">throw</span> <span class=\"number\">2</span>&#125;<span class=\"keyword\">catch</span>(a)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></div></figure>\n<p>Traceur的转移结果：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (a) &#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br></pre></td></tr></table></div></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言。</p>\n</blockquote>\n<h3 id=\"什么是作用域？\"><a href=\"#什么是作用域？\" class=\"headerlink\" title=\"什么是作用域？\"></a>什么是作用域？</h3><p>「编译」\b三步骤：</p>\n<ol>\n<li><p>分词/词法分析： 将一连串字符打断成（对于语言来说）有意义的片段，称为token（记号）。举例来说，考虑这段程序：<code>var a = 2;</code>。这段程序很可能会被打断成如下token：<code>var</code>，<code>a</code>，<code>=</code>，<code>2</code>，和 <code>;</code>。空格也许会被保留为一个 token，这要看它是否是有意义的。</p>\n<blockquote>\n<p>注意： 分词和词法分析之间的区别是微妙和学术上的，其中心在于这些 token 是否以 <em>无状态</em> 或 <em>有状态</em> 的方式被识别。简而言之，如果分词器去调用有状态的解析规则来弄清a是否应当被考虑为一个不同的 token，还是只是其他 token 的一部分，那么这就是 词法分析。</p>\n</blockquote>\n</li>\n<li><p>解析： 将一个 token 的流（数组）转换为一个嵌套元素的树，它总体上表示了程序的语法结构。这棵树称为 “AST”（Abstract Syntax Tree —— 抽象语法树）。</p>\n<blockquote>\n<p><code>var a = 2;</code> 的树也许开始于称为 VariableDeclaration（变量声明）顶层节点，带有一个称为 Identifier（标识符）的子节点（它的值为a），和另一个称为 AssignmentExpression（赋值表达式）的子节点，而这个子节点本身带有一个称为 NumericLiteral（数字字面量）的子节点（它的值为2）。</p>\n</blockquote>\n</li>\n<li><p>代码生成： 这个处理将 AST 转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。</p>\n</li>\n</ol>\n<blockquote>\n<p>对于一个变量赋值，发生了两个不同的动作：第一，<code>编译器</code>声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，<code>引擎</code>在<code>作用域</code>中查询这个变量并给它赋值，如果找到的话。</p>\n</blockquote>\n<h4 id=\"LHS查询和RHS查询\"><a href=\"#LHS查询和RHS查询\" class=\"headerlink\" title=\"LHS查询和RHS查询\"></a>LHS查询和RHS查询</h4><p>当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。</p>\n<blockquote>\n<p>“赋值的目标（LHS）” &amp; “赋值的源（RHS）”</p>\n</blockquote>\n<blockquote>\n<p>将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的</p>\n</blockquote>\n<p><strong>LHS查询</strong></p>\n<ul>\n<li>对变量进行赋值，就会使用 LHS 查询；</li>\n<li><code>=</code>号操作符或调用函数时传入参数的操作都会导致关联作用域的赋值查询（LHS）；</li>\n<li>不成功的 LHS 引用，非严格模式下会导致自动隐式创建一个全局变量，严格模式下或者抛出 ReferenceError 异常。</li>\n</ul>\n<p><strong>RHS查询</strong></p>\n<ul>\n<li>如果是获取变量的值，就会使用RHS查询；</li>\n<li>不成功的 RHS 引用会导致抛出 ReferenceError异常。（即RHS查询在所有嵌套作用域到没找到所需变量）；</li>\n<li>如果 RHS 查询到了一个变量，但是你尝试对这个变量进行不合理操作，比如对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，引擎就会抛出 TypeError 异常。</li>\n</ul>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><blockquote>\n<p>词法作用域是 JavaScript 所采用的作用域模型</p>\n</blockquote>\n<p>在 JavaScript 中有两种机制可以“欺骗”词法作用域： <code>eval(..)</code> 和 <code>with</code> 。</p>\n<ul>\n<li>JavaScript 中的<code>eval(..)</code>函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。因此它会欺骗词法作用域。</li>\n</ul>\n<blockquote>\n<p>当<code>eval(..)</code>被用于一个操作它自己的词法作用域的 strict 模式程序时，在<code>eval(..)</code>内部做出的声明不会实际上修改包围它的作用域。</p>\n</blockquote>\n<blockquote>\n<p>在 JavaScript 中还有其他的工具拥有与<code>eval(..)</code>非常类似的效果。<code>setTimeout(..)</code>和<code>setInterval(..)</code>可以为它们各自的第一个参数值接收一个字符串，其内容将会被<code>eval</code>为一个动态生成的函数的代码。<code>new Function(..)</code>函数构造器类似地为它的最后一个参数值接收一个代码字符串，来把它转换为一个动态生成的函数（前面的参数值，如果有的话，将作为新函数的形式参数）。</p>\n</blockquote>\n<ul>\n<li>with 的常见方式是作为一种缩写，来引用一个对象的多个属性，而不必每次都重复对象引用本身。</li>\n</ul>\n<blockquote>\n<p>尽管一个<code>with</code>块儿将一个对象视为一个词法作用域，但是在<code>with</code>块儿内部的一个普通<code>var</code>声明将不会归于这个<code>with</code>块儿的作用域，而是归于包含它的函数作用域。<br>如果<code>eval(..)</code>函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而<code>with</code>语句实际上是从你传递给它的对象中凭空制造了一个全新的词法作用域。</p>\n</blockquote>\n<blockquote>\n<p>strict 模式下<code>with</code>不允许使用</p>\n</blockquote>\n<p>这些机制的缺点是，它压制了<em>引擎</em>在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是不合法的。这两种特性的结果就是代码将会运行的更慢。不要使用它们。</p>\n<h3 id=\"函数与块儿作用域\"><a href=\"#函数与块儿作用域\" class=\"headerlink\" title=\"函数与块儿作用域\"></a>函数与块儿作用域</h3><p>在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。</p>\n<p>从ES3开始，<code>try/catch</code>结构在<code>catch</code>子句上拥有块儿作用域。</p>\n<p>在ES6中，引入了<code>let</code>关键字（var 关键字的表兄弟）允许在任意代码块中声明变量。使用<code>let</code>做出的声明将不会在它们所出现的整个块儿的作用域中提升。</p>\n<p><strong>函数声明</strong> <strong>函数表达式</strong></p>\n<h4 id=\"IIFE-立即被调用函数表达\"><a href=\"#IIFE-立即被调用函数表达\" class=\"headerlink\" title=\"IIFE(立即被调用函数表达)\"></a>IIFE(立即被调用函数表达)</h4><p>Immediately Invoked Function Expression</p>\n<p><code>(function foo(){ .. })()</code>第一个外围的<code>()</code>使这个函数变成表达式，而第二个<code>()</code>执行这个函数。</p>\n<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><p>JavaScript 引擎会\b将<code>var a = 2</code>看作<code>var a</code>和<code>a = 2</code>两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。</p>\n<p>这将导致在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前 首先 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们 <strong>各自</strong> 的作用域顶部（不是程序的顶端），这就是我们所说的“提升”。</p>\n<blockquote>\n<p>只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在原处。提升是以作用域为单位的。</p>\n</blockquote>\n<blockquote>\n<p><strong>函数声明会被提升，但是函数表达式不会。</strong></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">bar(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个代码段可以（使用提升）更准确地解释为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">bar(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bar = ...self...</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数会首先被提升，然后才是变量。\"><a href=\"#函数会首先被提升，然后才是变量。\" class=\"headerlink\" title=\"函数会首先被提升，然后才是变量。\"></a>函数会首先被提升，然后才是变量。</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>1 被打印了，而不是 2，这个代码段被引擎解释执行为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>var foo</code>是一个重复（因此被无视）的声明，即便它出现在<code>function foo()...</code>声明之前，因为函数声明是在普通变量之前被提升的。</p>\n<blockquote>\n<p>后续的函数声明会覆盖前一个</p>\n</blockquote>\n<blockquote>\n<p>普通的块儿作用域里的函数声明一般会被提升至外围的作用域</p>\n</blockquote>\n<h3 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h3><ul>\n<li><p>当函数是在当前词法作用域之外执行，如果函数可以记住并访问所在的词法作用域时，就产生了闭包。</p>\n</li>\n<li><p>计时器、事件处理器、Ajax请求、跨窗口消息、web worker、或者任何其他的异步（或同步！）任务，当你传入一个回调函数，你就在它周围悬挂了一些闭包！</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>)</span>&#123;</span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">\t\t&#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">\t&#125;)( i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模块要求两个关键性质：</p>\n<ol>\n<li><p>必须有一个外部的外围函数，而且它必须至少被调用一次（每次创建一个新的模块实例）。</p>\n</li>\n<li><p>外围的函数必须至少返回一个内部函数，这样这个内部函数才拥有私有作用域的闭包，并且可以访问和/或修改这个私有状态。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CoolModule</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> something = <span class=\"string\">\"cool\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( something );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAnother</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( another.join( <span class=\"string\">\" ! \"</span> ) );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tdoSomething: doSomething,</span><br><span class=\"line\">\t\tdoAnother: doAnother</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">foo.doSomething(); <span class=\"comment\">// cool</span></span><br><span class=\"line\">foo.doAnother(); <span class=\"comment\">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyModules = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Manager</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> modules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">define</span>(<span class=\"params\">name, deps, impl</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class=\"line\">\t\t\tdeps[i] = modules[deps[i]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmodules[name] = impl.apply( impl, deps );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> modules[name];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tdefine: define,</span><br><span class=\"line\">\t\tget: get</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyModules.define( <span class=\"string\">\"bar\"</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">who</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Let me introduce: \"</span> + who;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\thello: hello</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">MyModules.define( <span class=\"string\">\"foo\"</span>, [<span class=\"string\">\"bar\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bar</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> hungry = <span class=\"string\">\"hippo\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awesome</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tawesome: awesome</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = MyModules.get( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = MyModules.get( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">\tbar.hello( <span class=\"string\">\"hippo\"</span> )</span><br><span class=\"line\">); <span class=\"comment\">// Let me introduce: hippo</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.awesome(); <span class=\"comment\">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"ES6中的模块\"><a href=\"#ES6中的模块\" class=\"headerlink\" title=\"ES6中的模块\"></a>ES6中的模块</h4><ul>\n<li>import 在当前的作用域中导入一个模块的 API 的一个或多个成员，每个都绑定到一个变量；</li>\n<li>module 将整个模块的 API 导入到一个被绑定的变量；</li>\n<li>export 为当前模块的公有API导出一个标识符（变量，函数）。在一个模块的定义中，这些操作符可以根据需要使用任意多次。</li>\n</ul>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><h4 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h4><ul>\n<li>词法作用域是一组关于引擎如何查询变量和它在何处能够找到变量的规则。词法作用域的关键性质是，它是在代码编写时被定义的。</li>\n<li>动态作用域是在运行时被确定的，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。</li>\n<li>两者的关键差异是：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是函数在何处被声明，但是动态作用域关心的是函数从何处被调用。</li>\n<li>JavaScript 没有动态作用域，但是 this 机制有些像动态作用域。</li>\n</ul>\n<h4 id=\"填补块儿作用域\"><a href=\"#填补块儿作用域\" class=\"headerlink\" title=\"填补块儿作用域\"></a>填补块儿作用域</h4><p>ES6 才提出了 let，而早在 ES3 的<code>try/catch</code>就已经有了块儿作用域。我们想在前 ES6 环境中使用块儿作用域可以这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 let</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>转为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES3 try/catch</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;<span class=\"keyword\">throw</span> <span class=\"number\">2</span>&#125;<span class=\"keyword\">catch</span>(a)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>Traceur的转移结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (a) &#123;</span><br><span class=\"line\">\t\ta = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br></pre></td></tr></table></figure>\n","plink":"https://vincentdou.github.io/blog/post/2018-05-14-你不知道的JS-1/","type":"post"},{"layout":"post","title":"你不知道的JS-this与对象原型-对象","date":"2018-06-02T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n### 对象\n\n#### 关于「JavaScript中的一切都是对象」\n\n应该说，这种说法是错误的。JavaScript 中有 string、number、boolean、symbol、null、和 undefined 6 种基础类型，它们本身并不是对象，只是在执行方法时会被暂时的转化为对应的对象类型。\n\nJavaScript 中有一些内置对象：tring、Number、Boolean、Object、Function、Array、Date、RegExp、Error。或者说，这些是内置函数，可以当作构造函数来使用。\n\n函数是对象的一种子类型（技术上讲，叫做“可调用对象”），函数在 JS 中被称为“一等公民”。\n\n数组也是一种形式的对象，带有特别的行为。数组在内容的组织上要稍稍比一般的对象更加结构化。\n\n#### 计算型属性名\n\nES6 加入了 计算型属性名，在一个字面对象声明的键名称位置，你可以指定一个表达式，用 [ ] 括起来：\n\n```js\nvar prefix = \"foo\";\n\nvar myObject = {\n\t[prefix + \"bar\"]: \"hello\",\n\t[prefix + \"baz\"]: \"world\"\n};\n\nmyObject[\"foobar\"]; // hello\nmyObject[\"foobaz\"]; // world\n```\n\n#### 属性描述符\n\nES5 之后，所有的属性都用**属性描述符（Property Descriptors）**来描述，可以通过`getOwnPropertyDescriptor`来查看：\n\n```js\nvar myObject = {\n\ta: 2\n};\n\nObject.getOwnPropertyDescriptor( myObject, \"a\" );\n// {\n//    value: 2,\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n// }\n```\n\n可以通过`Object.defineProperty()`进行定义：\n\n```js\nvar myObject = {};\n\nObject.defineProperty( myObject, \"a\", {\n\tvalue: 2,\n\twritable: true,\n\tconfigurable: true,\n\tenumerable: true\n} );\n\nmyObject.a; // 2\n```\n\n属性描述符除了 value 还包含三个性质：可写性（writable）、可配置性（configurable）、可枚举性（enumerable）。\n\n- writable 控制着你改变属性值的能力，一个 writable 为 false 的属性无法通过赋值操作进行改变；\n- configurable 控制你通过 defineProperty 修改属性的描述符定义的能力，还有使用 delete 操作符移除既存属性的能力；\n- enumerable 控制着一个属性是否能在特定的对象-属性枚举操作中出现，比如 for..in 循环。设置为 false 将会阻止它出现在这样的枚举中，即使它依然完全是可以访问的，设置为 true 会使它出现。所有普通的用户定义属性都默认是可 enumerable 的。\n\n#### 不可变性\n\nES5 提供了几种不同的微妙方式将属性或对象设置为不可改变：\n\n- 对象常量：通过将 writable:false 与 configurable:false 组合，你可以实质上创建了一个作为对象属性的常量（不能被改变，重定义或删除）；\n- 防止扩展：如果你想防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性，可以调用 `Object.preventExtensions(..)`；\n- 封印：`Object.seal(..)`创建一个“封印”的对象，这意味着它实质上在当前的对象上调用`Object.preventExtensions(..)`，同时也将它所有的既存属性标记为 configurable:false；\n- 冻结：`Object.freeze(..)`创建一个冻结的对象，这意味着它实质上在当前的对象上调用`Object.seal(..)`，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。\n\n#### Getters 与 Setters\n\nES5 引入了 getters 和 setters。getter 是实际上调用一个隐藏函数来取得值的属性。setter 是实际上调用一个隐藏函数来设置值的属性。\n\ngetter:\n```js\nvar myObject = {\n\t// 为 `a` 定义一个 getter\n\tget a() {\n\t\treturn 2;\n\t}\n};\n\nObject.defineProperty(\n\tmyObject,\t// 目标对象\n\t\"b\",\t\t// 属性名\n\t{\t\t\t// 描述符\n\t\t// 为 `b` 定义 getter\n\t\tget: function(){ return this.a * 2 },\n\n\t\t// 确保 `b` 作为对象属性出现\n\t\tenumerable: true\n\t}\n);\n\nmyObject.a; // 2\n\nmyObject.b; // 4\n```\n\nsetter:\n```js\nvar myObject = {\n\t// 为 `a` 定义 getter\n\tget a() {\n\t\treturn this._a_;\n\t},\n\n\t// 为 `a` 定义 setter\n\tset a(val) {\n\t\tthis._a_ = val * 2;\n\t}\n};\n\nmyObject.a = 2;\n\nmyObject.a; // 4\n```\n\n#### 存在性\n\n- `in`操作符会检查属性是否存在于对象中，或者是否存在于`[[Prototype]]`链对象遍历的更高层中。相比之下，`hasOwnProperty(..)`不会查询 `[[Prototype]]`链；\n- 将`for..in`循环实施在数组上可能会给出意外的结果，因为枚举一个数组将不仅包含所有的数字下标，还包含所有的可枚举属性。所以一个好主意是：将`for..in`循环仅用于对象，而为存储在数组中的值使用传统的 for 循环并用数字索引迭代；\n- enumerable: true 的属性不出现在`for..in`循环中，但是可以通过 in 操作符的存在性检查；\n- `propertyIsEnumerable(..)`测试一个给定的属性名是否直接存在于对象上，并且是 enumerable: true；\n- `Object.keys(..)`返回一个所有可枚举属性的数组，而`Object.getOwnPropertyNames(..)`返回一个所有属性的数组，不论能不能枚举。\n\n#### 迭代\n\nfor..in 循环迭代一个对象上（包括它的 [[Prototype]] 链）所有的可迭代属性。想要迭代值，可以通过索引来引用值。\n\nES5 为数组加入了几个迭代帮助方法，包括 forEach(..)、every(..)、和 some(..)。\n\n- `forEach(..)`将会迭代数组中所有的值，并且忽略回调的返回值；\n- `every(..)`会一直迭代到最后，或者当回调返回一个 false；\n- `some(..)`会一直迭代到最后，或者当回调返回一个 true。\n\n#### 关于for..of\n\nES6 加入了一个有用的 for..of 循环语法，用来迭代数组（和对象，如果这个对象有定义的迭代器）：\n\n```js\nvar myArray = [ 1, 2, 3 ];\n\nfor (var v of myArray) {\n\tconsole.log( v );\n}\n// 1\n// 2\n// 3\n```\n\n`for..of`循环要求被迭代的东西提供一个迭代器对象（从一个在语言规范中叫做`@@iterator`的默认内部函数那里得到），每次循环都调用一次这个迭代器对象的`next()`方法，循环迭代的内容就是这些连续的返回值。数组拥有内建的`@@iterator`。\n\n> @@iterator 本身不是迭代器对象，而是一个返回迭代器对象的方法。\n\n普通的对象没有内建的`@@iterator`，可以自己定义：\n\n```js\nvar myObject = {\n\ta: 2,\n\tb: 3\n};\n\nObject.defineProperty( myObject, Symbol.iterator, {\n\tenumerable: false,\n\twritable: false,\n\tconfigurable: true,\n\tvalue: function() {\n\t\tvar o = this;\n\t\tvar idx = 0;\n\t\tvar ks = Object.keys( o );\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: o[ks[idx++]],\n\t\t\t\t\tdone: (idx > ks.length)\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n} );\n\n// 手动迭代 `myObject`\nvar it = myObject[Symbol.iterator]();\nit.next(); // { value:2, done:false }\nit.next(); // { value:3, done:false }\nit.next(); // { value:undefined, done:true }\n\n// 用 `for..of` 迭代 `myObject`\nfor (var v of myObject) {\n\tconsole.log( v );\n}\n// 2\n// 3\n```\n\n### 混合对象「类」\n\n面向类的设计模式：实例化（instantiation）、继承（inheritance）与（相对）多态(relative polymorphism）。\n\n面向对象设计模式的：迭代器（iterator）、观察者（observer）、工厂（factory）、单例（singleton）。\n\nJavaScript 实际上并不拥有类。\n\n### 原型\n\n#### Object.prototype\n\n每个普通的`[[Prototype]]`链的最顶端，是内建的`Object.prototype`。因为 JavaScript 中所有普通对象（内建，而非被宿主环境扩展的）都源自`Object.prototype`对象，这个对象包含各种在整个 JS 中被使用的共通工具，比如`.toString()`、`.valueOf()`、`.hasOwnProperty(..)`和`.isPrototypeOf(..)`。\n\n#### 设置与遮蔽属性\n\n如果属性名`foo`同时存在于`myObject`本身和从`myObject`开始的`[[Prototype]]`链的更高层，这样的情况称为遮蔽。直接存在于`myObject`上的`foo`属性会遮蔽任何出现在链条高层的`foo`属性，因为`myObject.foo`查询总是在寻找链条最底层的`foo`属性。\n\n一个存在于`[[Prototype]]`链的高层的属性，对它的赋值不总是造成遮蔽，因为只读属性的存在会阻止同名属性在`[[Prototype]]`链的低层被创建，这种情况下可以使用`Object.defineProperty(..)`。\n\n`++`操作符会产生隐式遮蔽：\n\n```js\nvar anotherObject = {\n\ta: 2\n};\n\nvar myObject = Object.create( anotherObject );\n\nanotherObject.a; // 2\nmyObject.a; // 2\n\nanotherObject.hasOwnProperty( \"a\" ); // true\nmyObject.hasOwnProperty( \"a\" ); // false\n\nmyObject.a++; // 噢，隐式遮蔽！++ 操作符相当于 myObject.a = myObject.a + 1\n\nanotherObject.a; // 2\nmyObject.a; // 3\n\nmyObject.hasOwnProperty( \"a\" ); // true\n```\n\n#### 构造函数\n\n构造器是在前面用 new 关键字调用的任何函数。函数不是构造器，但是当且仅当 new 被使用时，函数调用是一个「构造器调用」。\n\n#### 关于.constructor\n\n```js\nfunction Foo(name) {\n\tthis.name = name;\n}\n\nFoo.prototype.myName = function() {\n\treturn this.name;\n};\n\nvar a = new Foo( \"a\" );\nvar b = new Foo( \"b\" );\n\na.myName(); // \"a\"\nb.myName(); // \"b\"\n```\n\n`.constructor`只是`.prototype`对象上的一个不可枚举属性，并不意味着「被XX构建」。\n\n在`Foo.prototype`上的`.constructor`属性仅当`Foo`函数被声明时才出现在对象上。\n\n#### 「原型继承」\n\n```js\nfunction Foo(name) {\n\tthis.name = name;\n}\n\nFoo.prototype.myName = function() {\n\treturn this.name;\n};\n\nfunction Bar(name,label) {\n\tFoo.call( this, name );\n\tthis.label = label;\n}\n\n// 这里，我们创建一个新的 `Bar.prototype` 链接链到 `Foo.prototype`\nBar.prototype = Object.create( Foo.prototype );\n\n// 注意！现在 `Bar.prototype.constructor` 不存在了，\n// 如果你有依赖这个属性的习惯的话，它可以被手动“修复”。\n\nBar.prototype.myLabel = function() {\n\treturn this.label;\n};\n\nvar a = new Bar( \"a\", \"obj a\" );\n\na.myName(); // \"a\"\na.myLabel(); // \"obj a\"\n```\n\n上面`Bar.prototype = Object.create(Foo.prototype)`的作用是创建一个新的`Bar.prototype`对象并把它关联到`Foo.prototype`。当`function Bar() { .. }`被声明时，就像其他函数一样，拥有一个链到默认对象的`.prototype`链接。但是 那个对象没有链到我们希望的`Foo.prototype`。所以，我们创建了一个新对象，链到我们希望的地方，并将原来的错误链接的对象扔掉。\n\n关于修改`.prototype`，有这两种常见误解：\n\n```js\n// 不会如你期望的那样工作!\nBar.prototype = Foo.prototype;\n\n// 会如你期望的那样工作\n// 但会带有你可能不想要的副作用 :(\nBar.prototype = new Foo();\n```\n\n`Bar.prototype = Foo.prototype`不会创建新对象让`Bar.prototype`链接。它只是让`Bar.prototype`成为`Foo.prototype`的另一个引用，将`Bar`直接链到`Foo`链着的 同一个对象：`Foo.prototype`。这意味着当你开始赋值时，你修改的不是一个分离的对象而是那个被分享的`Foo.prototype`对象本身，它将影响到所有链接到`Foo.prototype`的对象。\n\n`Bar.prototype = new Foo()`确实创建了一个新的对象，这个新对象也的确链接到了我们希望的`Foo.prototype`。但是，它是用`Foo(..)`“构造器调用”来这样做的，如果这个函数有任何副作用，这些副作用就会在链接时发生。\n\nES6 中增加了`Object.setPrototypeOf(..)`辅助工具来修改既存对象的链接：\n\n```js\n// ES6 以前\n// 扔掉默认既存的 `Bar.prototype`\nBar.prototype = Object.create( Foo.prototype );\n\n// ES6+\n// 修改既存的 `Bar.prototype`\nObject.setPrototypeOf( Bar.prototype, Foo.prototype );\n```\n\n#### 检查「类」关系\n\n**instanceof**\n\n`instanceof`操作符的左侧接收一个普通对象，右侧接收一个函数。`instanceof`回答的问题是：在 a 的整个`[[Prototype]]`链中，是否有指向`Foo.prototype`的对象？\n\n**.isPrototypeOf**\n\n`isPrototypeOf(..)`回答的问题是：在 a 的整个`[[Prototype]]`链中，`Foo.prototype`出现过吗？考察两个对象之间的关系。\n\n```js\n// 简单地：`b` 在 `c` 的 `[[Prototype]]` 链中出现过吗？\nb.isPrototypeOf( c );\n```\n\n**`.__proto__`**\n\n`.__proto__`直到 ES6 才被标准化，`.__proto__`实际上不存在于你考察的对象上。事实上，它和其他的共通工具在一起(`.toString()`，`.isPrototypeOf(..)`等)，存在于内建的`Object.prototype`上。`.__proto__`虽然看起来像一个属性，但实际上将它看做是一个 getter/setter 更合适。\n\n```js\nObject.defineProperty( Object.prototype, \"__proto__\", {\n\tget: function() {\n\t\t// ES5 的 getPrototypeOf(..)\n\t\treturn Object.getPrototypeOf( this );\n\t},\n\tset: function(o) {\n\t\t// ES6 的 setPrototypeOf(..)\n\t\tObject.setPrototypeOf( this, o );\n\t\treturn o;\n\t}\n} );\n```\n\n#### Object.create()\n\n```js\nvar foo = {\n\tsomething: function() {\n\t\tconsole.log( \"Tell me something good...\" );\n\t}\n};\n\nvar bar = Object.create( foo );\n\nbar.something(); // Tell me something good...\n```\n\n`Object.create(..)`创建了一个链接到我们指定的对象（foo）上的新对象（bar），这给了我们`[[Prototype]]`机制的所有力量（委托），而且没有 new 函数作为类和构造器调用产生的所有没必要的复杂性，搞乱`.prototype`和`.constructor`引用，或任何其他的多余的东西。\n\n`Object.create(..)`的第二个参数通过声明每个新属性的 属性描述符指定了要添加在新对象上的属性。\n\n```js\nvar anotherObject = {\n\ta: 2\n};\n\nvar myObject = Object.create( anotherObject, {\n\tb: {\n\t\tenumerable: false,\n\t\twritable: true,\n\t\tconfigurable: false,\n\t\tvalue: 3\n\t},\n\tc: {\n\t\tenumerable: true,\n\t\twritable: false,\n\t\tconfigurable: false,\n\t\tvalue: 4\n\t}\n} );\n\nmyObject.hasOwnProperty( \"a\" ); // false\nmyObject.hasOwnProperty( \"b\" ); // true\nmyObject.hasOwnProperty( \"c\" ); // true\n\nmyObject.a; // 2\nmyObject.b; // 3\nmyObject.c; // 4\n```\n\n`Object.create(..)`在 ES5 中被加入。对于 ES5 之前的环境，我们需要一个对`Object.create(..)`部分 polyfill 工具：\n\n```js\nif (!Object.create) {\n\tObject.create = function(o) {\n\t\tfunction F(){}\n\t\tF.prototype = o;\n\t\treturn new F();\n\t};\n}\n```\n","source":"_posts/2018-06-03-你不知道的JS-3.markdown","raw":"---\nlayout:     post\ntitle:      \"你不知道的JS-this与对象原型-对象\"\ndate:       2018-06-03\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - 你不知道的JS\n---\n\n### 对象\n\n#### 关于「JavaScript中的一切都是对象」\n\n应该说，这种说法是错误的。JavaScript 中有 string、number、boolean、symbol、null、和 undefined 6 种基础类型，它们本身并不是对象，只是在执行方法时会被暂时的转化为对应的对象类型。\n\nJavaScript 中有一些内置对象：tring、Number、Boolean、Object、Function、Array、Date、RegExp、Error。或者说，这些是内置函数，可以当作构造函数来使用。\n\n函数是对象的一种子类型（技术上讲，叫做“可调用对象”），函数在 JS 中被称为“一等公民”。\n\n数组也是一种形式的对象，带有特别的行为。数组在内容的组织上要稍稍比一般的对象更加结构化。\n\n#### 计算型属性名\n\nES6 加入了 计算型属性名，在一个字面对象声明的键名称位置，你可以指定一个表达式，用 [ ] 括起来：\n\n```js\nvar prefix = \"foo\";\n\nvar myObject = {\n\t[prefix + \"bar\"]: \"hello\",\n\t[prefix + \"baz\"]: \"world\"\n};\n\nmyObject[\"foobar\"]; // hello\nmyObject[\"foobaz\"]; // world\n```\n\n#### 属性描述符\n\nES5 之后，所有的属性都用**属性描述符（Property Descriptors）**来描述，可以通过`getOwnPropertyDescriptor`来查看：\n\n```js\nvar myObject = {\n\ta: 2\n};\n\nObject.getOwnPropertyDescriptor( myObject, \"a\" );\n// {\n//    value: 2,\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n// }\n```\n\n可以通过`Object.defineProperty()`进行定义：\n\n```js\nvar myObject = {};\n\nObject.defineProperty( myObject, \"a\", {\n\tvalue: 2,\n\twritable: true,\n\tconfigurable: true,\n\tenumerable: true\n} );\n\nmyObject.a; // 2\n```\n\n属性描述符除了 value 还包含三个性质：可写性（writable）、可配置性（configurable）、可枚举性（enumerable）。\n\n- writable 控制着你改变属性值的能力，一个 writable 为 false 的属性无法通过赋值操作进行改变；\n- configurable 控制你通过 defineProperty 修改属性的描述符定义的能力，还有使用 delete 操作符移除既存属性的能力；\n- enumerable 控制着一个属性是否能在特定的对象-属性枚举操作中出现，比如 for..in 循环。设置为 false 将会阻止它出现在这样的枚举中，即使它依然完全是可以访问的，设置为 true 会使它出现。所有普通的用户定义属性都默认是可 enumerable 的。\n\n#### 不可变性\n\nES5 提供了几种不同的微妙方式将属性或对象设置为不可改变：\n\n- 对象常量：通过将 writable:false 与 configurable:false 组合，你可以实质上创建了一个作为对象属性的常量（不能被改变，重定义或删除）；\n- 防止扩展：如果你想防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性，可以调用 `Object.preventExtensions(..)`；\n- 封印：`Object.seal(..)`创建一个“封印”的对象，这意味着它实质上在当前的对象上调用`Object.preventExtensions(..)`，同时也将它所有的既存属性标记为 configurable:false；\n- 冻结：`Object.freeze(..)`创建一个冻结的对象，这意味着它实质上在当前的对象上调用`Object.seal(..)`，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。\n\n#### Getters 与 Setters\n\nES5 引入了 getters 和 setters。getter 是实际上调用一个隐藏函数来取得值的属性。setter 是实际上调用一个隐藏函数来设置值的属性。\n\ngetter:\n```js\nvar myObject = {\n\t// 为 `a` 定义一个 getter\n\tget a() {\n\t\treturn 2;\n\t}\n};\n\nObject.defineProperty(\n\tmyObject,\t// 目标对象\n\t\"b\",\t\t// 属性名\n\t{\t\t\t// 描述符\n\t\t// 为 `b` 定义 getter\n\t\tget: function(){ return this.a * 2 },\n\n\t\t// 确保 `b` 作为对象属性出现\n\t\tenumerable: true\n\t}\n);\n\nmyObject.a; // 2\n\nmyObject.b; // 4\n```\n\nsetter:\n```js\nvar myObject = {\n\t// 为 `a` 定义 getter\n\tget a() {\n\t\treturn this._a_;\n\t},\n\n\t// 为 `a` 定义 setter\n\tset a(val) {\n\t\tthis._a_ = val * 2;\n\t}\n};\n\nmyObject.a = 2;\n\nmyObject.a; // 4\n```\n\n#### 存在性\n\n- `in`操作符会检查属性是否存在于对象中，或者是否存在于`[[Prototype]]`链对象遍历的更高层中。相比之下，`hasOwnProperty(..)`不会查询 `[[Prototype]]`链；\n- 将`for..in`循环实施在数组上可能会给出意外的结果，因为枚举一个数组将不仅包含所有的数字下标，还包含所有的可枚举属性。所以一个好主意是：将`for..in`循环仅用于对象，而为存储在数组中的值使用传统的 for 循环并用数字索引迭代；\n- enumerable: true 的属性不出现在`for..in`循环中，但是可以通过 in 操作符的存在性检查；\n- `propertyIsEnumerable(..)`测试一个给定的属性名是否直接存在于对象上，并且是 enumerable: true；\n- `Object.keys(..)`返回一个所有可枚举属性的数组，而`Object.getOwnPropertyNames(..)`返回一个所有属性的数组，不论能不能枚举。\n\n#### 迭代\n\nfor..in 循环迭代一个对象上（包括它的 [[Prototype]] 链）所有的可迭代属性。想要迭代值，可以通过索引来引用值。\n\nES5 为数组加入了几个迭代帮助方法，包括 forEach(..)、every(..)、和 some(..)。\n\n- `forEach(..)`将会迭代数组中所有的值，并且忽略回调的返回值；\n- `every(..)`会一直迭代到最后，或者当回调返回一个 false；\n- `some(..)`会一直迭代到最后，或者当回调返回一个 true。\n\n#### 关于for..of\n\nES6 加入了一个有用的 for..of 循环语法，用来迭代数组（和对象，如果这个对象有定义的迭代器）：\n\n```js\nvar myArray = [ 1, 2, 3 ];\n\nfor (var v of myArray) {\n\tconsole.log( v );\n}\n// 1\n// 2\n// 3\n```\n\n`for..of`循环要求被迭代的东西提供一个迭代器对象（从一个在语言规范中叫做`@@iterator`的默认内部函数那里得到），每次循环都调用一次这个迭代器对象的`next()`方法，循环迭代的内容就是这些连续的返回值。数组拥有内建的`@@iterator`。\n\n> @@iterator 本身不是迭代器对象，而是一个返回迭代器对象的方法。\n\n普通的对象没有内建的`@@iterator`，可以自己定义：\n\n```js\nvar myObject = {\n\ta: 2,\n\tb: 3\n};\n\nObject.defineProperty( myObject, Symbol.iterator, {\n\tenumerable: false,\n\twritable: false,\n\tconfigurable: true,\n\tvalue: function() {\n\t\tvar o = this;\n\t\tvar idx = 0;\n\t\tvar ks = Object.keys( o );\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: o[ks[idx++]],\n\t\t\t\t\tdone: (idx > ks.length)\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n} );\n\n// 手动迭代 `myObject`\nvar it = myObject[Symbol.iterator]();\nit.next(); // { value:2, done:false }\nit.next(); // { value:3, done:false }\nit.next(); // { value:undefined, done:true }\n\n// 用 `for..of` 迭代 `myObject`\nfor (var v of myObject) {\n\tconsole.log( v );\n}\n// 2\n// 3\n```\n\n### 混合对象「类」\n\n面向类的设计模式：实例化（instantiation）、继承（inheritance）与（相对）多态(relative polymorphism）。\n\n面向对象设计模式的：迭代器（iterator）、观察者（observer）、工厂（factory）、单例（singleton）。\n\nJavaScript 实际上并不拥有类。\n\n### 原型\n\n#### Object.prototype\n\n每个普通的`[[Prototype]]`链的最顶端，是内建的`Object.prototype`。因为 JavaScript 中所有普通对象（内建，而非被宿主环境扩展的）都源自`Object.prototype`对象，这个对象包含各种在整个 JS 中被使用的共通工具，比如`.toString()`、`.valueOf()`、`.hasOwnProperty(..)`和`.isPrototypeOf(..)`。\n\n#### 设置与遮蔽属性\n\n如果属性名`foo`同时存在于`myObject`本身和从`myObject`开始的`[[Prototype]]`链的更高层，这样的情况称为遮蔽。直接存在于`myObject`上的`foo`属性会遮蔽任何出现在链条高层的`foo`属性，因为`myObject.foo`查询总是在寻找链条最底层的`foo`属性。\n\n一个存在于`[[Prototype]]`链的高层的属性，对它的赋值不总是造成遮蔽，因为只读属性的存在会阻止同名属性在`[[Prototype]]`链的低层被创建，这种情况下可以使用`Object.defineProperty(..)`。\n\n`++`操作符会产生隐式遮蔽：\n\n```js\nvar anotherObject = {\n\ta: 2\n};\n\nvar myObject = Object.create( anotherObject );\n\nanotherObject.a; // 2\nmyObject.a; // 2\n\nanotherObject.hasOwnProperty( \"a\" ); // true\nmyObject.hasOwnProperty( \"a\" ); // false\n\nmyObject.a++; // 噢，隐式遮蔽！++ 操作符相当于 myObject.a = myObject.a + 1\n\nanotherObject.a; // 2\nmyObject.a; // 3\n\nmyObject.hasOwnProperty( \"a\" ); // true\n```\n\n#### 构造函数\n\n构造器是在前面用 new 关键字调用的任何函数。函数不是构造器，但是当且仅当 new 被使用时，函数调用是一个「构造器调用」。\n\n#### 关于.constructor\n\n```js\nfunction Foo(name) {\n\tthis.name = name;\n}\n\nFoo.prototype.myName = function() {\n\treturn this.name;\n};\n\nvar a = new Foo( \"a\" );\nvar b = new Foo( \"b\" );\n\na.myName(); // \"a\"\nb.myName(); // \"b\"\n```\n\n`.constructor`只是`.prototype`对象上的一个不可枚举属性，并不意味着「被XX构建」。\n\n在`Foo.prototype`上的`.constructor`属性仅当`Foo`函数被声明时才出现在对象上。\n\n#### 「原型继承」\n\n```js\nfunction Foo(name) {\n\tthis.name = name;\n}\n\nFoo.prototype.myName = function() {\n\treturn this.name;\n};\n\nfunction Bar(name,label) {\n\tFoo.call( this, name );\n\tthis.label = label;\n}\n\n// 这里，我们创建一个新的 `Bar.prototype` 链接链到 `Foo.prototype`\nBar.prototype = Object.create( Foo.prototype );\n\n// 注意！现在 `Bar.prototype.constructor` 不存在了，\n// 如果你有依赖这个属性的习惯的话，它可以被手动“修复”。\n\nBar.prototype.myLabel = function() {\n\treturn this.label;\n};\n\nvar a = new Bar( \"a\", \"obj a\" );\n\na.myName(); // \"a\"\na.myLabel(); // \"obj a\"\n```\n\n上面`Bar.prototype = Object.create(Foo.prototype)`的作用是创建一个新的`Bar.prototype`对象并把它关联到`Foo.prototype`。当`function Bar() { .. }`被声明时，就像其他函数一样，拥有一个链到默认对象的`.prototype`链接。但是 那个对象没有链到我们希望的`Foo.prototype`。所以，我们创建了一个新对象，链到我们希望的地方，并将原来的错误链接的对象扔掉。\n\n关于修改`.prototype`，有这两种常见误解：\n\n```js\n// 不会如你期望的那样工作!\nBar.prototype = Foo.prototype;\n\n// 会如你期望的那样工作\n// 但会带有你可能不想要的副作用 :(\nBar.prototype = new Foo();\n```\n\n`Bar.prototype = Foo.prototype`不会创建新对象让`Bar.prototype`链接。它只是让`Bar.prototype`成为`Foo.prototype`的另一个引用，将`Bar`直接链到`Foo`链着的 同一个对象：`Foo.prototype`。这意味着当你开始赋值时，你修改的不是一个分离的对象而是那个被分享的`Foo.prototype`对象本身，它将影响到所有链接到`Foo.prototype`的对象。\n\n`Bar.prototype = new Foo()`确实创建了一个新的对象，这个新对象也的确链接到了我们希望的`Foo.prototype`。但是，它是用`Foo(..)`“构造器调用”来这样做的，如果这个函数有任何副作用，这些副作用就会在链接时发生。\n\nES6 中增加了`Object.setPrototypeOf(..)`辅助工具来修改既存对象的链接：\n\n```js\n// ES6 以前\n// 扔掉默认既存的 `Bar.prototype`\nBar.prototype = Object.create( Foo.prototype );\n\n// ES6+\n// 修改既存的 `Bar.prototype`\nObject.setPrototypeOf( Bar.prototype, Foo.prototype );\n```\n\n#### 检查「类」关系\n\n**instanceof**\n\n`instanceof`操作符的左侧接收一个普通对象，右侧接收一个函数。`instanceof`回答的问题是：在 a 的整个`[[Prototype]]`链中，是否有指向`Foo.prototype`的对象？\n\n**.isPrototypeOf**\n\n`isPrototypeOf(..)`回答的问题是：在 a 的整个`[[Prototype]]`链中，`Foo.prototype`出现过吗？考察两个对象之间的关系。\n\n```js\n// 简单地：`b` 在 `c` 的 `[[Prototype]]` 链中出现过吗？\nb.isPrototypeOf( c );\n```\n\n**`.__proto__`**\n\n`.__proto__`直到 ES6 才被标准化，`.__proto__`实际上不存在于你考察的对象上。事实上，它和其他的共通工具在一起(`.toString()`，`.isPrototypeOf(..)`等)，存在于内建的`Object.prototype`上。`.__proto__`虽然看起来像一个属性，但实际上将它看做是一个 getter/setter 更合适。\n\n```js\nObject.defineProperty( Object.prototype, \"__proto__\", {\n\tget: function() {\n\t\t// ES5 的 getPrototypeOf(..)\n\t\treturn Object.getPrototypeOf( this );\n\t},\n\tset: function(o) {\n\t\t// ES6 的 setPrototypeOf(..)\n\t\tObject.setPrototypeOf( this, o );\n\t\treturn o;\n\t}\n} );\n```\n\n#### Object.create()\n\n```js\nvar foo = {\n\tsomething: function() {\n\t\tconsole.log( \"Tell me something good...\" );\n\t}\n};\n\nvar bar = Object.create( foo );\n\nbar.something(); // Tell me something good...\n```\n\n`Object.create(..)`创建了一个链接到我们指定的对象（foo）上的新对象（bar），这给了我们`[[Prototype]]`机制的所有力量（委托），而且没有 new 函数作为类和构造器调用产生的所有没必要的复杂性，搞乱`.prototype`和`.constructor`引用，或任何其他的多余的东西。\n\n`Object.create(..)`的第二个参数通过声明每个新属性的 属性描述符指定了要添加在新对象上的属性。\n\n```js\nvar anotherObject = {\n\ta: 2\n};\n\nvar myObject = Object.create( anotherObject, {\n\tb: {\n\t\tenumerable: false,\n\t\twritable: true,\n\t\tconfigurable: false,\n\t\tvalue: 3\n\t},\n\tc: {\n\t\tenumerable: true,\n\t\twritable: false,\n\t\tconfigurable: false,\n\t\tvalue: 4\n\t}\n} );\n\nmyObject.hasOwnProperty( \"a\" ); // false\nmyObject.hasOwnProperty( \"b\" ); // true\nmyObject.hasOwnProperty( \"c\" ); // true\n\nmyObject.a; // 2\nmyObject.b; // 3\nmyObject.c; // 4\n```\n\n`Object.create(..)`在 ES5 中被加入。对于 ES5 之前的环境，我们需要一个对`Object.create(..)`部分 polyfill 工具：\n\n```js\nif (!Object.create) {\n\tObject.create = function(o) {\n\t\tfunction F(){}\n\t\tF.prototype = o;\n\t\treturn new F();\n\t};\n}\n```\n","slug":"2018-06-03-你不知道的JS-3","published":1,"updated":"2019-01-02T08:49:00.266Z","comments":0,"photos":[],"link":"post/2018-06-03-你不知道的JS-3","_id":"cjz2epjf70011n3w5a2f81d0g","content":"<h3 id=\"对象\">对象<a href=\"post/2018-06-03-你不知道的JS-3#对象\"></a></h3><h4 id=\"关于「JavaScript中的一切都是对象」\">关于「JavaScript中的一切都是对象」<a href=\"post/2018-06-03-你不知道的JS-3#关于「JavaScript中的一切都是对象」\"></a></h4><p>应该说，这种说法是错误的。JavaScript 中有 string、number、boolean、symbol、null、和 undefined 6 种基础类型，它们本身并不是对象，只是在执行方法时会被暂时的转化为对应的对象类型。</p>\n<p>JavaScript 中有一些内置对象：tring、Number、Boolean、Object、Function、Array、Date、RegExp、Error。或者说，这些是内置函数，可以当作构造函数来使用。</p>\n<p>函数是对象的一种子类型（技术上讲，叫做“可调用对象”），函数在 JS 中被称为“一等公民”。</p>\n<p>数组也是一种形式的对象，带有特别的行为。数组在内容的组织上要稍稍比一般的对象更加结构化。</p>\n<h4 id=\"计算型属性名\">计算型属性名<a href=\"post/2018-06-03-你不知道的JS-3#计算型属性名\"></a></h4><p>ES6 加入了 计算型属性名，在一个字面对象声明的键名称位置，你可以指定一个表达式，用 [ ] 括起来：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prefix = <span class=\"string\">\"foo\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\t[prefix + <span class=\"string\">\"bar\"</span>]: <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">\t[prefix + <span class=\"string\">\"baz\"</span>]: <span class=\"string\">\"world\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject[<span class=\"string\">\"foobar\"</span>]; <span class=\"comment\">// hello</span></span><br><span class=\"line\">myObject[<span class=\"string\">\"foobaz\"</span>]; <span class=\"comment\">// world</span></span><br></pre></td></tr></table></div></figure>\n<h4 id=\"属性描述符\">属性描述符<a href=\"post/2018-06-03-你不知道的JS-3#属性描述符\"></a></h4><p>ES5 之后，所有的属性都用<strong>属性描述符（Property Descriptors）</strong>来描述，可以通过<code>getOwnPropertyDescriptor</code>来查看：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor( myObject, <span class=\"string\">\"a\"</span> );</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    value: 2,</span></span><br><span class=\"line\"><span class=\"comment\">//    writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    configurable: true</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></div></figure>\n<p>可以通过<code>Object.defineProperty()</code>进行定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"a\"</span>, &#123;</span><br><span class=\"line\">\tvalue: <span class=\"number\">2</span>,</span><br><span class=\"line\">\twritable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tconfigurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tenumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n<p>属性描述符除了 value 还包含三个性质：可写性（writable）、可配置性（configurable）、可枚举性（enumerable）。</p>\n<ul>\n<li>writable 控制着你改变属性值的能力，一个 writable 为 false 的属性无法通过赋值操作进行改变；</li>\n<li>configurable 控制你通过 defineProperty 修改属性的描述符定义的能力，还有使用 delete 操作符移除既存属性的能力；</li>\n<li>enumerable 控制着一个属性是否能在特定的对象-属性枚举操作中出现，比如 for..in 循环。设置为 false 将会阻止它出现在这样的枚举中，即使它依然完全是可以访问的，设置为 true 会使它出现。所有普通的用户定义属性都默认是可 enumerable 的。</li>\n</ul>\n<h4 id=\"不可变性\">不可变性<a href=\"post/2018-06-03-你不知道的JS-3#不可变性\"></a></h4><p>ES5 提供了几种不同的微妙方式将属性或对象设置为不可改变：</p>\n<ul>\n<li>对象常量：通过将 writable:false 与 configurable:false 组合，你可以实质上创建了一个作为对象属性的常量（不能被改变，重定义或删除）；</li>\n<li>防止扩展：如果你想防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性，可以调用 <code>Object.preventExtensions(..)</code>；</li>\n<li>封印：<code>Object.seal(..)</code>创建一个“封印”的对象，这意味着它实质上在当前的对象上调用<code>Object.preventExtensions(..)</code>，同时也将它所有的既存属性标记为 configurable:false；</li>\n<li>冻结：<code>Object.freeze(..)</code>创建一个冻结的对象，这意味着它实质上在当前的对象上调用<code>Object.seal(..)</code>，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。</li>\n</ul>\n<h4 id=\"Getters-与-Setters\">Getters 与 Setters<a href=\"post/2018-06-03-你不知道的JS-3#Getters-与-Setters\"></a></h4><p>ES5 引入了 getters 和 setters。getter 是实际上调用一个隐藏函数来取得值的属性。setter 是实际上调用一个隐藏函数来设置值的属性。</p>\n<p>getter:<br><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 为 `a` 定义一个 getter</span></span><br><span class=\"line\">\tget a() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">\tmyObject,\t<span class=\"comment\">// 目标对象</span></span><br><span class=\"line\">\t<span class=\"string\">\"b\"</span>,\t\t<span class=\"comment\">// 属性名</span></span><br><span class=\"line\">\t&#123;\t\t\t<span class=\"comment\">// 描述符</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 为 `b` 定义 getter</span></span><br><span class=\"line\">\t\tget: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 确保 `b` 作为对象属性出现</span></span><br><span class=\"line\">\t\tenumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></div></figure></p>\n<p>setter:<br><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 为 `a` 定义 getter</span></span><br><span class=\"line\">\tget a() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._a_;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 为 `a` 定义 setter</span></span><br><span class=\"line\">\tset a(val) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._a_ = val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></div></figure></p>\n<h4 id=\"存在性\">存在性<a href=\"post/2018-06-03-你不知道的JS-3#存在性\"></a></h4><ul>\n<li><code>in</code>操作符会检查属性是否存在于对象中，或者是否存在于<code>[[Prototype]]</code>链对象遍历的更高层中。相比之下，<code>hasOwnProperty(..)</code>不会查询 <code>[[Prototype]]</code>链；</li>\n<li>将<code>for..in</code>循环实施在数组上可能会给出意外的结果，因为枚举一个数组将不仅包含所有的数字下标，还包含所有的可枚举属性。所以一个好主意是：将<code>for..in</code>循环仅用于对象，而为存储在数组中的值使用传统的 for 循环并用数字索引迭代；</li>\n<li>enumerable: true 的属性不出现在<code>for..in</code>循环中，但是可以通过 in 操作符的存在性检查；</li>\n<li><code>propertyIsEnumerable(..)</code>测试一个给定的属性名是否直接存在于对象上，并且是 enumerable: true；</li>\n<li><code>Object.keys(..)</code>返回一个所有可枚举属性的数组，而<code>Object.getOwnPropertyNames(..)</code>返回一个所有属性的数组，不论能不能枚举。</li>\n</ul>\n<h4 id=\"迭代\">迭代<a href=\"post/2018-06-03-你不知道的JS-3#迭代\"></a></h4><p>for..in 循环迭代一个对象上（包括它的 [[Prototype]] 链）所有的可迭代属性。想要迭代值，可以通过索引来引用值。</p>\n<p>ES5 为数组加入了几个迭代帮助方法，包括 forEach(..)、every(..)、和 some(..)。</p>\n<ul>\n<li><code>forEach(..)</code>将会迭代数组中所有的值，并且忽略回调的返回值；</li>\n<li><code>every(..)</code>会一直迭代到最后，或者当回调返回一个 false；</li>\n<li><code>some(..)</code>会一直迭代到最后，或者当回调返回一个 true。</li>\n</ul>\n<h4 id=\"关于for-of\">关于for..of<a href=\"post/2018-06-03-你不知道的JS-3#关于for-of\"></a></h4><p>ES6 加入了一个有用的 for..of 循环语法，用来迭代数组（和对象，如果这个对象有定义的迭代器）：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> v <span class=\"keyword\">of</span> myArray) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( v );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></div></figure>\n<p><code>for..of</code>循环要求被迭代的东西提供一个迭代器对象（从一个在语言规范中叫做<code>@@iterator</code>的默认内部函数那里得到），每次循环都调用一次这个迭代器对象的<code>next()</code>方法，循环迭代的内容就是这些连续的返回值。数组拥有内建的<code>@@iterator</code>。</p>\n<blockquote>\n<p>@@iterator 本身不是迭代器对象，而是一个返回迭代器对象的方法。</p>\n</blockquote>\n<p>普通的对象没有内建的<code>@@iterator</code>，可以自己定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span>,</span><br><span class=\"line\">\tb: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"built_in\">Symbol</span>.iterator, &#123;</span><br><span class=\"line\">\tenumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\twritable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\tconfigurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tvalue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> o = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> ks = <span class=\"built_in\">Object</span>.keys( o );</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\tnext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tvalue: o[ks[idx++]],</span><br><span class=\"line\">\t\t\t\t\tdone: (idx &gt; ks.length)</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动迭代 `myObject`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = myObject[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value:2, done:false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value:3, done:false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value:undefined, done:true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `for..of` 迭代 `myObject`</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> v <span class=\"keyword\">of</span> myObject) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( v );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"混合对象「类」\">混合对象「类」<a href=\"post/2018-06-03-你不知道的JS-3#混合对象「类」\"></a></h3><p>面向类的设计模式：实例化（instantiation）、继承（inheritance）与（相对）多态(relative polymorphism）。</p>\n<p>面向对象设计模式的：迭代器（iterator）、观察者（observer）、工厂（factory）、单例（singleton）。</p>\n<p>JavaScript 实际上并不拥有类。</p>\n<h3 id=\"原型\">原型<a href=\"post/2018-06-03-你不知道的JS-3#原型\"></a></h3><h4 id=\"Object-prototype\">Object.prototype<a href=\"post/2018-06-03-你不知道的JS-3#Object-prototype\"></a></h4><p>每个普通的<code>[[Prototype]]</code>链的最顶端，是内建的<code>Object.prototype</code>。因为 JavaScript 中所有普通对象（内建，而非被宿主环境扩展的）都源自<code>Object.prototype</code>对象，这个对象包含各种在整个 JS 中被使用的共通工具，比如<code>.toString()</code>、<code>.valueOf()</code>、<code>.hasOwnProperty(..)</code>和<code>.isPrototypeOf(..)</code>。</p>\n<h4 id=\"设置与遮蔽属性\">设置与遮蔽属性<a href=\"post/2018-06-03-你不知道的JS-3#设置与遮蔽属性\"></a></h4><p>如果属性名<code>foo</code>同时存在于<code>myObject</code>本身和从<code>myObject</code>开始的<code>[[Prototype]]</code>链的更高层，这样的情况称为遮蔽。直接存在于<code>myObject</code>上的<code>foo</code>属性会遮蔽任何出现在链条高层的<code>foo</code>属性，因为<code>myObject.foo</code>查询总是在寻找链条最底层的<code>foo</code>属性。</p>\n<p>一个存在于<code>[[Prototype]]</code>链的高层的属性，对它的赋值不总是造成遮蔽，因为只读属性的存在会阻止同名属性在<code>[[Prototype]]</code>链的低层被创建，这种情况下可以使用<code>Object.defineProperty(..)</code>。</p>\n<p><code>++</code>操作符会产生隐式遮蔽：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a++; <span class=\"comment\">// 噢，隐式遮蔽！++ 操作符相当于 myObject.a = myObject.a + 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></div></figure>\n<h4 id=\"构造函数\">构造函数<a href=\"post/2018-06-03-你不知道的JS-3#构造函数\"></a></h4><p>构造器是在前面用 new 关键字调用的任何函数。函数不是构造器，但是当且仅当 new 被使用时，函数调用是一个「构造器调用」。</p>\n<h4 id=\"关于-constructor\">关于.constructor<a href=\"post/2018-06-03-你不知道的JS-3#关于-constructor\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.myName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Foo( <span class=\"string\">\"a\"</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Foo( <span class=\"string\">\"b\"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">a.myName(); <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">b.myName(); <span class=\"comment\">// \"b\"</span></span><br></pre></td></tr></table></div></figure>\n<p><code>.constructor</code>只是<code>.prototype</code>对象上的一个不可枚举属性，并不意味着「被XX构建」。</p>\n<p>在<code>Foo.prototype</code>上的<code>.constructor</code>属性仅当<code>Foo</code>函数被声明时才出现在对象上。</p>\n<h4 id=\"「原型继承」\">「原型继承」<a href=\"post/2018-06-03-你不知道的JS-3#「原型继承」\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.myName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\">name,label</span>) </span>&#123;</span><br><span class=\"line\">\tFoo.call( <span class=\"keyword\">this</span>, name );</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.label = label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里，我们创建一个新的 `Bar.prototype` 链接链到 `Foo.prototype`</span></span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意！现在 `Bar.prototype.constructor` 不存在了，</span></span><br><span class=\"line\"><span class=\"comment\">// 如果你有依赖这个属性的习惯的话，它可以被手动“修复”。</span></span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype.myLabel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.label;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Bar( <span class=\"string\">\"a\"</span>, <span class=\"string\">\"obj a\"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">a.myName(); <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">a.myLabel(); <span class=\"comment\">// \"obj a\"</span></span><br></pre></td></tr></table></div></figure>\n<p>上面<code>Bar.prototype = Object.create(Foo.prototype)</code>的作用是创建一个新的<code>Bar.prototype</code>对象并把它关联到<code>Foo.prototype</code>。当<code>function Bar() { .. }</code>被声明时，就像其他函数一样，拥有一个链到默认对象的<code>.prototype</code>链接。但是 那个对象没有链到我们希望的<code>Foo.prototype</code>。所以，我们创建了一个新对象，链到我们希望的地方，并将原来的错误链接的对象扔掉。</p>\n<p>关于修改<code>.prototype</code>，有这两种常见误解：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不会如你期望的那样工作!</span></span><br><span class=\"line\">Bar.prototype = Foo.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 会如你期望的那样工作</span></span><br><span class=\"line\"><span class=\"comment\">// 但会带有你可能不想要的副作用 :(</span></span><br><span class=\"line\">Bar.prototype = <span class=\"keyword\">new</span> Foo();</span><br></pre></td></tr></table></div></figure>\n<p><code>Bar.prototype = Foo.prototype</code>不会创建新对象让<code>Bar.prototype</code>链接。它只是让<code>Bar.prototype</code>成为<code>Foo.prototype</code>的另一个引用，将<code>Bar</code>直接链到<code>Foo</code>链着的 同一个对象：<code>Foo.prototype</code>。这意味着当你开始赋值时，你修改的不是一个分离的对象而是那个被分享的<code>Foo.prototype</code>对象本身，它将影响到所有链接到<code>Foo.prototype</code>的对象。</p>\n<p><code>Bar.prototype = new Foo()</code>确实创建了一个新的对象，这个新对象也的确链接到了我们希望的<code>Foo.prototype</code>。但是，它是用<code>Foo(..)</code>“构造器调用”来这样做的，如果这个函数有任何副作用，这些副作用就会在链接时发生。</p>\n<p>ES6 中增加了<code>Object.setPrototypeOf(..)</code>辅助工具来修改既存对象的链接：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 以前</span></span><br><span class=\"line\"><span class=\"comment\">// 扔掉默认既存的 `Bar.prototype`</span></span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6+</span></span><br><span class=\"line\"><span class=\"comment\">// 修改既存的 `Bar.prototype`</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"检查「类」关系\">检查「类」关系<a href=\"post/2018-06-03-你不知道的JS-3#检查「类」关系\"></a></h4><p><strong>instanceof</strong></p>\n<p><code>instanceof</code>操作符的左侧接收一个普通对象，右侧接收一个函数。<code>instanceof</code>回答的问题是：在 a 的整个<code>[[Prototype]]</code>链中，是否有指向<code>Foo.prototype</code>的对象？</p>\n<p><strong>.isPrototypeOf</strong></p>\n<p><code>isPrototypeOf(..)</code>回答的问题是：在 a 的整个<code>[[Prototype]]</code>链中，<code>Foo.prototype</code>出现过吗？考察两个对象之间的关系。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单地：`b` 在 `c` 的 `[[Prototype]]` 链中出现过吗？</span></span><br><span class=\"line\">b.isPrototypeOf( c );</span><br></pre></td></tr></table></div></figure>\n<p><strong><code>.__proto__</code></strong></p>\n<p><code>.__proto__</code>直到 ES6 才被标准化，<code>.__proto__</code>实际上不存在于你考察的对象上。事实上，它和其他的共通工具在一起(<code>.toString()</code>，<code>.isPrototypeOf(..)</code>等)，存在于内建的<code>Object.prototype</code>上。<code>.__proto__</code>虽然看起来像一个属性，但实际上将它看做是一个 getter/setter 更合适。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( <span class=\"built_in\">Object</span>.prototype, <span class=\"string\">\"__proto__\"</span>, &#123;</span><br><span class=\"line\">\tget: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ES5 的 getPrototypeOf(..)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.getPrototypeOf( <span class=\"keyword\">this</span> );</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tset: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ES6 的 setPrototypeOf(..)</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">Object</span>.setPrototypeOf( <span class=\"keyword\">this</span>, o );</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"Object-create\">Object.create()<a href=\"post/2018-06-03-你不知道的JS-3#Object-create\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">\tsomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"Tell me something good...\"</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"built_in\">Object</span>.create( foo );</span><br><span class=\"line\"></span><br><span class=\"line\">bar.something(); <span class=\"comment\">// Tell me something good...</span></span><br></pre></td></tr></table></div></figure>\n<p><code>Object.create(..)</code>创建了一个链接到我们指定的对象（foo）上的新对象（bar），这给了我们<code>[[Prototype]]</code>机制的所有力量（委托），而且没有 new 函数作为类和构造器调用产生的所有没必要的复杂性，搞乱<code>.prototype</code>和<code>.constructor</code>引用，或任何其他的多余的东西。</p>\n<p><code>Object.create(..)</code>的第二个参数通过声明每个新属性的 属性描述符指定了要添加在新对象上的属性。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject, &#123;</span><br><span class=\"line\">\tb: &#123;</span><br><span class=\"line\">\t\tenumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\twritable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tconfigurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tvalue: <span class=\"number\">3</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tc: &#123;</span><br><span class=\"line\">\t\tenumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\twritable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tconfigurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tvalue: <span class=\"number\">4</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"b\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"c\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myObject.c; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></div></figure>\n<p><code>Object.create(..)</code>在 ES5 中被加入。对于 ES5 之前的环境，我们需要一个对<code>Object.create(..)</code>部分 polyfill 工具：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Object</span>.create) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\t\tF.prototype = o;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><h4 id=\"关于「JavaScript中的一切都是对象」\"><a href=\"#关于「JavaScript中的一切都是对象」\" class=\"headerlink\" title=\"关于「JavaScript中的一切都是对象」\"></a>关于「JavaScript中的一切都是对象」</h4><p>应该说，这种说法是错误的。JavaScript 中有 string、number、boolean、symbol、null、和 undefined 6 种基础类型，它们本身并不是对象，只是在执行方法时会被暂时的转化为对应的对象类型。</p>\n<p>JavaScript 中有一些内置对象：tring、Number、Boolean、Object、Function、Array、Date、RegExp、Error。或者说，这些是内置函数，可以当作构造函数来使用。</p>\n<p>函数是对象的一种子类型（技术上讲，叫做“可调用对象”），函数在 JS 中被称为“一等公民”。</p>\n<p>数组也是一种形式的对象，带有特别的行为。数组在内容的组织上要稍稍比一般的对象更加结构化。</p>\n<h4 id=\"计算型属性名\"><a href=\"#计算型属性名\" class=\"headerlink\" title=\"计算型属性名\"></a>计算型属性名</h4><p>ES6 加入了 计算型属性名，在一个字面对象声明的键名称位置，你可以指定一个表达式，用 [ ] 括起来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prefix = <span class=\"string\">\"foo\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\t[prefix + <span class=\"string\">\"bar\"</span>]: <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">\t[prefix + <span class=\"string\">\"baz\"</span>]: <span class=\"string\">\"world\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject[<span class=\"string\">\"foobar\"</span>]; <span class=\"comment\">// hello</span></span><br><span class=\"line\">myObject[<span class=\"string\">\"foobaz\"</span>]; <span class=\"comment\">// world</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h4><p>ES5 之后，所有的属性都用<strong>属性描述符（Property Descriptors）</strong>来描述，可以通过<code>getOwnPropertyDescriptor</code>来查看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor( myObject, <span class=\"string\">\"a\"</span> );</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    value: 2,</span></span><br><span class=\"line\"><span class=\"comment\">//    writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    configurable: true</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>可以通过<code>Object.defineProperty()</code>进行定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"string\">\"a\"</span>, &#123;</span><br><span class=\"line\">\tvalue: <span class=\"number\">2</span>,</span><br><span class=\"line\">\twritable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tconfigurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tenumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>属性描述符除了 value 还包含三个性质：可写性（writable）、可配置性（configurable）、可枚举性（enumerable）。</p>\n<ul>\n<li>writable 控制着你改变属性值的能力，一个 writable 为 false 的属性无法通过赋值操作进行改变；</li>\n<li>configurable 控制你通过 defineProperty 修改属性的描述符定义的能力，还有使用 delete 操作符移除既存属性的能力；</li>\n<li>enumerable 控制着一个属性是否能在特定的对象-属性枚举操作中出现，比如 for..in 循环。设置为 false 将会阻止它出现在这样的枚举中，即使它依然完全是可以访问的，设置为 true 会使它出现。所有普通的用户定义属性都默认是可 enumerable 的。</li>\n</ul>\n<h4 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h4><p>ES5 提供了几种不同的微妙方式将属性或对象设置为不可改变：</p>\n<ul>\n<li>对象常量：通过将 writable:false 与 configurable:false 组合，你可以实质上创建了一个作为对象属性的常量（不能被改变，重定义或删除）；</li>\n<li>防止扩展：如果你想防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性，可以调用 <code>Object.preventExtensions(..)</code>；</li>\n<li>封印：<code>Object.seal(..)</code>创建一个“封印”的对象，这意味着它实质上在当前的对象上调用<code>Object.preventExtensions(..)</code>，同时也将它所有的既存属性标记为 configurable:false；</li>\n<li>冻结：<code>Object.freeze(..)</code>创建一个冻结的对象，这意味着它实质上在当前的对象上调用<code>Object.seal(..)</code>，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。</li>\n</ul>\n<h4 id=\"Getters-与-Setters\"><a href=\"#Getters-与-Setters\" class=\"headerlink\" title=\"Getters 与 Setters\"></a>Getters 与 Setters</h4><p>ES5 引入了 getters 和 setters。getter 是实际上调用一个隐藏函数来取得值的属性。setter 是实际上调用一个隐藏函数来设置值的属性。</p>\n<p>getter:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 为 `a` 定义一个 getter</span></span><br><span class=\"line\">\tget a() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">\tmyObject,\t<span class=\"comment\">// 目标对象</span></span><br><span class=\"line\">\t<span class=\"string\">\"b\"</span>,\t\t<span class=\"comment\">// 属性名</span></span><br><span class=\"line\">\t&#123;\t\t\t<span class=\"comment\">// 描述符</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 为 `b` 定义 getter</span></span><br><span class=\"line\">\t\tget: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 确保 `b` 作为对象属性出现</span></span><br><span class=\"line\">\t\tenumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<p>setter:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 为 `a` 定义 getter</span></span><br><span class=\"line\">\tget a() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._a_;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 为 `a` 定义 setter</span></span><br><span class=\"line\">\tset a(val) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>._a_ = val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"存在性\"><a href=\"#存在性\" class=\"headerlink\" title=\"存在性\"></a>存在性</h4><ul>\n<li><code>in</code>操作符会检查属性是否存在于对象中，或者是否存在于<code>[[Prototype]]</code>链对象遍历的更高层中。相比之下，<code>hasOwnProperty(..)</code>不会查询 <code>[[Prototype]]</code>链；</li>\n<li>将<code>for..in</code>循环实施在数组上可能会给出意外的结果，因为枚举一个数组将不仅包含所有的数字下标，还包含所有的可枚举属性。所以一个好主意是：将<code>for..in</code>循环仅用于对象，而为存储在数组中的值使用传统的 for 循环并用数字索引迭代；</li>\n<li>enumerable: true 的属性不出现在<code>for..in</code>循环中，但是可以通过 in 操作符的存在性检查；</li>\n<li><code>propertyIsEnumerable(..)</code>测试一个给定的属性名是否直接存在于对象上，并且是 enumerable: true；</li>\n<li><code>Object.keys(..)</code>返回一个所有可枚举属性的数组，而<code>Object.getOwnPropertyNames(..)</code>返回一个所有属性的数组，不论能不能枚举。</li>\n</ul>\n<h4 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h4><p>for..in 循环迭代一个对象上（包括它的 [[Prototype]] 链）所有的可迭代属性。想要迭代值，可以通过索引来引用值。</p>\n<p>ES5 为数组加入了几个迭代帮助方法，包括 forEach(..)、every(..)、和 some(..)。</p>\n<ul>\n<li><code>forEach(..)</code>将会迭代数组中所有的值，并且忽略回调的返回值；</li>\n<li><code>every(..)</code>会一直迭代到最后，或者当回调返回一个 false；</li>\n<li><code>some(..)</code>会一直迭代到最后，或者当回调返回一个 true。</li>\n</ul>\n<h4 id=\"关于for-of\"><a href=\"#关于for-of\" class=\"headerlink\" title=\"关于for..of\"></a>关于for..of</h4><p>ES6 加入了一个有用的 for..of 循环语法，用来迭代数组（和对象，如果这个对象有定义的迭代器）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> v <span class=\"keyword\">of</span> myArray) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( v );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p><code>for..of</code>循环要求被迭代的东西提供一个迭代器对象（从一个在语言规范中叫做<code>@@iterator</code>的默认内部函数那里得到），每次循环都调用一次这个迭代器对象的<code>next()</code>方法，循环迭代的内容就是这些连续的返回值。数组拥有内建的<code>@@iterator</code>。</p>\n<blockquote>\n<p>@@iterator 本身不是迭代器对象，而是一个返回迭代器对象的方法。</p>\n</blockquote>\n<p>普通的对象没有内建的<code>@@iterator</code>，可以自己定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span>,</span><br><span class=\"line\">\tb: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( myObject, <span class=\"built_in\">Symbol</span>.iterator, &#123;</span><br><span class=\"line\">\tenumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\twritable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\tconfigurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tvalue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> o = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> ks = <span class=\"built_in\">Object</span>.keys( o );</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\tnext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tvalue: o[ks[idx++]],</span><br><span class=\"line\">\t\t\t\t\tdone: (idx &gt; ks.length)</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动迭代 `myObject`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = myObject[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value:2, done:false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value:3, done:false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value:undefined, done:true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `for..of` 迭代 `myObject`</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> v <span class=\"keyword\">of</span> myObject) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( v );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"混合对象「类」\"><a href=\"#混合对象「类」\" class=\"headerlink\" title=\"混合对象「类」\"></a>混合对象「类」</h3><p>面向类的设计模式：实例化（instantiation）、继承（inheritance）与（相对）多态(relative polymorphism）。</p>\n<p>面向对象设计模式的：迭代器（iterator）、观察者（observer）、工厂（factory）、单例（singleton）。</p>\n<p>JavaScript 实际上并不拥有类。</p>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><h4 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h4><p>每个普通的<code>[[Prototype]]</code>链的最顶端，是内建的<code>Object.prototype</code>。因为 JavaScript 中所有普通对象（内建，而非被宿主环境扩展的）都源自<code>Object.prototype</code>对象，这个对象包含各种在整个 JS 中被使用的共通工具，比如<code>.toString()</code>、<code>.valueOf()</code>、<code>.hasOwnProperty(..)</code>和<code>.isPrototypeOf(..)</code>。</p>\n<h4 id=\"设置与遮蔽属性\"><a href=\"#设置与遮蔽属性\" class=\"headerlink\" title=\"设置与遮蔽属性\"></a>设置与遮蔽属性</h4><p>如果属性名<code>foo</code>同时存在于<code>myObject</code>本身和从<code>myObject</code>开始的<code>[[Prototype]]</code>链的更高层，这样的情况称为遮蔽。直接存在于<code>myObject</code>上的<code>foo</code>属性会遮蔽任何出现在链条高层的<code>foo</code>属性，因为<code>myObject.foo</code>查询总是在寻找链条最底层的<code>foo</code>属性。</p>\n<p>一个存在于<code>[[Prototype]]</code>链的高层的属性，对它的赋值不总是造成遮蔽，因为只读属性的存在会阻止同名属性在<code>[[Prototype]]</code>链的低层被创建，这种情况下可以使用<code>Object.defineProperty(..)</code>。</p>\n<p><code>++</code>操作符会产生隐式遮蔽：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a++; <span class=\"comment\">// 噢，隐式遮蔽！++ 操作符相当于 myObject.a = myObject.a + 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">anotherObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>构造器是在前面用 new 关键字调用的任何函数。函数不是构造器，但是当且仅当 new 被使用时，函数调用是一个「构造器调用」。</p>\n<h4 id=\"关于-constructor\"><a href=\"#关于-constructor\" class=\"headerlink\" title=\"关于.constructor\"></a>关于.constructor</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.myName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Foo( <span class=\"string\">\"a\"</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Foo( <span class=\"string\">\"b\"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">a.myName(); <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">b.myName(); <span class=\"comment\">// \"b\"</span></span><br></pre></td></tr></table></figure>\n<p><code>.constructor</code>只是<code>.prototype</code>对象上的一个不可枚举属性，并不意味着「被XX构建」。</p>\n<p>在<code>Foo.prototype</code>上的<code>.constructor</code>属性仅当<code>Foo</code>函数被声明时才出现在对象上。</p>\n<h4 id=\"「原型继承」\"><a href=\"#「原型继承」\" class=\"headerlink\" title=\"「原型继承」\"></a>「原型继承」</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.myName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\">name,label</span>) </span>&#123;</span><br><span class=\"line\">\tFoo.call( <span class=\"keyword\">this</span>, name );</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.label = label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里，我们创建一个新的 `Bar.prototype` 链接链到 `Foo.prototype`</span></span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意！现在 `Bar.prototype.constructor` 不存在了，</span></span><br><span class=\"line\"><span class=\"comment\">// 如果你有依赖这个属性的习惯的话，它可以被手动“修复”。</span></span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype.myLabel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.label;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Bar( <span class=\"string\">\"a\"</span>, <span class=\"string\">\"obj a\"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">a.myName(); <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">a.myLabel(); <span class=\"comment\">// \"obj a\"</span></span><br></pre></td></tr></table></figure>\n<p>上面<code>Bar.prototype = Object.create(Foo.prototype)</code>的作用是创建一个新的<code>Bar.prototype</code>对象并把它关联到<code>Foo.prototype</code>。当<code>function Bar() { .. }</code>被声明时，就像其他函数一样，拥有一个链到默认对象的<code>.prototype</code>链接。但是 那个对象没有链到我们希望的<code>Foo.prototype</code>。所以，我们创建了一个新对象，链到我们希望的地方，并将原来的错误链接的对象扔掉。</p>\n<p>关于修改<code>.prototype</code>，有这两种常见误解：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不会如你期望的那样工作!</span></span><br><span class=\"line\">Bar.prototype = Foo.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 会如你期望的那样工作</span></span><br><span class=\"line\"><span class=\"comment\">// 但会带有你可能不想要的副作用 :(</span></span><br><span class=\"line\">Bar.prototype = <span class=\"keyword\">new</span> Foo();</span><br></pre></td></tr></table></figure>\n<p><code>Bar.prototype = Foo.prototype</code>不会创建新对象让<code>Bar.prototype</code>链接。它只是让<code>Bar.prototype</code>成为<code>Foo.prototype</code>的另一个引用，将<code>Bar</code>直接链到<code>Foo</code>链着的 同一个对象：<code>Foo.prototype</code>。这意味着当你开始赋值时，你修改的不是一个分离的对象而是那个被分享的<code>Foo.prototype</code>对象本身，它将影响到所有链接到<code>Foo.prototype</code>的对象。</p>\n<p><code>Bar.prototype = new Foo()</code>确实创建了一个新的对象，这个新对象也的确链接到了我们希望的<code>Foo.prototype</code>。但是，它是用<code>Foo(..)</code>“构造器调用”来这样做的，如果这个函数有任何副作用，这些副作用就会在链接时发生。</p>\n<p>ES6 中增加了<code>Object.setPrototypeOf(..)</code>辅助工具来修改既存对象的链接：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6 以前</span></span><br><span class=\"line\"><span class=\"comment\">// 扔掉默认既存的 `Bar.prototype`</span></span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create( Foo.prototype );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6+</span></span><br><span class=\"line\"><span class=\"comment\">// 修改既存的 `Bar.prototype`</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></figure>\n<h4 id=\"检查「类」关系\"><a href=\"#检查「类」关系\" class=\"headerlink\" title=\"检查「类」关系\"></a>检查「类」关系</h4><p><strong>instanceof</strong></p>\n<p><code>instanceof</code>操作符的左侧接收一个普通对象，右侧接收一个函数。<code>instanceof</code>回答的问题是：在 a 的整个<code>[[Prototype]]</code>链中，是否有指向<code>Foo.prototype</code>的对象？</p>\n<p><strong>.isPrototypeOf</strong></p>\n<p><code>isPrototypeOf(..)</code>回答的问题是：在 a 的整个<code>[[Prototype]]</code>链中，<code>Foo.prototype</code>出现过吗？考察两个对象之间的关系。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单地：`b` 在 `c` 的 `[[Prototype]]` 链中出现过吗？</span></span><br><span class=\"line\">b.isPrototypeOf( c );</span><br></pre></td></tr></table></figure>\n<p><strong><code>.__proto__</code></strong></p>\n<p><code>.__proto__</code>直到 ES6 才被标准化，<code>.__proto__</code>实际上不存在于你考察的对象上。事实上，它和其他的共通工具在一起(<code>.toString()</code>，<code>.isPrototypeOf(..)</code>等)，存在于内建的<code>Object.prototype</code>上。<code>.__proto__</code>虽然看起来像一个属性，但实际上将它看做是一个 getter/setter 更合适。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty( <span class=\"built_in\">Object</span>.prototype, <span class=\"string\">\"__proto__\"</span>, &#123;</span><br><span class=\"line\">\tget: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ES5 的 getPrototypeOf(..)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.getPrototypeOf( <span class=\"keyword\">this</span> );</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tset: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ES6 的 setPrototypeOf(..)</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">Object</span>.setPrototypeOf( <span class=\"keyword\">this</span>, o );</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></figure>\n<h4 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">\tsomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"Tell me something good...\"</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"built_in\">Object</span>.create( foo );</span><br><span class=\"line\"></span><br><span class=\"line\">bar.something(); <span class=\"comment\">// Tell me something good...</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.create(..)</code>创建了一个链接到我们指定的对象（foo）上的新对象（bar），这给了我们<code>[[Prototype]]</code>机制的所有力量（委托），而且没有 new 函数作为类和构造器调用产生的所有没必要的复杂性，搞乱<code>.prototype</code>和<code>.constructor</code>引用，或任何其他的多余的东西。</p>\n<p><code>Object.create(..)</code>的第二个参数通过声明每个新属性的 属性描述符指定了要添加在新对象上的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject, &#123;</span><br><span class=\"line\">\tb: &#123;</span><br><span class=\"line\">\t\tenumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\twritable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tconfigurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tvalue: <span class=\"number\">3</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tc: &#123;</span><br><span class=\"line\">\t\tenumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\twritable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tconfigurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tvalue: <span class=\"number\">4</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"b\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"c\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.b; <span class=\"comment\">// 3</span></span><br><span class=\"line\">myObject.c; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.create(..)</code>在 ES5 中被加入。对于 ES5 之前的环境，我们需要一个对<code>Object.create(..)</code>部分 polyfill 工具：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Object</span>.create) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\t\tF.prototype = o;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","plink":"https://vincentdou.github.io/blog/post/2018-06-03-你不知道的JS-3/","type":"post"},{"layout":"post","title":"JS机制梳理总结","date":"2018-06-19T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> 原文：[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&utm_source=weixinqun)\n\n### 进程与线程\n\n- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n\n- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n\n### 浏览器是多进程的\n\n以 Chrome 浏览器为例，它到底包含这些主要进程：\n\n1. Browser进程：浏览器的主进程（负责协调、主控）。负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；网络资源的管理，下载等\n\n2. 第三方插件进程：每种类型的插件对应一个进程\n\n3. GPU进程：最多一个，用于3D绘制等\n\n4. 浏览器渲染进程（浏览器内核）（Renderer进程）：默认每个Tab页面一个进程，互不影响，内部是多线程的。负责页面渲染，脚本执行，事件处理等。**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）**\n\n### 浏览器渲染进程（浏览器内核）（Renderer进程）\n\n1. GUI渲染线程\n\n    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n\n    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n\n    - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n\n2. JS引擎线程\n\n    - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\n\n    - JS引擎线程负责解析Javascript脚本，运行代码。\n\n    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\n\n    - 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n3. 事件触发线程\n\n    - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\n\n    - 当JS引擎执行代码块如`setTimeOut`时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\n\n    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\n\n    - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）\n\n4. 定时触发器线程\n\n    - 传说中的`setInterval`与`setTimeout`所在线程\n\n    - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n\n    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n\n    - 注意，W3C在HTML标准中规定，规定要求`setTimeout`中低于4ms的时间间隔算为4ms。\n\n5. 异步http请求线程\n\n    - 在`XMLHttpRequest`在连接后是通过浏览器新开一个线程请求\n\n    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行\n\n![](https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d39a5b2?imageslim)\n\n### 浏览器渲染流程\n\n1. 解析html建立dom树\n\n2. 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n\n3. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n\n4. 绘制render树（paint），绘制页面像素信息\n\n5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n\n##### load事件与DOMContentLoaded事件的先后\n\n- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。\n(譬如如果有async加载的脚本就不一定完成)\n\n- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。\n（渲染完毕了）\n\n所以，顺序是：`DOMContentLoaded -> load`\n\n##### css加载是否会阻塞dom树渲染？\n\ncss是由单独的下载线程异步下载的。\n\n- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）\n\n- css加载会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\n\n### 复合图层和硬件加速\n\n##### 复合图层\n\n- 普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）\n\n- `absolute`布局（`fixed`也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。\n\n- 可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）\n\n##### 如何变成复合图层（硬件加速）\n\n将该元素变成一个复合图层，就是传说中的硬件加速技术\n\n- 最常用的方式：`translate3d`、`translateZ`\n\n- `opacity`属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\n\n- `will-chang`属性（这个比较偏僻），一般配合`opacity`与`translate`使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），\n作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\n\n- `<video><iframe><canvas><webgl>`等元素\n\n- 其它，譬如以前的flash插件\n\n### 从Event Loop谈JS的运行机制\n\n- JS分为同步任务和异步任务\n\n- 同步任务都在`主线程`上执行，形成一个`执行栈`\n\n- 主线程之外，`事件触发线程`管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件。\n\n- 一旦`执行栈`中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取`任务队列`，将可运行的异步任务添加到`可执行栈`中，开始执行。\n\n### macrotask与microtask\n\n`microtask`是`Promise`里的一个新的概念\n\n- macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\n\n    - 每一个 task 会从头到尾将这个任务执行完毕，不会执行其它\n\n    - 浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染（task->渲染->task->...）\n\n    - 主代码块，`setTimeout`，`setInterval`等可以形成 macrotask（可以看到，事件队列中的每一个事件都是一个 macrotask）\n\n- microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务\n\n    - 也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前\n\n    - 所以它的响应速度相比`setTimeout`（`setTimeout`是 task）会更快，因为无需等渲染\n\n    - 也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）\n\n    - `Promise`，`process.nextTick`等可以形成 microtask\n\n根据线程来理解下：\n\n- macrotask 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护\n\n- microtask 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由 JS 引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）\n\n![](https://user-gold-cdn.xitu.io/2018/1/21/1611938b96e93485?imageslim)\n\n另外，要注意 Promise 的 polyfill 与官方版本的区别：\n\n- 官方版本中，是标准的 microtask 形式\n\n- polyfill，一般都是通过 setTimeout 模拟的，所以是 macrotask 形式\n\n##### 使用MutationObserver实现microtask\n\nMutationObserver 可以用来实现 microtask（它属于 microtask，优先级小于Promise，一般是 Promise 不支持时才会这样做）\n\n它是 HTML5 中的新特性，作用是：监听一个 DOM 变动，当 DOM 对象树发生任何变动时，Mutation Observer 会得到通知\n\n像以前的Vue源码中就是利用它来模拟 nextTick 的，具体原理是，创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容，如下：（Vue的源码，未修改）\n\n```\nvar counter = 1\nvar observer = new MutationObserver(nextTickHandler)\nvar textNode = document.createTextNode(String(counter))\n\nobserver.observe(textNode, {\n    characterData: true\n})\ntimerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n}\n```","source":"_posts/2018-06-20-JS机制梳理总结.markdown","raw":"---\nlayout:     post\ntitle:      \"JS机制梳理总结\"\ndate:       2018-06-20\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - JS机制\n---\n\n> 原文：[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&utm_source=weixinqun)\n\n### 进程与线程\n\n- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n\n- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n\n### 浏览器是多进程的\n\n以 Chrome 浏览器为例，它到底包含这些主要进程：\n\n1. Browser进程：浏览器的主进程（负责协调、主控）。负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；网络资源的管理，下载等\n\n2. 第三方插件进程：每种类型的插件对应一个进程\n\n3. GPU进程：最多一个，用于3D绘制等\n\n4. 浏览器渲染进程（浏览器内核）（Renderer进程）：默认每个Tab页面一个进程，互不影响，内部是多线程的。负责页面渲染，脚本执行，事件处理等。**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）**\n\n### 浏览器渲染进程（浏览器内核）（Renderer进程）\n\n1. GUI渲染线程\n\n    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n\n    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n\n    - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n\n2. JS引擎线程\n\n    - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\n\n    - JS引擎线程负责解析Javascript脚本，运行代码。\n\n    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\n\n    - 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n3. 事件触发线程\n\n    - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）\n\n    - 当JS引擎执行代码块如`setTimeOut`时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中\n\n    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理\n\n    - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）\n\n4. 定时触发器线程\n\n    - 传说中的`setInterval`与`setTimeout`所在线程\n\n    - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n\n    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）\n\n    - 注意，W3C在HTML标准中规定，规定要求`setTimeout`中低于4ms的时间间隔算为4ms。\n\n5. 异步http请求线程\n\n    - 在`XMLHttpRequest`在连接后是通过浏览器新开一个线程请求\n\n    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行\n\n![](https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d39a5b2?imageslim)\n\n### 浏览器渲染流程\n\n1. 解析html建立dom树\n\n2. 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）\n\n3. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n\n4. 绘制render树（paint），绘制页面像素信息\n\n5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n\n##### load事件与DOMContentLoaded事件的先后\n\n- 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。\n(譬如如果有async加载的脚本就不一定完成)\n\n- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。\n（渲染完毕了）\n\n所以，顺序是：`DOMContentLoaded -> load`\n\n##### css加载是否会阻塞dom树渲染？\n\ncss是由单独的下载线程异步下载的。\n\n- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）\n\n- css加载会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\n\n### 复合图层和硬件加速\n\n##### 复合图层\n\n- 普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）\n\n- `absolute`布局（`fixed`也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。\n\n- 可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）\n\n##### 如何变成复合图层（硬件加速）\n\n将该元素变成一个复合图层，就是传说中的硬件加速技术\n\n- 最常用的方式：`translate3d`、`translateZ`\n\n- `opacity`属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\n\n- `will-chang`属性（这个比较偏僻），一般配合`opacity`与`translate`使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），\n作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\n\n- `<video><iframe><canvas><webgl>`等元素\n\n- 其它，譬如以前的flash插件\n\n### 从Event Loop谈JS的运行机制\n\n- JS分为同步任务和异步任务\n\n- 同步任务都在`主线程`上执行，形成一个`执行栈`\n\n- 主线程之外，`事件触发线程`管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件。\n\n- 一旦`执行栈`中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取`任务队列`，将可运行的异步任务添加到`可执行栈`中，开始执行。\n\n### macrotask与microtask\n\n`microtask`是`Promise`里的一个新的概念\n\n- macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\n\n    - 每一个 task 会从头到尾将这个任务执行完毕，不会执行其它\n\n    - 浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染（task->渲染->task->...）\n\n    - 主代码块，`setTimeout`，`setInterval`等可以形成 macrotask（可以看到，事件队列中的每一个事件都是一个 macrotask）\n\n- microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务\n\n    - 也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前\n\n    - 所以它的响应速度相比`setTimeout`（`setTimeout`是 task）会更快，因为无需等渲染\n\n    - 也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）\n\n    - `Promise`，`process.nextTick`等可以形成 microtask\n\n根据线程来理解下：\n\n- macrotask 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护\n\n- microtask 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由 JS 引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）\n\n![](https://user-gold-cdn.xitu.io/2018/1/21/1611938b96e93485?imageslim)\n\n另外，要注意 Promise 的 polyfill 与官方版本的区别：\n\n- 官方版本中，是标准的 microtask 形式\n\n- polyfill，一般都是通过 setTimeout 模拟的，所以是 macrotask 形式\n\n##### 使用MutationObserver实现microtask\n\nMutationObserver 可以用来实现 microtask（它属于 microtask，优先级小于Promise，一般是 Promise 不支持时才会这样做）\n\n它是 HTML5 中的新特性，作用是：监听一个 DOM 变动，当 DOM 对象树发生任何变动时，Mutation Observer 会得到通知\n\n像以前的Vue源码中就是利用它来模拟 nextTick 的，具体原理是，创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容，如下：（Vue的源码，未修改）\n\n```\nvar counter = 1\nvar observer = new MutationObserver(nextTickHandler)\nvar textNode = document.createTextNode(String(counter))\n\nobserver.observe(textNode, {\n    characterData: true\n})\ntimerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n}\n```","slug":"2018-06-20-JS机制梳理总结","published":1,"updated":"2019-01-02T08:49:00.245Z","comments":0,"photos":[],"link":"post/2018-06-20-JS机制梳理总结","_id":"cjz2epjfb0013n3w5exrsqy73","content":"<blockquote>\n<p>原文：<a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>\n</blockquote>\n<h3 id=\"进程与线程\">进程与线程<a href=\"post/2018-06-20-JS机制梳理总结#进程与线程\"></a></h3><ul>\n<li><p>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</p>\n</li>\n<li><p>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p>\n</li>\n</ul>\n<h3 id=\"浏览器是多进程的\">浏览器是多进程的<a href=\"post/2018-06-20-JS机制梳理总结#浏览器是多进程的\"></a></h3><p>以 Chrome 浏览器为例，它到底包含这些主要进程：</p>\n<ol>\n<li><p>Browser进程：浏览器的主进程（负责协调、主控）。负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；网络资源的管理，下载等</p>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程</p>\n</li>\n<li><p>GPU进程：最多一个，用于3D绘制等</p>\n</li>\n<li><p>浏览器渲染进程（浏览器内核）（Renderer进程）：默认每个Tab页面一个进程，互不影响，内部是多线程的。负责页面渲染，脚本执行，事件处理等。<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p>\n</li>\n</ol>\n<h3 id=\"浏览器渲染进程（浏览器内核）（Renderer进程）\">浏览器渲染进程（浏览器内核）（Renderer进程）<a href=\"post/2018-06-20-JS机制梳理总结#浏览器渲染进程（浏览器内核）（Renderer进程）\"></a></h3><ol>\n<li><p>GUI渲染线程</p>\n<ul>\n<li><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</p>\n</li>\n<li><p>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</p>\n</li>\n<li><p>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>\n</li>\n</ul>\n</li>\n<li><p>JS引擎线程</p>\n<ul>\n<li><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</p>\n</li>\n<li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p>\n</li>\n<li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p>\n</li>\n<li><p>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n</li>\n</ul>\n</li>\n<li><p>事件触发线程</p>\n<ul>\n<li><p>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</p>\n</li>\n<li><p>当JS引擎执行代码块如<code>setTimeOut</code>时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</p>\n</li>\n<li><p>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p>\n</li>\n<li><p>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p>\n</li>\n</ul>\n</li>\n<li><p>定时触发器线程</p>\n<ul>\n<li><p>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</p>\n</li>\n<li><p>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</p>\n</li>\n<li><p>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p>\n</li>\n<li><p>注意，W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms。</p>\n</li>\n</ul>\n</li>\n<li><p>异步http请求线程</p>\n<ul>\n<li><p>在<code>XMLHttpRequest</code>在连接后是通过浏览器新开一个线程请求</p>\n</li>\n<li><p>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d39a5b2?imageslim\" alt=\"\" class=\"article-img\"></p>\n<h3 id=\"浏览器渲染流程\">浏览器渲染流程<a href=\"post/2018-06-20-JS机制梳理总结#浏览器渲染流程\"></a></h3><ol>\n<li><p>解析html建立dom树</p>\n</li>\n<li><p>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</p>\n</li>\n<li><p>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p>\n</li>\n<li><p>绘制render树（paint），绘制页面像素信息</p>\n</li>\n<li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</p>\n</li>\n</ol>\n<h5 id=\"load事件与DOMContentLoaded事件的先后\">load事件与DOMContentLoaded事件的先后<a href=\"post/2018-06-20-JS机制梳理总结#load事件与DOMContentLoaded事件的先后\"></a></h5><ul>\n<li><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p>\n</li>\n<li><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p>\n</li>\n</ul>\n<p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p>\n<h5 id=\"css加载是否会阻塞dom树渲染？\">css加载是否会阻塞dom树渲染？<a href=\"post/2018-06-20-JS机制梳理总结#css加载是否会阻塞dom树渲染？\"></a></h5><p>css是由单独的下载线程异步下载的。</p>\n<ul>\n<li><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</p>\n</li>\n<li><p>css加载会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>\n</li>\n</ul>\n<h3 id=\"复合图层和硬件加速\">复合图层和硬件加速<a href=\"post/2018-06-20-JS机制梳理总结#复合图层和硬件加速\"></a></h3><h5 id=\"复合图层\">复合图层<a href=\"post/2018-06-20-JS机制梳理总结#复合图层\"></a></h5><ul>\n<li><p>普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</p>\n</li>\n<li><p><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p>\n</li>\n<li><p>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>\n</li>\n</ul>\n<h5 id=\"如何变成复合图层（硬件加速）\">如何变成复合图层（硬件加速）<a href=\"post/2018-06-20-JS机制梳理总结#如何变成复合图层（硬件加速）\"></a></h5><p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p>\n<ul>\n<li><p>最常用的方式：<code>translate3d</code>、<code>translateZ</code></p>\n</li>\n<li><p><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</p>\n</li>\n<li><p><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），<br>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p>\n</li>\n<li><p><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</p>\n</li>\n<li><p>其它，譬如以前的flash插件</p>\n</li>\n</ul>\n<h3 id=\"从Event-Loop谈JS的运行机制\">从Event Loop谈JS的运行机制<a href=\"post/2018-06-20-JS机制梳理总结#从Event-Loop谈JS的运行机制\"></a></h3><ul>\n<li><p>JS分为同步任务和异步任务</p>\n</li>\n<li><p>同步任务都在<code>主线程</code>上执行，形成一个<code>执行栈</code></p>\n</li>\n<li><p>主线程之外，<code>事件触发线程</code>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件。</p>\n</li>\n<li><p>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到<code>可执行栈</code>中，开始执行。</p>\n</li>\n</ul>\n<h3 id=\"macrotask与microtask\">macrotask与microtask<a href=\"post/2018-06-20-JS机制梳理总结#macrotask与microtask\"></a></h3><p><code>microtask</code>是<code>Promise</code>里的一个新的概念</p>\n<ul>\n<li><p>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>\n<ul>\n<li><p>每一个 task 会从头到尾将这个任务执行完毕，不会执行其它</p>\n</li>\n<li><p>浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染（task-&gt;渲染-&gt;task-&gt;…）</p>\n</li>\n<li><p>主代码块，<code>setTimeout</code>，<code>setInterval</code>等可以形成 macrotask（可以看到，事件队列中的每一个事件都是一个 macrotask）</p>\n</li>\n</ul>\n</li>\n<li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p>\n<ul>\n<li><p>也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前</p>\n</li>\n<li><p>所以它的响应速度相比<code>setTimeout</code>（<code>setTimeout</code>是 task）会更快，因为无需等渲染</p>\n</li>\n<li><p>也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）</p>\n</li>\n<li><p><code>Promise</code>，<code>process.nextTick</code>等可以形成 microtask</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>根据线程来理解下：</p>\n<ul>\n<li><p>macrotask 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护</p>\n</li>\n<li><p>microtask 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由 JS 引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/1/21/1611938b96e93485?imageslim\" alt=\"\" class=\"article-img\"></p>\n<p>另外，要注意 Promise 的 polyfill 与官方版本的区别：</p>\n<ul>\n<li><p>官方版本中，是标准的 microtask 形式</p>\n</li>\n<li><p>polyfill，一般都是通过 setTimeout 模拟的，所以是 macrotask 形式</p>\n</li>\n</ul>\n<h5 id=\"使用MutationObserver实现microtask\">使用MutationObserver实现microtask<a href=\"post/2018-06-20-JS机制梳理总结#使用MutationObserver实现microtask\"></a></h5><p>MutationObserver 可以用来实现 microtask（它属于 microtask，优先级小于Promise，一般是 Promise 不支持时才会这样做）</p>\n<p>它是 HTML5 中的新特性，作用是：监听一个 DOM 变动，当 DOM 对象树发生任何变动时，Mutation Observer 会得到通知</p>\n<p>像以前的Vue源码中就是利用它来模拟 nextTick 的，具体原理是，创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容，如下：（Vue的源码，未修改）</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var counter = 1</span><br><span class=\"line\">var observer = new MutationObserver(nextTickHandler)</span><br><span class=\"line\">var textNode = document.createTextNode(String(counter))</span><br><span class=\"line\"></span><br><span class=\"line\">observer.observe(textNode, &#123;</span><br><span class=\"line\">    characterData: true</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">timerFunc = () =&gt; &#123;</span><br><span class=\"line\">    counter = (counter + 1) % 2</span><br><span class=\"line\">    textNode.data = String(counter)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>\n</blockquote>\n<h3 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h3><ul>\n<li><p>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</p>\n</li>\n<li><p>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p>\n</li>\n</ul>\n<h3 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h3><p>以 Chrome 浏览器为例，它到底包含这些主要进程：</p>\n<ol>\n<li><p>Browser进程：浏览器的主进程（负责协调、主控）。负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；网络资源的管理，下载等</p>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程</p>\n</li>\n<li><p>GPU进程：最多一个，用于3D绘制等</p>\n</li>\n<li><p>浏览器渲染进程（浏览器内核）（Renderer进程）：默认每个Tab页面一个进程，互不影响，内部是多线程的。负责页面渲染，脚本执行，事件处理等。<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p>\n</li>\n</ol>\n<h3 id=\"浏览器渲染进程（浏览器内核）（Renderer进程）\"><a href=\"#浏览器渲染进程（浏览器内核）（Renderer进程）\" class=\"headerlink\" title=\"浏览器渲染进程（浏览器内核）（Renderer进程）\"></a>浏览器渲染进程（浏览器内核）（Renderer进程）</h3><ol>\n<li><p>GUI渲染线程</p>\n<ul>\n<li><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</p>\n</li>\n<li><p>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</p>\n</li>\n<li><p>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>\n</li>\n</ul>\n</li>\n<li><p>JS引擎线程</p>\n<ul>\n<li><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</p>\n</li>\n<li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p>\n</li>\n<li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p>\n</li>\n<li><p>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n</li>\n</ul>\n</li>\n<li><p>事件触发线程</p>\n<ul>\n<li><p>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</p>\n</li>\n<li><p>当JS引擎执行代码块如<code>setTimeOut</code>时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</p>\n</li>\n<li><p>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p>\n</li>\n<li><p>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p>\n</li>\n</ul>\n</li>\n<li><p>定时触发器线程</p>\n<ul>\n<li><p>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</p>\n</li>\n<li><p>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</p>\n</li>\n<li><p>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p>\n</li>\n<li><p>注意，W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms。</p>\n</li>\n</ul>\n</li>\n<li><p>异步http请求线程</p>\n<ul>\n<li><p>在<code>XMLHttpRequest</code>在连接后是通过浏览器新开一个线程请求</p>\n</li>\n<li><p>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d39a5b2?imageslim\" alt=\"\"></p>\n<h3 id=\"浏览器渲染流程\"><a href=\"#浏览器渲染流程\" class=\"headerlink\" title=\"浏览器渲染流程\"></a>浏览器渲染流程</h3><ol>\n<li><p>解析html建立dom树</p>\n</li>\n<li><p>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</p>\n</li>\n<li><p>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p>\n</li>\n<li><p>绘制render树（paint），绘制页面像素信息</p>\n</li>\n<li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</p>\n</li>\n</ol>\n<h5 id=\"load事件与DOMContentLoaded事件的先后\"><a href=\"#load事件与DOMContentLoaded事件的先后\" class=\"headerlink\" title=\"load事件与DOMContentLoaded事件的先后\"></a>load事件与DOMContentLoaded事件的先后</h5><ul>\n<li><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p>\n</li>\n<li><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p>\n</li>\n</ul>\n<p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p>\n<h5 id=\"css加载是否会阻塞dom树渲染？\"><a href=\"#css加载是否会阻塞dom树渲染？\" class=\"headerlink\" title=\"css加载是否会阻塞dom树渲染？\"></a>css加载是否会阻塞dom树渲染？</h5><p>css是由单独的下载线程异步下载的。</p>\n<ul>\n<li><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</p>\n</li>\n<li><p>css加载会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>\n</li>\n</ul>\n<h3 id=\"复合图层和硬件加速\"><a href=\"#复合图层和硬件加速\" class=\"headerlink\" title=\"复合图层和硬件加速\"></a>复合图层和硬件加速</h3><h5 id=\"复合图层\"><a href=\"#复合图层\" class=\"headerlink\" title=\"复合图层\"></a>复合图层</h5><ul>\n<li><p>普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</p>\n</li>\n<li><p><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p>\n</li>\n<li><p>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>\n</li>\n</ul>\n<h5 id=\"如何变成复合图层（硬件加速）\"><a href=\"#如何变成复合图层（硬件加速）\" class=\"headerlink\" title=\"如何变成复合图层（硬件加速）\"></a>如何变成复合图层（硬件加速）</h5><p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p>\n<ul>\n<li><p>最常用的方式：<code>translate3d</code>、<code>translateZ</code></p>\n</li>\n<li><p><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</p>\n</li>\n<li><p><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），<br>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p>\n</li>\n<li><p><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</p>\n</li>\n<li><p>其它，譬如以前的flash插件</p>\n</li>\n</ul>\n<h3 id=\"从Event-Loop谈JS的运行机制\"><a href=\"#从Event-Loop谈JS的运行机制\" class=\"headerlink\" title=\"从Event Loop谈JS的运行机制\"></a>从Event Loop谈JS的运行机制</h3><ul>\n<li><p>JS分为同步任务和异步任务</p>\n</li>\n<li><p>同步任务都在<code>主线程</code>上执行，形成一个<code>执行栈</code></p>\n</li>\n<li><p>主线程之外，<code>事件触发线程</code>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件。</p>\n</li>\n<li><p>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到<code>可执行栈</code>中，开始执行。</p>\n</li>\n</ul>\n<h3 id=\"macrotask与microtask\"><a href=\"#macrotask与microtask\" class=\"headerlink\" title=\"macrotask与microtask\"></a>macrotask与microtask</h3><p><code>microtask</code>是<code>Promise</code>里的一个新的概念</p>\n<ul>\n<li><p>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>\n<ul>\n<li><p>每一个 task 会从头到尾将这个任务执行完毕，不会执行其它</p>\n</li>\n<li><p>浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染（task-&gt;渲染-&gt;task-&gt;…）</p>\n</li>\n<li><p>主代码块，<code>setTimeout</code>，<code>setInterval</code>等可以形成 macrotask（可以看到，事件队列中的每一个事件都是一个 macrotask）</p>\n</li>\n</ul>\n</li>\n<li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p>\n<ul>\n<li><p>也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前</p>\n</li>\n<li><p>所以它的响应速度相比<code>setTimeout</code>（<code>setTimeout</code>是 task）会更快，因为无需等渲染</p>\n</li>\n<li><p>也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）</p>\n</li>\n<li><p><code>Promise</code>，<code>process.nextTick</code>等可以形成 microtask</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>根据线程来理解下：</p>\n<ul>\n<li><p>macrotask 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护</p>\n</li>\n<li><p>microtask 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由 JS 引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/1/21/1611938b96e93485?imageslim\" alt=\"\"></p>\n<p>另外，要注意 Promise 的 polyfill 与官方版本的区别：</p>\n<ul>\n<li><p>官方版本中，是标准的 microtask 形式</p>\n</li>\n<li><p>polyfill，一般都是通过 setTimeout 模拟的，所以是 macrotask 形式</p>\n</li>\n</ul>\n<h5 id=\"使用MutationObserver实现microtask\"><a href=\"#使用MutationObserver实现microtask\" class=\"headerlink\" title=\"使用MutationObserver实现microtask\"></a>使用MutationObserver实现microtask</h5><p>MutationObserver 可以用来实现 microtask（它属于 microtask，优先级小于Promise，一般是 Promise 不支持时才会这样做）</p>\n<p>它是 HTML5 中的新特性，作用是：监听一个 DOM 变动，当 DOM 对象树发生任何变动时，Mutation Observer 会得到通知</p>\n<p>像以前的Vue源码中就是利用它来模拟 nextTick 的，具体原理是，创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容，如下：（Vue的源码，未修改）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var counter = 1</span><br><span class=\"line\">var observer = new MutationObserver(nextTickHandler)</span><br><span class=\"line\">var textNode = document.createTextNode(String(counter))</span><br><span class=\"line\"></span><br><span class=\"line\">observer.observe(textNode, &#123;</span><br><span class=\"line\">    characterData: true</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">timerFunc = () =&gt; &#123;</span><br><span class=\"line\">    counter = (counter + 1) % 2</span><br><span class=\"line\">    textNode.data = String(counter)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","plink":"https://vincentdou.github.io/blog/post/2018-06-20-JS机制梳理总结/","type":"post"},{"layout":"post","title":"浏览器缓存知识小结及应用","date":"2018-08-02T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n### 浏览器缓存基本认识\n\n它分为强缓存和协商缓存： \n\n1. 浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器；\n\n2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；\n\n3. 强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：**强缓存不发请求到服务器，协商缓存会发请求到服务器。**\n\n4. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n\n### 强缓存\n\n#### 强缓存的原理\n\n当浏览器对某个资源的请求命中了强缓存时，返回的 http 状态为 200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache。\n\n强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。\n\nExpires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用 GMT 格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160113231739069-2137551345.png)\n\n2. 浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；\n\n3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。\n\n4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。\n\n> Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。\n\nHTTP/1.1 的时候，提出了一个新的 header，就是 Cache-Control，在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：\n\n- public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n\n- private：所有内容只有客户端可以缓存，Cache-Control 的默认取值\n\n- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n\n- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n\n- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n\n它的缓存原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160114150736335-1224902285.png)\n\n2. 浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；\n\n3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n\n4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。\n\n> Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。\n\n> 这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160114213430210-470510830.png)\n\n#### 强缓存的管理\n\n前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有 2 种方式来设置是否启用强缓存：\n\n1. 通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；\n\n2. 通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。\n\n#### 强缓存的应用\n\n强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的 Expires 或 Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。\n\n然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。\n\n这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：\n\n[大公司里怎样开发和部署前端代码？](http://www.zhihu.com/question/20790576)\n\n强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的 html 也可以看作是动态资源，如果这种 html 也被缓存，当这些 html 更新之后，可能就没有机制能够通知浏览器这些 html 有更新，尤其是前后端分离的应用里，页面都是纯 html 页面，每个访问地址可能都是直接访问 html 页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。\n\n### 协商缓存\n\n#### 协商缓存的原理\n\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串。\n\n协商缓存是利用的是`Last-Modified`、`If-Modified-Since`和`ETag`、`If-None-Match`这两对 Header 来管理的。\n\nLast-Modified、If-Modified-Since 的控制缓存的原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111445678-1475052015.png)\n\n2. 浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125438397-853706841.png)\n\n3. 服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111453741-1776179122.png)\n\n4. 浏览器收到 304 的响应后，就会从缓存中加载资源。\n\n5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。\n\nLast-Modified、If-Modified-Since 都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是`ETag`、`If-None-Match`。它们的缓存管理的方式是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112631897-451862486.png)\n\n2. 浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag的值：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112640007-97304290.png)\n\n3. 服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125439444-1024808154.png)\n\n4. 浏览器收到 304 的响应后，就会从缓存中加载资源。\n\n#### 协商缓存的管理\n\n协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用`Last-Modified`、`If-Modified-Since`和`ETag`、`If-None-Match`，比如 apache:\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125440382-1079455302.png)\n\n如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。\n\n`Last-Modified`、`If-Modified-Since`和`ETag`、`If-None-Match`一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：\n\n分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；\n\n分布式系统尽量关闭掉 ETag(每台机器生成的ETag都会不一样）；\n\n协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。\n\n### 浏览器的缓存存放在哪里？\n\n缓存有两种情况：内存缓存(from memory cache)和硬盘缓存(from disk cache)\n\n#### 内存缓存 / 硬盘缓存\n\n内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：\n\n- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。\n\n- 时效性：一旦该进程关闭，则该进程的内存则会清空。\n\n硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。\n\n在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n### 浏览器行为对缓存的影响\n\n如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：\n\n1. 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n\n2. 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；\n\n> 参考：\n> [浏览器缓存知识小结及应用](https://www.cnblogs.com/lyzg/p/5125934.html)\n> [彻底理解浏览器的缓存机制](https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA)","source":"_posts/2018-08-03-浏览器缓存知识小结及应用.markdown","raw":"---\nlayout:     post\ntitle:      \"浏览器缓存知识小结及应用\"\ndate:       2018-08-03\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - 缓存\n---\n\n### 浏览器缓存基本认识\n\n它分为强缓存和协商缓存： \n\n1. 浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器；\n\n2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；\n\n3. 强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：**强缓存不发请求到服务器，协商缓存会发请求到服务器。**\n\n4. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n\n### 强缓存\n\n#### 强缓存的原理\n\n当浏览器对某个资源的请求命中了强缓存时，返回的 http 状态为 200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache。\n\n强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。\n\nExpires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用 GMT 格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160113231739069-2137551345.png)\n\n2. 浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；\n\n3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。\n\n4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。\n\n> Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。\n\nHTTP/1.1 的时候，提出了一个新的 header，就是 Cache-Control，在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：\n\n- public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n\n- private：所有内容只有客户端可以缓存，Cache-Control 的默认取值\n\n- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n\n- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n\n- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n\n它的缓存原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160114150736335-1224902285.png)\n\n2. 浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；\n\n3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n\n4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。\n\n> Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。\n\n> 这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160114213430210-470510830.png)\n\n#### 强缓存的管理\n\n前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有 2 种方式来设置是否启用强缓存：\n\n1. 通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；\n\n2. 通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。\n\n#### 强缓存的应用\n\n强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的 Expires 或 Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。\n\n然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。\n\n这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：\n\n[大公司里怎样开发和部署前端代码？](http://www.zhihu.com/question/20790576)\n\n强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的 html 也可以看作是动态资源，如果这种 html 也被缓存，当这些 html 更新之后，可能就没有机制能够通知浏览器这些 html 有更新，尤其是前后端分离的应用里，页面都是纯 html 页面，每个访问地址可能都是直接访问 html 页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。\n\n### 协商缓存\n\n#### 协商缓存的原理\n\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串。\n\n协商缓存是利用的是`Last-Modified`、`If-Modified-Since`和`ETag`、`If-None-Match`这两对 Header 来管理的。\n\nLast-Modified、If-Modified-Since 的控制缓存的原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111445678-1475052015.png)\n\n2. 浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125438397-853706841.png)\n\n3. 服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111453741-1776179122.png)\n\n4. 浏览器收到 304 的响应后，就会从缓存中加载资源。\n\n5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。\n\nLast-Modified、If-Modified-Since 都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是`ETag`、`If-None-Match`。它们的缓存管理的方式是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112631897-451862486.png)\n\n2. 浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag的值：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112640007-97304290.png)\n\n3. 服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125439444-1024808154.png)\n\n4. 浏览器收到 304 的响应后，就会从缓存中加载资源。\n\n#### 协商缓存的管理\n\n协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用`Last-Modified`、`If-Modified-Since`和`ETag`、`If-None-Match`，比如 apache:\n\n![](https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125440382-1079455302.png)\n\n如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。\n\n`Last-Modified`、`If-Modified-Since`和`ETag`、`If-None-Match`一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：\n\n分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；\n\n分布式系统尽量关闭掉 ETag(每台机器生成的ETag都会不一样）；\n\n协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。\n\n### 浏览器的缓存存放在哪里？\n\n缓存有两种情况：内存缓存(from memory cache)和硬盘缓存(from disk cache)\n\n#### 内存缓存 / 硬盘缓存\n\n内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：\n\n- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。\n\n- 时效性：一旦该进程关闭，则该进程的内存则会清空。\n\n硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。\n\n在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n### 浏览器行为对缓存的影响\n\n如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：\n\n1. 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n\n2. 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；\n\n> 参考：\n> [浏览器缓存知识小结及应用](https://www.cnblogs.com/lyzg/p/5125934.html)\n> [彻底理解浏览器的缓存机制](https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA)","slug":"2018-08-03-浏览器缓存知识小结及应用","published":1,"updated":"2019-01-02T08:49:00.227Z","comments":0,"photos":[],"link":"post/2018-08-03-浏览器缓存知识小结及应用","_id":"cjz2epjfd0015n3w5u5lpszla","content":"<h3 id=\"浏览器缓存基本认识\">浏览器缓存基本认识<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#浏览器缓存基本认识\"></a></h3><p>它分为强缓存和协商缓存： </p>\n<ol>\n<li><p>浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器；</p>\n</li>\n<li><p>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>\n</li>\n<li><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器，协商缓存会发请求到服务器。</strong></p>\n</li>\n<li><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>\n</li>\n</ol>\n<h3 id=\"强缓存\">强缓存<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#强缓存\"></a></h3><h4 id=\"强缓存的原理\">强缓存的原理<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#强缓存的原理\"></a></h4><p>当浏览器对某个资源的请求命中了强缓存时，返回的 http 状态为 200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache。</p>\n<p>强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。</p>\n<p>Expires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用 GMT 格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160113231739069-2137551345.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"2\">\n<li><p>浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；</p>\n</li>\n<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。</p>\n</li>\n<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。</p>\n</li>\n</ol>\n<blockquote>\n<p>Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。</p>\n</blockquote>\n<p>HTTP/1.1 的时候，提出了一个新的 header，就是 Cache-Control，在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：</p>\n<ul>\n<li><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</p>\n</li>\n<li><p>private：所有内容只有客户端可以缓存，Cache-Control 的默认取值</p>\n</li>\n<li><p>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</p>\n</li>\n<li><p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>\n</li>\n<li><p>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</p>\n</li>\n</ul>\n<p>它的缓存原理是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160114150736335-1224902285.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"2\">\n<li><p>浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；</p>\n</li>\n<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>\n</li>\n<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。</p>\n</li>\n</ol>\n<blockquote>\n<p>Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。</p>\n</blockquote>\n<blockquote>\n<p>这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：</p>\n</blockquote>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160114213430210-470510830.png\" alt=\"\" class=\"article-img\"></p>\n<h4 id=\"强缓存的管理\">强缓存的管理<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#强缓存的管理\"></a></h4><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有 2 种方式来设置是否启用强缓存：</p>\n<ol>\n<li><p>通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；</p>\n</li>\n<li><p>通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。</p>\n</li>\n</ol>\n<h4 id=\"强缓存的应用\">强缓存的应用<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#强缓存的应用\"></a></h4><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的 Expires 或 Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。</p>\n<p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。</p>\n<p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：</p>\n<p><a href=\"http://www.zhihu.com/question/20790576\" target=\"_blank\" rel=\"noopener\">大公司里怎样开发和部署前端代码？</a></p>\n<p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的 html 也可以看作是动态资源，如果这种 html 也被缓存，当这些 html 更新之后，可能就没有机制能够通知浏览器这些 html 有更新，尤其是前后端分离的应用里，页面都是纯 html 页面，每个访问地址可能都是直接访问 html 页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。</p>\n<h3 id=\"协商缓存\">协商缓存<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#协商缓存\"></a></h3><h4 id=\"协商缓存的原理\">协商缓存的原理<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#协商缓存的原理\"></a></h4><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串。</p>\n<p>协商缓存是利用的是<code>Last-Modified</code>、<code>If-Modified-Since</code>和<code>ETag</code>、<code>If-None-Match</code>这两对 Header 来管理的。</p>\n<p>Last-Modified、If-Modified-Since 的控制缓存的原理是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111445678-1475052015.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"2\">\n<li>浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125438397-853706841.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"3\">\n<li>服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111453741-1776179122.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"4\">\n<li><p>浏览器收到 304 的响应后，就会从缓存中加载资源。</p>\n</li>\n<li><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。</p>\n</li>\n</ol>\n<p>Last-Modified、If-Modified-Since 都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是<code>ETag</code>、<code>If-None-Match</code>。它们的缓存管理的方式是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112631897-451862486.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"2\">\n<li>浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag的值：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112640007-97304290.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"3\">\n<li>服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125439444-1024808154.png\" alt=\"\" class=\"article-img\"></p>\n<ol start=\"4\">\n<li>浏览器收到 304 的响应后，就会从缓存中加载资源。</li>\n</ol>\n<h4 id=\"协商缓存的管理\">协商缓存的管理<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#协商缓存的管理\"></a></h4><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用<code>Last-Modified</code>、<code>If-Modified-Since</code>和<code>ETag</code>、<code>If-None-Match</code>，比如 apache:</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125440382-1079455302.png\" alt=\"\" class=\"article-img\"></p>\n<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>\n<p><code>Last-Modified</code>、<code>If-Modified-Since</code>和<code>ETag</code>、<code>If-None-Match</code>一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；</p>\n<p>分布式系统尽量关闭掉 ETag(每台机器生成的ETag都会不一样）；</p>\n<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>\n<h3 id=\"浏览器的缓存存放在哪里？\">浏览器的缓存存放在哪里？<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#浏览器的缓存存放在哪里？\"></a></h3><p>缓存有两种情况：内存缓存(from memory cache)和硬盘缓存(from disk cache)</p>\n<h4 id=\"内存缓存-硬盘缓存\">内存缓存 / 硬盘缓存<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#内存缓存-硬盘缓存\"></a></h4><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</p>\n<ul>\n<li><p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p>\n</li>\n<li><p>时效性：一旦该进程关闭，则该进程的内存则会清空。</p>\n</li>\n</ul>\n<p>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p>\n<p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>\n<h3 id=\"浏览器行为对缓存的影响\">浏览器行为对缓存的影响<a href=\"post/2018-08-03-浏览器缓存知识小结及应用#浏览器行为对缓存的影响\"></a></h3><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>\n<ol>\n<li><p>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>\n</li>\n<li><p>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p>\n</li>\n</ol>\n<blockquote>\n<p>参考：<br><a href=\"https://www.cnblogs.com/lyzg/p/5125934.html\" target=\"_blank\" rel=\"noopener\">浏览器缓存知识小结及应用</a><br><a href=\"https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\" target=\"_blank\" rel=\"noopener\">彻底理解浏览器的缓存机制</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浏览器缓存基本认识\"><a href=\"#浏览器缓存基本认识\" class=\"headerlink\" title=\"浏览器缓存基本认识\"></a>浏览器缓存基本认识</h3><p>它分为强缓存和协商缓存： </p>\n<ol>\n<li><p>浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器；</p>\n</li>\n<li><p>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>\n</li>\n<li><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器，协商缓存会发请求到服务器。</strong></p>\n</li>\n<li><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>\n</li>\n</ol>\n<h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><h4 id=\"强缓存的原理\"><a href=\"#强缓存的原理\" class=\"headerlink\" title=\"强缓存的原理\"></a>强缓存的原理</h4><p>当浏览器对某个资源的请求命中了强缓存时，返回的 http 状态为 200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache。</p>\n<p>强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。</p>\n<p>Expires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用 GMT 格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160113231739069-2137551345.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li><p>浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；</p>\n</li>\n<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。</p>\n</li>\n<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。</p>\n</li>\n</ol>\n<blockquote>\n<p>Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。</p>\n</blockquote>\n<p>HTTP/1.1 的时候，提出了一个新的 header，就是 Cache-Control，在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：</p>\n<ul>\n<li><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</p>\n</li>\n<li><p>private：所有内容只有客户端可以缓存，Cache-Control 的默认取值</p>\n</li>\n<li><p>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</p>\n</li>\n<li><p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>\n</li>\n<li><p>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</p>\n</li>\n</ul>\n<p>它的缓存原理是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160114150736335-1224902285.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li><p>浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；</p>\n</li>\n<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>\n</li>\n<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。</p>\n</li>\n</ol>\n<blockquote>\n<p>Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。</p>\n</blockquote>\n<blockquote>\n<p>这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：</p>\n</blockquote>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160114213430210-470510830.png\" alt=\"\"></p>\n<h4 id=\"强缓存的管理\"><a href=\"#强缓存的管理\" class=\"headerlink\" title=\"强缓存的管理\"></a>强缓存的管理</h4><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有 2 种方式来设置是否启用强缓存：</p>\n<ol>\n<li><p>通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；</p>\n</li>\n<li><p>通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。</p>\n</li>\n</ol>\n<h4 id=\"强缓存的应用\"><a href=\"#强缓存的应用\" class=\"headerlink\" title=\"强缓存的应用\"></a>强缓存的应用</h4><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的 Expires 或 Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。</p>\n<p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。</p>\n<p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：</p>\n<p><a href=\"http://www.zhihu.com/question/20790576\" target=\"_blank\" rel=\"noopener\">大公司里怎样开发和部署前端代码？</a></p>\n<p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的 html 也可以看作是动态资源，如果这种 html 也被缓存，当这些 html 更新之后，可能就没有机制能够通知浏览器这些 html 有更新，尤其是前后端分离的应用里，页面都是纯 html 页面，每个访问地址可能都是直接访问 html 页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><h4 id=\"协商缓存的原理\"><a href=\"#协商缓存的原理\" class=\"headerlink\" title=\"协商缓存的原理\"></a>协商缓存的原理</h4><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串。</p>\n<p>协商缓存是利用的是<code>Last-Modified</code>、<code>If-Modified-Since</code>和<code>ETag</code>、<code>If-None-Match</code>这两对 Header 来管理的。</p>\n<p>Last-Modified、If-Modified-Since 的控制缓存的原理是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111445678-1475052015.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125438397-853706841.png\" alt=\"\"></p>\n<ol start=\"3\">\n<li>服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115111453741-1776179122.png\" alt=\"\"></p>\n<ol start=\"4\">\n<li><p>浏览器收到 304 的响应后，就会从缓存中加载资源。</p>\n</li>\n<li><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。</p>\n</li>\n</ol>\n<p>Last-Modified、If-Modified-Since 都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是<code>ETag</code>、<code>If-None-Match</code>。它们的缓存管理的方式是：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112631897-451862486.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag的值：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115112640007-97304290.png\" alt=\"\"></p>\n<ol start=\"3\">\n<li>服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：</li>\n</ol>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125439444-1024808154.png\" alt=\"\"></p>\n<ol start=\"4\">\n<li>浏览器收到 304 的响应后，就会从缓存中加载资源。</li>\n</ol>\n<h4 id=\"协商缓存的管理\"><a href=\"#协商缓存的管理\" class=\"headerlink\" title=\"协商缓存的管理\"></a>协商缓存的管理</h4><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用<code>Last-Modified</code>、<code>If-Modified-Since</code>和<code>ETag</code>、<code>If-None-Match</code>，比如 apache:</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/459873/201601/459873-20160115125440382-1079455302.png\" alt=\"\"></p>\n<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>\n<p><code>Last-Modified</code>、<code>If-Modified-Since</code>和<code>ETag</code>、<code>If-None-Match</code>一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；</p>\n<p>分布式系统尽量关闭掉 ETag(每台机器生成的ETag都会不一样）；</p>\n<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>\n<h3 id=\"浏览器的缓存存放在哪里？\"><a href=\"#浏览器的缓存存放在哪里？\" class=\"headerlink\" title=\"浏览器的缓存存放在哪里？\"></a>浏览器的缓存存放在哪里？</h3><p>缓存有两种情况：内存缓存(from memory cache)和硬盘缓存(from disk cache)</p>\n<h4 id=\"内存缓存-硬盘缓存\"><a href=\"#内存缓存-硬盘缓存\" class=\"headerlink\" title=\"内存缓存 / 硬盘缓存\"></a>内存缓存 / 硬盘缓存</h4><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</p>\n<ul>\n<li><p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p>\n</li>\n<li><p>时效性：一旦该进程关闭，则该进程的内存则会清空。</p>\n</li>\n</ul>\n<p>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p>\n<p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>\n<h3 id=\"浏览器行为对缓存的影响\"><a href=\"#浏览器行为对缓存的影响\" class=\"headerlink\" title=\"浏览器行为对缓存的影响\"></a>浏览器行为对缓存的影响</h3><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>\n<ol>\n<li><p>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>\n</li>\n<li><p>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p>\n</li>\n</ol>\n<blockquote>\n<p>参考：<br><a href=\"https://www.cnblogs.com/lyzg/p/5125934.html\" target=\"_blank\" rel=\"noopener\">浏览器缓存知识小结及应用</a><br><a href=\"https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\" target=\"_blank\" rel=\"noopener\">彻底理解浏览器的缓存机制</a></p>\n</blockquote>\n","plink":"https://vincentdou.github.io/blog/post/2018-08-03-浏览器缓存知识小结及应用/","type":"post"},{"layout":"post","title":"JavaScript 模块化七日谈","date":"2018-08-07T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> 黄玄这篇 Slides（[JavaScript Modularization Journey](https://huangxuan.me/js-module-7day)）把前端模块化的发展历程梳理的很清晰，这篇文章是对这个 Slides 的总结。\n\n### 第一日 上古时期 (MODULE?)\n\n> 从设计模式说起\n\n最早，我们这么写代码：\n\n```js\nfunction foo(){\n    //...\n}\nfunction bar(){\n    //...\n}\n```\n\n这种情况下 Global 被污染，很容易命名冲突。\n\n于是想到了进行\b简单的封装，就是 **Namespace** 模式：\n\n```js\nvar MYAPP = {\n    foo: function(){},\n    bar: function(){}\n}\n\nMYAPP.foo();\n```\n\n这种做法减少 Global 上的变量数目。\n\n但是它本质是对象，我们可以直接访问甚至更改它的内部变量，\b一点都不安全。由此就有了用匿名闭包的方式，即 **IIFE** 模式：\n\n```js\nvar Module = (function(){\n    var _private = \"safe now\";\n    var foo = function(){\n        console.log(_private)\n    }\n\n    return {\n        foo: foo\n    }\n})()\n\nModule.foo();\nModule._private; // undefined\n```\n\n再增强一点，引入依赖：\n\n```js\nvar Module = (function($){\n    var _$body = $(\"body\");     // we can use jQuery now!\n    var foo = function(){\n        console.log(_$body);    // 特权方法\n    }\n\n    // Revelation Pattern\n    return {\n        foo: foo\n    }\n})(jQuery)\n\nModule.foo();\n```\n\n这就是模块模式，也是现代模块实现的基石。\n\n### 第二日 石器时代 (SCRIPT LOADER)\n\n>只有封装性可不够，我们还需要加载\n\n回到 script 标签：\n\n```js\nbody\n    script(src=\"jquery.js\")\n    script(src=\"app.js\")    // do some $ things...\n```\n\n请求是必要发起的，加载是平行加载，DOM 顺序即执行顺序。\n\n对于一个前端项目，现实是这样的：\n\n```js\nbody\n    script(src=\"zepto.js\")\n    script(src=\"jhash.js\")\n    script(src=\"fastClick.js\")\n    script(src=\"iScroll.js\")\n    script(src=\"underscore.js\")\n    script(src=\"handlebar.js\")\n    script(src=\"datacenter.js\")\n    script(src=\"deferred.js\")\n    script(src=\"util/wxbridge.js\")\n    script(src=\"util/login.js\")\n    script(src=\"util/base.js\")\n    script(src=\"util/city.js\")\n    script(src=\"util/date.js\")\n    script(src=\"util/cookie.js\")\n    script(src=\"app.js\")\n```\n\n这就引发了难以维护、依赖模糊、请求过多的问题。\n\n#### [LABjs](http://labjs.com/)\n\n```js\nscript(src=\"LAB.js\")\n```\n\n```js\n$LAB.script(\"framework.js\").wait()\n    .script(\"plugin.framework.js\")\n    .script(\"myplugin.framework.js\").wait()\n    .script(\"init.js\");\n```\n\n.wait()方法表示立即运行刚才加载的Javascript文件\n\n语法糖：\n\n```js\n$LAB\n.script( [ \"script1.js\", \"script2.js\", \"script3.js\"] )\n.wait(function(){ // wait for all scripts to execute first\n    script1Func();\n    script2Func();\n    script3Func();\n});\n```\n\n*基于文件的依赖管理*\n\n### 第三日 蒸汽朋克 (MODULE LOADER)\n\n> 模块化架构的工业革命\n\n#### [YUI3](https://huangxuan.me/js-module-7day/yuilibrary.com) Loader\n\n回顾昔日王者的风采：\n\n```js\n// YUI - 编写模块\nYUI.add('dom', function(Y) {\n  Y.DOM = { ... }\n})\n\n// YUI - 使用模块\nYUI().use('dom', function(Y) {\n  Y.DOM.doSomeThing();\n  // use some methods DOM attach to Y\n})\n```\n\n编写常用模块：\n\n```js\n// hello.js\nYUI.add('hello', function(Y){\n    Y.sayHello = function(msg){\n        Y.DOM.set(el, 'innerHTML', 'Hello!');\n    }\n},'3.0.0',{\n    requires:['dom']\n})\n```\n\n```js\n// main.js\nYUI().use('hello', function(Y){\n    Y.sayHello(\"hey yui loader\");\n})\n```\n\n*基于模块的依赖管理*\n\n更深一步：\n\n```js\n// Sandbox Implementation\nfunction Sandbox() {\n    // ...\n    // initialize the required modules\n    for (i = 0; i < modules.length; i += 1) {\n        Sandbox.modules[modules[i]](this);\n    }\n    // ...\n}\n```\n\nY 其实是一个强沙箱，所有依赖模块通过 attach 的方式被注入沙盒。\n\n> attach：在当前 YUI 实例上执行模块的初始化代码，使得模块在当前实例上可用\n\nYUI Combo 可以解决过多网络请求的问题：\n\n```js\nscript(src=\"http://yui.yahooapis.com/3.0.0/build/yui/yui-min.js\")\nscript(src=\"http://yui.yahooapis.com/3.0.0/build/dom/dom-min.js\")\n```\n\n上面的情况可以写成：\n\n```js\nscript(src=\"http://yui.yahooapis.com/combo?\n    3.0.0/build/yui/yui-min.js&\n    3.0.0/build/dom/dom-min.js\")\n```\n\n这样就能在一次请求中拿到多个资源\n\n*GET 请求，需要服务器支持*\n\n### 第四日 号角吹响 (COMMONJS)\n\n> 征服世界的第一步是跳出浏览器\n\n#### [CommonJS](http://www.commonjs.org/) - API Standard\n\nCommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。\n\n**Modules/1.x**\n\n模块的定义与引用：\n\n```js\n// math.js\nexports.add = function(a, b){\n    return a + b;\n}\n```\n\n```js\n// main.js\nvar math = require('math')      // ./math in node\nconsole.log(math.add(1, 2));    // 3\n```\n\nCommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步/阻塞式加载的机制：\n\n```js\n// timeout.js\nvar EXE_TIME = 2;\n\n(function(second){\n    var start = +new Date();\n    while(start + second*1000 > new Date()){}\n})(EXE_TIME)\n\nconsole.log(\"2000ms executed\")\n```\n\n```js\n// main.js\nrequire('./timeout');   // sync load\nconsole.log('done!');\n```\n\n这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n### 第五日 双塔奇兵 (AMD/CMD)\n\n> 浏览器环境模块化方案\n\n在 CommonJS 推广到浏览器的过程中，关于 Modules 的下一版规范，形成了三大流派：\n\n1. Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。\n2. Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。\n3. Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了。\n\n#### [RequireJS](http://requirejs.org/) & AMD\n\nAMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器这个问题：\n\n```js\n//CommonJS\n\nvar Employee = require(\"types/Employee\");\n\nfunction Programmer (){\n    //do something\n}  \n\nProgrammer.prototype = new Employee();\n\n//如果 require call 是异步的，那么肯定 error\n//因为在执行这句前 Employee 模块肯定来不及加载进来\n```\n\n所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来\n\n```js\n//AMD Wrapper\n\ndefine(\n    [types/Employee],    //依赖\n    function(Employee){  //这个回调会在所有依赖都被加载后才执行\n\n        function Programmer(){\n            //do something\n        };\n\n        Programmer.prototype = new Employee();\n        return Programmer;  //return Constructor\n    }\n)\n```\n\n当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\nAMD 和 CommonJS 的核心争议包括执行时机和书写风格：\n\n**执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是提前执行，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n**书写风格**\n\nAMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n#### [SeaJS](https://seajs.github.io/seajs/docs/) & CMD\n\nCMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\nCMD 主要有 define, factory, require, export 这么几个东西：\n\n- define `define(id?, deps?, factory)`\n- factory `factory(require, exports, module)`\n- require `require(id)`\n- exports `Object`\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 require：\n\n这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n#### AMD vs CMD\n\n虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：\n\n对于依赖的模块，AMD 是提前执行，CMD 是懒执行；CMD 推崇依赖就近，AMD 推崇依赖前置。（都是先加载）\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n### 第六日 精灵宝钻 (BROWSERIFY/WEBPACK)\n\n> 大势所趋，去掉这层包裹！\n\n#### [Browserify](http://browserify.org/) - CommonJS In Browser\n\nBrowserify 是一个 node.js 模块，主要用于改写现有的 CommonJS 模块，使得浏览器端也可以使用这些模块。\n\n举个例子，假定有一个很简单的CommonJS模块文件foo.js：\n\n```js\n// foo.js\n\nmodule.exports = function(x) {\n  console.log(x);\n};\n```\n\n然后，还有一个main.js文件，用来加载foo模块：\n\n```js\n// main.js\n\nvar foo = require(\"./foo\");\nfoo(\"Hi\");\n```\n\n使用Browserify，将main.js转化为浏览器可以加载的脚本compiled.js。\n\n```shell\nbrowserify main.js -o compiled.js\n```\n\n转化后的文件不仅包括了main.js，还包括了它所依赖的foo.js。两者打包在一起，保证浏览器加载时的依赖关系。\n\n```html\n<script src=\"compiled.js\"></script>\n```\n\n使用上面的命令，在浏览器中运行 compiled.js，控制台会显示Hi。\n\n利用 [Watchify](https://www.npmjs.com/package/watchify) 可以做到 auto-recompile：\n\n```shell\n$ npm install -g watchify\n```\n\n```shell\n# WATCH!\n$ watchify app.js -o bundle.js -v\n```\n\n#### [Webpack](https://www.webpackjs.com/) - Module Bundler\n\nwebpack 是一个模块打包器，webpack 的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用。\n\nwebpack 功能十分强大，除了打包 JS 还能对静态资源、css 文件等进行处理，另外还有插件系统、\b代码分割\b等功能。\n\n### 第七日 王者归来 (ES6 MODULE)\n\n> 最后的战役\n\n在 ES6 之后终于有了 Module\n\n只有一个 default 的情况：\n\n```js\n// math.js\nexport default math = {\n    PI: 3.14,\n    foo: function(){}\n}\n```\n\n```js\n// app.js\nimport math from \"./math\";\nmath.PI\n```\n\n命名 export：\n\n```js\n// export Declaration\nexport function foo(){\n    console.log('I am not bar.');\n}\n```\n\n```js\n// export VariableStatement;\nexport var PI = 3.14;\nexport var bar = foo;   // function expression\n```\n\n```js\n// export { ExportsList }\nvar PI = 3.14;\nvar foo = function(){};\n\nexport { PI, foo };\n```\n\n引入命名的 export：\n\n```js\n// import { ImportsList } from \"module-name\"\nimport { PI } from \"./math\";\nimport { PI, foo } from \"module-name\";\n```\n\n```js\n// import IdentifierName as ImportedBinding\nimport { foo as bar } from \"./math\";\nbar();  // use alias bar\n```\n\n```js\n// import NameSpaceImport\nimport * as math from \"./math\";\nmath.PI\nmath.foo()\n```\n\n#### [babel](https://babeljs.io/)\n\nBabel 是一个 JavaScript 编译器，它让我们现在就可以使用下一代 JavaScript 语法。\n\n> 参考：\n> [前端模块的历史沿革](https://www.cyj.me/programming/2018/05/22/about-module-i/)\n> [前端模块的现状](https://www.cyj.me/programming/2018/05/23/about-module-ii/)\n","source":"_posts/2018-08-08-JavaScript模块化七日谈.markdown","raw":"---\nlayout:     post\ntitle:      \"JavaScript 模块化七日谈\"\ndate:       2018-08-08\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - 前端模块化\n---\n\n> 黄玄这篇 Slides（[JavaScript Modularization Journey](https://huangxuan.me/js-module-7day)）把前端模块化的发展历程梳理的很清晰，这篇文章是对这个 Slides 的总结。\n\n### 第一日 上古时期 (MODULE?)\n\n> 从设计模式说起\n\n最早，我们这么写代码：\n\n```js\nfunction foo(){\n    //...\n}\nfunction bar(){\n    //...\n}\n```\n\n这种情况下 Global 被污染，很容易命名冲突。\n\n于是想到了进行\b简单的封装，就是 **Namespace** 模式：\n\n```js\nvar MYAPP = {\n    foo: function(){},\n    bar: function(){}\n}\n\nMYAPP.foo();\n```\n\n这种做法减少 Global 上的变量数目。\n\n但是它本质是对象，我们可以直接访问甚至更改它的内部变量，\b一点都不安全。由此就有了用匿名闭包的方式，即 **IIFE** 模式：\n\n```js\nvar Module = (function(){\n    var _private = \"safe now\";\n    var foo = function(){\n        console.log(_private)\n    }\n\n    return {\n        foo: foo\n    }\n})()\n\nModule.foo();\nModule._private; // undefined\n```\n\n再增强一点，引入依赖：\n\n```js\nvar Module = (function($){\n    var _$body = $(\"body\");     // we can use jQuery now!\n    var foo = function(){\n        console.log(_$body);    // 特权方法\n    }\n\n    // Revelation Pattern\n    return {\n        foo: foo\n    }\n})(jQuery)\n\nModule.foo();\n```\n\n这就是模块模式，也是现代模块实现的基石。\n\n### 第二日 石器时代 (SCRIPT LOADER)\n\n>只有封装性可不够，我们还需要加载\n\n回到 script 标签：\n\n```js\nbody\n    script(src=\"jquery.js\")\n    script(src=\"app.js\")    // do some $ things...\n```\n\n请求是必要发起的，加载是平行加载，DOM 顺序即执行顺序。\n\n对于一个前端项目，现实是这样的：\n\n```js\nbody\n    script(src=\"zepto.js\")\n    script(src=\"jhash.js\")\n    script(src=\"fastClick.js\")\n    script(src=\"iScroll.js\")\n    script(src=\"underscore.js\")\n    script(src=\"handlebar.js\")\n    script(src=\"datacenter.js\")\n    script(src=\"deferred.js\")\n    script(src=\"util/wxbridge.js\")\n    script(src=\"util/login.js\")\n    script(src=\"util/base.js\")\n    script(src=\"util/city.js\")\n    script(src=\"util/date.js\")\n    script(src=\"util/cookie.js\")\n    script(src=\"app.js\")\n```\n\n这就引发了难以维护、依赖模糊、请求过多的问题。\n\n#### [LABjs](http://labjs.com/)\n\n```js\nscript(src=\"LAB.js\")\n```\n\n```js\n$LAB.script(\"framework.js\").wait()\n    .script(\"plugin.framework.js\")\n    .script(\"myplugin.framework.js\").wait()\n    .script(\"init.js\");\n```\n\n.wait()方法表示立即运行刚才加载的Javascript文件\n\n语法糖：\n\n```js\n$LAB\n.script( [ \"script1.js\", \"script2.js\", \"script3.js\"] )\n.wait(function(){ // wait for all scripts to execute first\n    script1Func();\n    script2Func();\n    script3Func();\n});\n```\n\n*基于文件的依赖管理*\n\n### 第三日 蒸汽朋克 (MODULE LOADER)\n\n> 模块化架构的工业革命\n\n#### [YUI3](https://huangxuan.me/js-module-7day/yuilibrary.com) Loader\n\n回顾昔日王者的风采：\n\n```js\n// YUI - 编写模块\nYUI.add('dom', function(Y) {\n  Y.DOM = { ... }\n})\n\n// YUI - 使用模块\nYUI().use('dom', function(Y) {\n  Y.DOM.doSomeThing();\n  // use some methods DOM attach to Y\n})\n```\n\n编写常用模块：\n\n```js\n// hello.js\nYUI.add('hello', function(Y){\n    Y.sayHello = function(msg){\n        Y.DOM.set(el, 'innerHTML', 'Hello!');\n    }\n},'3.0.0',{\n    requires:['dom']\n})\n```\n\n```js\n// main.js\nYUI().use('hello', function(Y){\n    Y.sayHello(\"hey yui loader\");\n})\n```\n\n*基于模块的依赖管理*\n\n更深一步：\n\n```js\n// Sandbox Implementation\nfunction Sandbox() {\n    // ...\n    // initialize the required modules\n    for (i = 0; i < modules.length; i += 1) {\n        Sandbox.modules[modules[i]](this);\n    }\n    // ...\n}\n```\n\nY 其实是一个强沙箱，所有依赖模块通过 attach 的方式被注入沙盒。\n\n> attach：在当前 YUI 实例上执行模块的初始化代码，使得模块在当前实例上可用\n\nYUI Combo 可以解决过多网络请求的问题：\n\n```js\nscript(src=\"http://yui.yahooapis.com/3.0.0/build/yui/yui-min.js\")\nscript(src=\"http://yui.yahooapis.com/3.0.0/build/dom/dom-min.js\")\n```\n\n上面的情况可以写成：\n\n```js\nscript(src=\"http://yui.yahooapis.com/combo?\n    3.0.0/build/yui/yui-min.js&\n    3.0.0/build/dom/dom-min.js\")\n```\n\n这样就能在一次请求中拿到多个资源\n\n*GET 请求，需要服务器支持*\n\n### 第四日 号角吹响 (COMMONJS)\n\n> 征服世界的第一步是跳出浏览器\n\n#### [CommonJS](http://www.commonjs.org/) - API Standard\n\nCommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。\n\n**Modules/1.x**\n\n模块的定义与引用：\n\n```js\n// math.js\nexports.add = function(a, b){\n    return a + b;\n}\n```\n\n```js\n// main.js\nvar math = require('math')      // ./math in node\nconsole.log(math.add(1, 2));    // 3\n```\n\nCommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步/阻塞式加载的机制：\n\n```js\n// timeout.js\nvar EXE_TIME = 2;\n\n(function(second){\n    var start = +new Date();\n    while(start + second*1000 > new Date()){}\n})(EXE_TIME)\n\nconsole.log(\"2000ms executed\")\n```\n\n```js\n// main.js\nrequire('./timeout');   // sync load\nconsole.log('done!');\n```\n\n这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n### 第五日 双塔奇兵 (AMD/CMD)\n\n> 浏览器环境模块化方案\n\n在 CommonJS 推广到浏览器的过程中，关于 Modules 的下一版规范，形成了三大流派：\n\n1. Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。\n2. Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。\n3. Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了。\n\n#### [RequireJS](http://requirejs.org/) & AMD\n\nAMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器这个问题：\n\n```js\n//CommonJS\n\nvar Employee = require(\"types/Employee\");\n\nfunction Programmer (){\n    //do something\n}  \n\nProgrammer.prototype = new Employee();\n\n//如果 require call 是异步的，那么肯定 error\n//因为在执行这句前 Employee 模块肯定来不及加载进来\n```\n\n所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来\n\n```js\n//AMD Wrapper\n\ndefine(\n    [types/Employee],    //依赖\n    function(Employee){  //这个回调会在所有依赖都被加载后才执行\n\n        function Programmer(){\n            //do something\n        };\n\n        Programmer.prototype = new Employee();\n        return Programmer;  //return Constructor\n    }\n)\n```\n\n当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\nAMD 和 CommonJS 的核心争议包括执行时机和书写风格：\n\n**执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是提前执行，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n**书写风格**\n\nAMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n#### [SeaJS](https://seajs.github.io/seajs/docs/) & CMD\n\nCMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\nCMD 主要有 define, factory, require, export 这么几个东西：\n\n- define `define(id?, deps?, factory)`\n- factory `factory(require, exports, module)`\n- require `require(id)`\n- exports `Object`\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 require：\n\n这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n#### AMD vs CMD\n\n虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：\n\n对于依赖的模块，AMD 是提前执行，CMD 是懒执行；CMD 推崇依赖就近，AMD 推崇依赖前置。（都是先加载）\n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n### 第六日 精灵宝钻 (BROWSERIFY/WEBPACK)\n\n> 大势所趋，去掉这层包裹！\n\n#### [Browserify](http://browserify.org/) - CommonJS In Browser\n\nBrowserify 是一个 node.js 模块，主要用于改写现有的 CommonJS 模块，使得浏览器端也可以使用这些模块。\n\n举个例子，假定有一个很简单的CommonJS模块文件foo.js：\n\n```js\n// foo.js\n\nmodule.exports = function(x) {\n  console.log(x);\n};\n```\n\n然后，还有一个main.js文件，用来加载foo模块：\n\n```js\n// main.js\n\nvar foo = require(\"./foo\");\nfoo(\"Hi\");\n```\n\n使用Browserify，将main.js转化为浏览器可以加载的脚本compiled.js。\n\n```shell\nbrowserify main.js -o compiled.js\n```\n\n转化后的文件不仅包括了main.js，还包括了它所依赖的foo.js。两者打包在一起，保证浏览器加载时的依赖关系。\n\n```html\n<script src=\"compiled.js\"></script>\n```\n\n使用上面的命令，在浏览器中运行 compiled.js，控制台会显示Hi。\n\n利用 [Watchify](https://www.npmjs.com/package/watchify) 可以做到 auto-recompile：\n\n```shell\n$ npm install -g watchify\n```\n\n```shell\n# WATCH!\n$ watchify app.js -o bundle.js -v\n```\n\n#### [Webpack](https://www.webpackjs.com/) - Module Bundler\n\nwebpack 是一个模块打包器，webpack 的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用。\n\nwebpack 功能十分强大，除了打包 JS 还能对静态资源、css 文件等进行处理，另外还有插件系统、\b代码分割\b等功能。\n\n### 第七日 王者归来 (ES6 MODULE)\n\n> 最后的战役\n\n在 ES6 之后终于有了 Module\n\n只有一个 default 的情况：\n\n```js\n// math.js\nexport default math = {\n    PI: 3.14,\n    foo: function(){}\n}\n```\n\n```js\n// app.js\nimport math from \"./math\";\nmath.PI\n```\n\n命名 export：\n\n```js\n// export Declaration\nexport function foo(){\n    console.log('I am not bar.');\n}\n```\n\n```js\n// export VariableStatement;\nexport var PI = 3.14;\nexport var bar = foo;   // function expression\n```\n\n```js\n// export { ExportsList }\nvar PI = 3.14;\nvar foo = function(){};\n\nexport { PI, foo };\n```\n\n引入命名的 export：\n\n```js\n// import { ImportsList } from \"module-name\"\nimport { PI } from \"./math\";\nimport { PI, foo } from \"module-name\";\n```\n\n```js\n// import IdentifierName as ImportedBinding\nimport { foo as bar } from \"./math\";\nbar();  // use alias bar\n```\n\n```js\n// import NameSpaceImport\nimport * as math from \"./math\";\nmath.PI\nmath.foo()\n```\n\n#### [babel](https://babeljs.io/)\n\nBabel 是一个 JavaScript 编译器，它让我们现在就可以使用下一代 JavaScript 语法。\n\n> 参考：\n> [前端模块的历史沿革](https://www.cyj.me/programming/2018/05/22/about-module-i/)\n> [前端模块的现状](https://www.cyj.me/programming/2018/05/23/about-module-ii/)\n","slug":"2018-08-08-JavaScript模块化七日谈","published":1,"updated":"2019-01-02T08:49:00.266Z","comments":0,"photos":[],"link":"post/2018-08-08-JavaScript模块化七日谈","_id":"cjz2epjfh0018n3w5vvxno4ul","content":"<blockquote>\n<p>黄玄这篇 Slides（<a href=\"https://huangxuan.me/js-module-7day\" target=\"_blank\" rel=\"noopener\">JavaScript Modularization Journey</a>）把前端模块化的发展历程梳理的很清晰，这篇文章是对这个 Slides 的总结。</p>\n</blockquote>\n<h3 id=\"第一日-上古时期-MODULE\">第一日 上古时期 (MODULE?)<a href=\"post/2018-08-08-JavaScript模块化七日谈#第一日-上古时期-MODULE\"></a></h3><blockquote>\n<p>从设计模式说起</p>\n</blockquote>\n<p>最早，我们这么写代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这种情况下 Global 被污染，很容易命名冲突。</p>\n<p>于是想到了进行\b简单的封装，就是 <strong>Namespace</strong> 模式：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MYAPP = &#123;</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MYAPP.foo();</span><br></pre></td></tr></table></div></figure>\n<p>这种做法减少 Global 上的变量数目。</p>\n<p>但是它本质是对象，我们可以直接访问甚至更改它的内部变量，\b一点都不安全。由此就有了用匿名闭包的方式，即 <strong>IIFE</strong> 模式：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Module = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _private = <span class=\"string\">\"safe now\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(_private)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        foo: foo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">Module.foo();</span><br><span class=\"line\">Module._private; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></div></figure>\n<p>再增强一点，引入依赖：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Module = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _$body = $(<span class=\"string\">\"body\"</span>);     <span class=\"comment\">// we can use jQuery now!</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(_$body);    <span class=\"comment\">// 特权方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Revelation Pattern</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        foo: foo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(jQuery)</span><br><span class=\"line\"></span><br><span class=\"line\">Module.foo();</span><br></pre></td></tr></table></div></figure>\n<p>这就是模块模式，也是现代模块实现的基石。</p>\n<h3 id=\"第二日-石器时代-SCRIPT-LOADER\">第二日 石器时代 (SCRIPT LOADER)<a href=\"post/2018-08-08-JavaScript模块化七日谈#第二日-石器时代-SCRIPT-LOADER\"></a></h3><blockquote>\n<p>只有封装性可不够，我们还需要加载</p>\n</blockquote>\n<p>回到 script 标签：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body</span><br><span class=\"line\">    script(src=<span class=\"string\">\"jquery.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"app.js\"</span>)    <span class=\"comment\">// do some $ things...</span></span><br></pre></td></tr></table></div></figure>\n<p>请求是必要发起的，加载是平行加载，DOM 顺序即执行顺序。</p>\n<p>对于一个前端项目，现实是这样的：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body</span><br><span class=\"line\">    script(src=<span class=\"string\">\"zepto.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"jhash.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"fastClick.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"iScroll.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"underscore.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"handlebar.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"datacenter.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"deferred.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/wxbridge.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/login.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/base.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/city.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/date.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/cookie.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"app.js\"</span>)</span><br></pre></td></tr></table></div></figure>\n<p>这就引发了难以维护、依赖模糊、请求过多的问题。</p>\n<h4 id=\"LABjs\"><a href=\"http://labjs.com/\" target=\"_blank\" rel=\"noopener\">LABjs</a><a href=\"post/2018-08-08-JavaScript模块化七日谈#LABjs\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script(src=<span class=\"string\">\"LAB.js\"</span>)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$LAB.script(<span class=\"string\">\"framework.js\"</span>).wait()</span><br><span class=\"line\">    .script(<span class=\"string\">\"plugin.framework.js\"</span>)</span><br><span class=\"line\">    .script(<span class=\"string\">\"myplugin.framework.js\"</span>).wait()</span><br><span class=\"line\">    .script(<span class=\"string\">\"init.js\"</span>);</span><br></pre></td></tr></table></div></figure>\n<p>.wait()方法表示立即运行刚才加载的Javascript文件</p>\n<p>语法糖：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$LAB</span><br><span class=\"line\">.script( [ <span class=\"string\">\"script1.js\"</span>, <span class=\"string\">\"script2.js\"</span>, <span class=\"string\">\"script3.js\"</span>] )</span><br><span class=\"line\">.wait(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// wait for all scripts to execute first</span></span><br><span class=\"line\">    script1Func();</span><br><span class=\"line\">    script2Func();</span><br><span class=\"line\">    script3Func();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p><em>基于文件的依赖管理</em></p>\n<h3 id=\"第三日-蒸汽朋克-MODULE-LOADER\">第三日 蒸汽朋克 (MODULE LOADER)<a href=\"post/2018-08-08-JavaScript模块化七日谈#第三日-蒸汽朋克-MODULE-LOADER\"></a></h3><blockquote>\n<p>模块化架构的工业革命</p>\n</blockquote>\n<h4 id=\"YUI3-Loader\"><a href=\"https://huangxuan.me/js-module-7day/yuilibrary.com\" target=\"_blank\" rel=\"noopener\">YUI3</a> Loader<a href=\"post/2018-08-08-JavaScript模块化七日谈#YUI3-Loader\"></a></h4><p>回顾昔日王者的风采：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// YUI - 编写模块</span></span><br><span class=\"line\">YUI.add(<span class=\"string\">'dom'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">  Y.DOM = &#123; ... &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// YUI - 使用模块</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">'dom'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">  Y.DOM.doSomeThing();</span><br><span class=\"line\">  <span class=\"comment\">// use some methods DOM attach to Y</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>编写常用模块：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.js</span></span><br><span class=\"line\">YUI.add(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>)</span>&#123;</span><br><span class=\"line\">    Y.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">        Y.DOM.set(el, <span class=\"string\">'innerHTML'</span>, <span class=\"string\">'Hello!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,<span class=\"string\">'3.0.0'</span>,&#123;</span><br><span class=\"line\">    requires:[<span class=\"string\">'dom'</span>]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>)</span>&#123;</span><br><span class=\"line\">    Y.sayHello(<span class=\"string\">\"hey yui loader\"</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p><em>基于模块的依赖管理</em></p>\n<p>更深一步：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sandbox Implementation</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sandbox</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize the required modules</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; modules.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        Sandbox.modules[modules[i]](<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Y 其实是一个强沙箱，所有依赖模块通过 attach 的方式被注入沙盒。</p>\n<blockquote>\n<p>attach：在当前 YUI 实例上执行模块的初始化代码，使得模块在当前实例上可用</p>\n</blockquote>\n<p>YUI Combo 可以解决过多网络请求的问题：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script(src=<span class=\"string\">\"http://yui.yahooapis.com/3.0.0/build/yui/yui-min.js\"</span>)</span><br><span class=\"line\">script(src=<span class=\"string\">\"http://yui.yahooapis.com/3.0.0/build/dom/dom-min.js\"</span>)</span><br></pre></td></tr></table></div></figure>\n<p>上面的情况可以写成：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script(src=<span class=\"string\">\"http://yui.yahooapis.com/combo?</span></span><br><span class=\"line\"><span class=\"string\">    3.0.0/build/yui/yui-min.js&amp;</span></span><br><span class=\"line\"><span class=\"string\">    3.0.0/build/dom/dom-min.js\"</span>)</span><br></pre></td></tr></table></div></figure>\n<p>这样就能在一次请求中拿到多个资源</p>\n<p><em>GET 请求，需要服务器支持</em></p>\n<h3 id=\"第四日-号角吹响-COMMONJS\">第四日 号角吹响 (COMMONJS)<a href=\"post/2018-08-08-JavaScript模块化七日谈#第四日-号角吹响-COMMONJS\"></a></h3><blockquote>\n<p>征服世界的第一步是跳出浏览器</p>\n</blockquote>\n<h4 id=\"CommonJS-API-Standard\"><a href=\"http://www.commonjs.org/\" target=\"_blank\" rel=\"noopener\">CommonJS</a> - API Standard<a href=\"post/2018-08-08-JavaScript模块化七日谈#CommonJS-API-Standard\"></a></h4><p>CommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。</p>\n<p><strong>Modules/1.x</strong></p>\n<p>模块的定义与引用：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\">exports.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'math'</span>)      <span class=\"comment\">// ./math in node</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(math.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>));    <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></div></figure>\n<p>CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步/阻塞式加载的机制：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// timeout.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EXE_TIME = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">second</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start + second*<span class=\"number\">1000</span> &gt; <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())&#123;&#125;</span><br><span class=\"line\">&#125;)(EXE_TIME)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2000ms executed\"</span>)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./timeout'</span>);   <span class=\"comment\">// sync load</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'done!'</span>);</span><br></pre></td></tr></table></div></figure>\n<p>这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<h3 id=\"第五日-双塔奇兵-AMD-CMD\">第五日 双塔奇兵 (AMD/CMD)<a href=\"post/2018-08-08-JavaScript模块化七日谈#第五日-双塔奇兵-AMD-CMD\"></a></h3><blockquote>\n<p>浏览器环境模块化方案</p>\n</blockquote>\n<p>在 CommonJS 推广到浏览器的过程中，关于 Modules 的下一版规范，形成了三大流派：</p>\n<ol>\n<li>Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。</li>\n<li>Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。</li>\n<li>Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了。</li>\n</ol>\n<h4 id=\"RequireJS-amp-AMD\"><a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">RequireJS</a> &amp; AMD<a href=\"post/2018-08-08-JavaScript模块化七日谈#RequireJS-amp-AMD\"></a></h4><p>AMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器这个问题：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//CommonJS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Employee = <span class=\"built_in\">require</span>(<span class=\"string\">\"types/Employee\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Programmer</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">Programmer.prototype = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果 require call 是异步的，那么肯定 error</span></span><br><span class=\"line\"><span class=\"comment\">//因为在执行这句前 Employee 模块肯定来不及加载进来</span></span><br></pre></td></tr></table></div></figure>\n<p>所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AMD Wrapper</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(</span><br><span class=\"line\">    [types/Employee],    <span class=\"comment\">//依赖</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Employee</span>)</span>&#123;  <span class=\"comment\">//这个回调会在所有依赖都被加载后才执行</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Programmer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//do something</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        Programmer.prototype = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Programmer;  <span class=\"comment\">//return Constructor</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n<p>当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</span><br><span class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p>AMD 和 CommonJS 的核心争议包括执行时机和书写风格：</p>\n<p><strong>执行时机</strong></p>\n<p>Modules/1.0:</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></span><br></pre></td></tr></table></div></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是提前执行，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<p><strong>书写风格</strong></p>\n<p>AMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"SeaJS-amp-CMD\"><a href=\"https://seajs.github.io/seajs/docs/\" target=\"_blank\" rel=\"noopener\">SeaJS</a> &amp; CMD<a href=\"post/2018-08-08-JavaScript模块化七日谈#SeaJS-amp-CMD\"></a></h4><p>CMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>CMD 主要有 define, factory, require, export 这么几个东西：</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 require：</p>\n<p>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></span><br><span class=\"line\">    a.doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></span><br><span class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></span><br><span class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模块代码...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        foo: <span class=\"string\">'bar'</span>,</span><br><span class=\"line\">        doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h4 id=\"AMD-vs-CMD\">AMD vs CMD<a href=\"post/2018-08-08-JavaScript模块化七日谈#AMD-vs-CMD\"></a></h4><p>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</p>\n<p>对于依赖的模块，AMD 是提前执行，CMD 是懒执行；CMD 推崇依赖就近，AMD 推崇依赖前置。（都是先加载）</p>\n<p>看代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></span><br><span class=\"line\"></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"第六日-精灵宝钻-BROWSERIFY-WEBPACK\">第六日 精灵宝钻 (BROWSERIFY/WEBPACK)<a href=\"post/2018-08-08-JavaScript模块化七日谈#第六日-精灵宝钻-BROWSERIFY-WEBPACK\"></a></h3><blockquote>\n<p>大势所趋，去掉这层包裹！</p>\n</blockquote>\n<h4 id=\"Browserify-CommonJS-In-Browser\"><a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a> - CommonJS In Browser<a href=\"post/2018-08-08-JavaScript模块化七日谈#Browserify-CommonJS-In-Browser\"></a></h4><p>Browserify 是一个 node.js 模块，主要用于改写现有的 CommonJS 模块，使得浏览器端也可以使用这些模块。</p>\n<p>举个例子，假定有一个很简单的CommonJS模块文件foo.js：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// foo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<p>然后，还有一个main.js文件，用来加载foo模块：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">\"./foo\"</span>);</span><br><span class=\"line\">foo(<span class=\"string\">\"Hi\"</span>);</span><br></pre></td></tr></table></div></figure>\n<p>使用Browserify，将main.js转化为浏览器可以加载的脚本compiled.js。</p>\n<figure class=\"highlight shell\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browserify main.js -o compiled.js</span><br></pre></td></tr></table></div></figure>\n<p>转化后的文件不仅包括了main.js，还包括了它所依赖的foo.js。两者打包在一起，保证浏览器加载时的依赖关系。</p>\n<figure class=\"highlight html\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"compiled.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></div></figure>\n<p>使用上面的命令，在浏览器中运行 compiled.js，控制台会显示Hi。</p>\n<p>利用 <a href=\"https://www.npmjs.com/package/watchify\" target=\"_blank\" rel=\"noopener\">Watchify</a> 可以做到 auto-recompile：</p>\n<figure class=\"highlight shell\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install -g watchify</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight shell\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> WATCH!</span><br><span class=\"line\"><span class=\"meta\">$</span> watchify app.js -o bundle.js -v</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"Webpack-Module-Bundler\"><a href=\"https://www.webpackjs.com/\" target=\"_blank\" rel=\"noopener\">Webpack</a> - Module Bundler<a href=\"post/2018-08-08-JavaScript模块化七日谈#Webpack-Module-Bundler\"></a></h4><p>webpack 是一个模块打包器，webpack 的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用。</p>\n<p>webpack 功能十分强大，除了打包 JS 还能对静态资源、css 文件等进行处理，另外还有插件系统、\b代码分割\b等功能。</p>\n<h3 id=\"第七日-王者归来-ES6-MODULE\">第七日 王者归来 (ES6 MODULE)<a href=\"post/2018-08-08-JavaScript模块化七日谈#第七日-王者归来-ES6-MODULE\"></a></h3><blockquote>\n<p>最后的战役</p>\n</blockquote>\n<p>在 ES6 之后终于有了 Module</p>\n<p>只有一个 default 的情况：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> math = &#123;</span><br><span class=\"line\">    PI: <span class=\"number\">3.14</span>,</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> math <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\">math.PI</span><br></pre></td></tr></table></div></figure>\n<p>命名 export：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export Declaration</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am not bar.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export VariableStatement;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> PI = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> bar = foo;   <span class=\"comment\">// function expression</span></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export &#123; ExportsList &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> PI = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; PI, foo &#125;;</span><br></pre></td></tr></table></div></figure>\n<p>引入命名的 export：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import &#123; ImportsList &#125; from \"module-name\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; PI &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; PI, foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"module-name\"</span>;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import IdentifierName as ImportedBinding</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; foo <span class=\"keyword\">as</span> bar &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\">bar();  <span class=\"comment\">// use alias bar</span></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import NameSpaceImport</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> math <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\">math.PI</span><br><span class=\"line\">math.foo()</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"babel\"><a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">babel</a><a href=\"post/2018-08-08-JavaScript模块化七日谈#babel\"></a></h4><p>Babel 是一个 JavaScript 编译器，它让我们现在就可以使用下一代 JavaScript 语法。</p>\n<blockquote>\n<p>参考：<br><a href=\"https://www.cyj.me/programming/2018/05/22/about-module-i/\" target=\"_blank\" rel=\"noopener\">前端模块的历史沿革</a><br><a href=\"https://www.cyj.me/programming/2018/05/23/about-module-ii/\" target=\"_blank\" rel=\"noopener\">前端模块的现状</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>黄玄这篇 Slides（<a href=\"https://huangxuan.me/js-module-7day\" target=\"_blank\" rel=\"noopener\">JavaScript Modularization Journey</a>）把前端模块化的发展历程梳理的很清晰，这篇文章是对这个 Slides 的总结。</p>\n</blockquote>\n<h3 id=\"第一日-上古时期-MODULE\"><a href=\"#第一日-上古时期-MODULE\" class=\"headerlink\" title=\"第一日 上古时期 (MODULE?)\"></a>第一日 上古时期 (MODULE?)</h3><blockquote>\n<p>从设计模式说起</p>\n</blockquote>\n<p>最早，我们这么写代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下 Global 被污染，很容易命名冲突。</p>\n<p>于是想到了进行\b简单的封装，就是 <strong>Namespace</strong> 模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MYAPP = &#123;</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MYAPP.foo();</span><br></pre></td></tr></table></figure>\n<p>这种做法减少 Global 上的变量数目。</p>\n<p>但是它本质是对象，我们可以直接访问甚至更改它的内部变量，\b一点都不安全。由此就有了用匿名闭包的方式，即 <strong>IIFE</strong> 模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Module = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _private = <span class=\"string\">\"safe now\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(_private)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        foo: foo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">Module.foo();</span><br><span class=\"line\">Module._private; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>再增强一点，引入依赖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Module = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _$body = $(<span class=\"string\">\"body\"</span>);     <span class=\"comment\">// we can use jQuery now!</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(_$body);    <span class=\"comment\">// 特权方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Revelation Pattern</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        foo: foo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(jQuery)</span><br><span class=\"line\"></span><br><span class=\"line\">Module.foo();</span><br></pre></td></tr></table></figure>\n<p>这就是模块模式，也是现代模块实现的基石。</p>\n<h3 id=\"第二日-石器时代-SCRIPT-LOADER\"><a href=\"#第二日-石器时代-SCRIPT-LOADER\" class=\"headerlink\" title=\"第二日 石器时代 (SCRIPT LOADER)\"></a>第二日 石器时代 (SCRIPT LOADER)</h3><blockquote>\n<p>只有封装性可不够，我们还需要加载</p>\n</blockquote>\n<p>回到 script 标签：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body</span><br><span class=\"line\">    script(src=<span class=\"string\">\"jquery.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"app.js\"</span>)    <span class=\"comment\">// do some $ things...</span></span><br></pre></td></tr></table></figure>\n<p>请求是必要发起的，加载是平行加载，DOM 顺序即执行顺序。</p>\n<p>对于一个前端项目，现实是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body</span><br><span class=\"line\">    script(src=<span class=\"string\">\"zepto.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"jhash.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"fastClick.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"iScroll.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"underscore.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"handlebar.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"datacenter.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"deferred.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/wxbridge.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/login.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/base.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/city.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/date.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"util/cookie.js\"</span>)</span><br><span class=\"line\">    script(src=<span class=\"string\">\"app.js\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这就引发了难以维护、依赖模糊、请求过多的问题。</p>\n<h4 id=\"LABjs\"><a href=\"#LABjs\" class=\"headerlink\" title=\"LABjs\"></a><a href=\"http://labjs.com/\" target=\"_blank\" rel=\"noopener\">LABjs</a></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script(src=<span class=\"string\">\"LAB.js\"</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$LAB.script(<span class=\"string\">\"framework.js\"</span>).wait()</span><br><span class=\"line\">    .script(<span class=\"string\">\"plugin.framework.js\"</span>)</span><br><span class=\"line\">    .script(<span class=\"string\">\"myplugin.framework.js\"</span>).wait()</span><br><span class=\"line\">    .script(<span class=\"string\">\"init.js\"</span>);</span><br></pre></td></tr></table></figure>\n<p>.wait()方法表示立即运行刚才加载的Javascript文件</p>\n<p>语法糖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$LAB</span><br><span class=\"line\">.script( [ <span class=\"string\">\"script1.js\"</span>, <span class=\"string\">\"script2.js\"</span>, <span class=\"string\">\"script3.js\"</span>] )</span><br><span class=\"line\">.wait(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// wait for all scripts to execute first</span></span><br><span class=\"line\">    script1Func();</span><br><span class=\"line\">    script2Func();</span><br><span class=\"line\">    script3Func();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><em>基于文件的依赖管理</em></p>\n<h3 id=\"第三日-蒸汽朋克-MODULE-LOADER\"><a href=\"#第三日-蒸汽朋克-MODULE-LOADER\" class=\"headerlink\" title=\"第三日 蒸汽朋克 (MODULE LOADER)\"></a>第三日 蒸汽朋克 (MODULE LOADER)</h3><blockquote>\n<p>模块化架构的工业革命</p>\n</blockquote>\n<h4 id=\"YUI3-Loader\"><a href=\"#YUI3-Loader\" class=\"headerlink\" title=\"YUI3 Loader\"></a><a href=\"https://huangxuan.me/js-module-7day/yuilibrary.com\" target=\"_blank\" rel=\"noopener\">YUI3</a> Loader</h4><p>回顾昔日王者的风采：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// YUI - 编写模块</span></span><br><span class=\"line\">YUI.add(<span class=\"string\">'dom'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">  Y.DOM = &#123; ... &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// YUI - 使用模块</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">'dom'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>) </span>&#123;</span><br><span class=\"line\">  Y.DOM.doSomeThing();</span><br><span class=\"line\">  <span class=\"comment\">// use some methods DOM attach to Y</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>编写常用模块：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.js</span></span><br><span class=\"line\">YUI.add(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>)</span>&#123;</span><br><span class=\"line\">    Y.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">        Y.DOM.set(el, <span class=\"string\">'innerHTML'</span>, <span class=\"string\">'Hello!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,<span class=\"string\">'3.0.0'</span>,&#123;</span><br><span class=\"line\">    requires:[<span class=\"string\">'dom'</span>]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\">YUI().use(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Y</span>)</span>&#123;</span><br><span class=\"line\">    Y.sayHello(<span class=\"string\">\"hey yui loader\"</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><em>基于模块的依赖管理</em></p>\n<p>更深一步：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sandbox Implementation</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sandbox</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize the required modules</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; modules.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        Sandbox.modules[modules[i]](<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Y 其实是一个强沙箱，所有依赖模块通过 attach 的方式被注入沙盒。</p>\n<blockquote>\n<p>attach：在当前 YUI 实例上执行模块的初始化代码，使得模块在当前实例上可用</p>\n</blockquote>\n<p>YUI Combo 可以解决过多网络请求的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script(src=<span class=\"string\">\"http://yui.yahooapis.com/3.0.0/build/yui/yui-min.js\"</span>)</span><br><span class=\"line\">script(src=<span class=\"string\">\"http://yui.yahooapis.com/3.0.0/build/dom/dom-min.js\"</span>)</span><br></pre></td></tr></table></figure>\n<p>上面的情况可以写成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script(src=<span class=\"string\">\"http://yui.yahooapis.com/combo?</span></span><br><span class=\"line\"><span class=\"string\">    3.0.0/build/yui/yui-min.js&amp;</span></span><br><span class=\"line\"><span class=\"string\">    3.0.0/build/dom/dom-min.js\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这样就能在一次请求中拿到多个资源</p>\n<p><em>GET 请求，需要服务器支持</em></p>\n<h3 id=\"第四日-号角吹响-COMMONJS\"><a href=\"#第四日-号角吹响-COMMONJS\" class=\"headerlink\" title=\"第四日 号角吹响 (COMMONJS)\"></a>第四日 号角吹响 (COMMONJS)</h3><blockquote>\n<p>征服世界的第一步是跳出浏览器</p>\n</blockquote>\n<h4 id=\"CommonJS-API-Standard\"><a href=\"#CommonJS-API-Standard\" class=\"headerlink\" title=\"CommonJS - API Standard\"></a><a href=\"http://www.commonjs.org/\" target=\"_blank\" rel=\"noopener\">CommonJS</a> - API Standard</h4><p>CommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。</p>\n<p><strong>Modules/1.x</strong></p>\n<p>模块的定义与引用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\">exports.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'math'</span>)      <span class=\"comment\">// ./math in node</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(math.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>));    <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步/阻塞式加载的机制：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// timeout.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EXE_TIME = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">second</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start + second*<span class=\"number\">1000</span> &gt; <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())&#123;&#125;</span><br><span class=\"line\">&#125;)(EXE_TIME)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2000ms executed\"</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./timeout'</span>);   <span class=\"comment\">// sync load</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'done!'</span>);</span><br></pre></td></tr></table></figure>\n<p>这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<h3 id=\"第五日-双塔奇兵-AMD-CMD\"><a href=\"#第五日-双塔奇兵-AMD-CMD\" class=\"headerlink\" title=\"第五日 双塔奇兵 (AMD/CMD)\"></a>第五日 双塔奇兵 (AMD/CMD)</h3><blockquote>\n<p>浏览器环境模块化方案</p>\n</blockquote>\n<p>在 CommonJS 推广到浏览器的过程中，关于 Modules 的下一版规范，形成了三大流派：</p>\n<ol>\n<li>Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。</li>\n<li>Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。</li>\n<li>Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了。</li>\n</ol>\n<h4 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a><a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">RequireJS</a> &amp; AMD</h4><p>AMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器这个问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//CommonJS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Employee = <span class=\"built_in\">require</span>(<span class=\"string\">\"types/Employee\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Programmer</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">Programmer.prototype = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果 require call 是异步的，那么肯定 error</span></span><br><span class=\"line\"><span class=\"comment\">//因为在执行这句前 Employee 模块肯定来不及加载进来</span></span><br></pre></td></tr></table></figure>\n<p>所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AMD Wrapper</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(</span><br><span class=\"line\">    [types/Employee],    <span class=\"comment\">//依赖</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Employee</span>)</span>&#123;  <span class=\"comment\">//这个回调会在所有依赖都被加载后才执行</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Programmer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//do something</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        Programmer.prototype = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Programmer;  <span class=\"comment\">//return Constructor</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</span><br><span class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>AMD 和 CommonJS 的核心争议包括执行时机和书写风格：</p>\n<p><strong>执行时机</strong></p>\n<p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></span><br></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是提前执行，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<p><strong>书写风格</strong></p>\n<p>AMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a><a href=\"https://seajs.github.io/seajs/docs/\" target=\"_blank\" rel=\"noopener\">SeaJS</a> &amp; CMD</h4><p>CMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>CMD 主要有 define, factory, require, export 这么几个东西：</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 require：</p>\n<p>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></span><br><span class=\"line\">    a.doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></span><br><span class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></span><br><span class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模块代码...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        foo: <span class=\"string\">'bar'</span>,</span><br><span class=\"line\">        doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h4 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h4><p>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</p>\n<p>对于依赖的模块，AMD 是提前执行，CMD 是懒执行；CMD 推崇依赖就近，AMD 推崇依赖前置。（都是先加载）</p>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></span><br><span class=\"line\"></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\"></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"第六日-精灵宝钻-BROWSERIFY-WEBPACK\"><a href=\"#第六日-精灵宝钻-BROWSERIFY-WEBPACK\" class=\"headerlink\" title=\"第六日 精灵宝钻 (BROWSERIFY/WEBPACK)\"></a>第六日 精灵宝钻 (BROWSERIFY/WEBPACK)</h3><blockquote>\n<p>大势所趋，去掉这层包裹！</p>\n</blockquote>\n<h4 id=\"Browserify-CommonJS-In-Browser\"><a href=\"#Browserify-CommonJS-In-Browser\" class=\"headerlink\" title=\"Browserify - CommonJS In Browser\"></a><a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a> - CommonJS In Browser</h4><p>Browserify 是一个 node.js 模块，主要用于改写现有的 CommonJS 模块，使得浏览器端也可以使用这些模块。</p>\n<p>举个例子，假定有一个很简单的CommonJS模块文件foo.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// foo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后，还有一个main.js文件，用来加载foo模块：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">\"./foo\"</span>);</span><br><span class=\"line\">foo(<span class=\"string\">\"Hi\"</span>);</span><br></pre></td></tr></table></figure>\n<p>使用Browserify，将main.js转化为浏览器可以加载的脚本compiled.js。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browserify main.js -o compiled.js</span><br></pre></td></tr></table></figure>\n<p>转化后的文件不仅包括了main.js，还包括了它所依赖的foo.js。两者打包在一起，保证浏览器加载时的依赖关系。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"compiled.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用上面的命令，在浏览器中运行 compiled.js，控制台会显示Hi。</p>\n<p>利用 <a href=\"https://www.npmjs.com/package/watchify\" target=\"_blank\" rel=\"noopener\">Watchify</a> 可以做到 auto-recompile：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm install -g watchify</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> WATCH!</span><br><span class=\"line\"><span class=\"meta\">$</span> watchify app.js -o bundle.js -v</span><br></pre></td></tr></table></figure>\n<h4 id=\"Webpack-Module-Bundler\"><a href=\"#Webpack-Module-Bundler\" class=\"headerlink\" title=\"Webpack - Module Bundler\"></a><a href=\"https://www.webpackjs.com/\" target=\"_blank\" rel=\"noopener\">Webpack</a> - Module Bundler</h4><p>webpack 是一个模块打包器，webpack 的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用。</p>\n<p>webpack 功能十分强大，除了打包 JS 还能对静态资源、css 文件等进行处理，另外还有插件系统、\b代码分割\b等功能。</p>\n<h3 id=\"第七日-王者归来-ES6-MODULE\"><a href=\"#第七日-王者归来-ES6-MODULE\" class=\"headerlink\" title=\"第七日 王者归来 (ES6 MODULE)\"></a>第七日 王者归来 (ES6 MODULE)</h3><blockquote>\n<p>最后的战役</p>\n</blockquote>\n<p>在 ES6 之后终于有了 Module</p>\n<p>只有一个 default 的情况：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> math = &#123;</span><br><span class=\"line\">    PI: <span class=\"number\">3.14</span>,</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> math <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\">math.PI</span><br></pre></td></tr></table></figure>\n<p>命名 export：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export Declaration</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am not bar.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export VariableStatement;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> PI = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> bar = foo;   <span class=\"comment\">// function expression</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export &#123; ExportsList &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> PI = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; PI, foo &#125;;</span><br></pre></td></tr></table></figure>\n<p>引入命名的 export：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import &#123; ImportsList &#125; from \"module-name\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; PI &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; PI, foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"module-name\"</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import IdentifierName as ImportedBinding</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; foo <span class=\"keyword\">as</span> bar &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\">bar();  <span class=\"comment\">// use alias bar</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import NameSpaceImport</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> math <span class=\"keyword\">from</span> <span class=\"string\">\"./math\"</span>;</span><br><span class=\"line\">math.PI</span><br><span class=\"line\">math.foo()</span><br></pre></td></tr></table></figure>\n<h4 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a><a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">babel</a></h4><p>Babel 是一个 JavaScript 编译器，它让我们现在就可以使用下一代 JavaScript 语法。</p>\n<blockquote>\n<p>参考：<br><a href=\"https://www.cyj.me/programming/2018/05/22/about-module-i/\" target=\"_blank\" rel=\"noopener\">前端模块的历史沿革</a><br><a href=\"https://www.cyj.me/programming/2018/05/23/about-module-ii/\" target=\"_blank\" rel=\"noopener\">前端模块的现状</a></p>\n</blockquote>\n","plink":"https://vincentdou.github.io/blog/post/2018-08-08-JavaScript模块化七日谈/","type":"post"},{"layout":"post","title":"[转]写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise","date":"2018-11-19T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n### Promise 只是一个 Event Loop 中的 microtask\n\n深入了解过 Promise 的人都知道，Promise 所说的异步执行，只是将 Promise 构造函数中 resolve，reject 方法和注册的 callback 转化为 eventLoop的 microtask/Promise Job，并放到 Event Loop 队列中等待执行，也就是 Javascript 单线程中的“异步执行”。\n\n[Promise/A+ 规范](https://promisesaplus.com/#point-67)中，并没有明确是以 microtask 还是 macrotask 形式放入队列，对没有 microtask 概念的宿主环境采用 setTimeout 等 task/Job 类的任务。规范中另外明确的一点也非常重要：回调函数的异步调用必须在当前 context，也就是 JS stack 为空之后执行。\n\n在最新的 [ECMAScript 规范](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-promisereactionjob)中，明确了 Promise 必须以 Promise Job 的形式入 Job 队列（也就是 microtask），并仅在没有运行的 stack(stack 为空的情况下)才可以初始化执行。\n\nHTML 规范也提出，在 stack 清空后，执行 microtask 的检查方法。也就是必须在 stack 为空的情况下才能执行。\n\nGoogle Chrome 的开发者 Jake Archibald （ES6-promise 作者）的文章将这个区分的问题描述得很清楚。假如要在 Javascript 平台或者引擎中实现 Promise，优先以 microtask/Promise Job 方式实现。目前主流浏览器的 Javascript 引擎原生实现，主流的 Promise 库（es6-promise，bluebrid）基本都是使用 microtask/Promise Job 的形式将 Promise 放入队列。\n\n其他以 microtask/Promise Job 形式实现的方法还有：process.nextTick，setImmediate，postMessage，MessageChannel 等\n\n根据规范，microtask 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 microtask。原生的 setTimeout 就算是将延迟设置为 0 也会有 4 ms 的延迟，会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 microtask。\n\n对于在不通宿主环境中选择合适的 microtask，可以选择 asap 和 setImmediate的代码作为参考。\n\n### Promise 的中的同步与异步\n\n```js\nnew Promise((resolve) => {\n  console.log('a')\n  resolve('b')\n  console.log('c')\n}).then((data) => {\n  console.log(data)\n})\n\n// a, c, b\n```\n\n使用过 Promise 的人都知道输出 a, c, b，但有多少人可以清楚地说出从创建 Promise 对象到执行完回调的过程？下面是一个完整的解释：\n\n**构造函数中的输出执行是同步的，输出 a, 执行 resolve 函数，将 Promise 对象状态置为 resolved，输出 c。同时注册这个 Promise 对象的回调 then 函数。整个脚本执行完，stack 清空。event loop 检查到 stack 为空，再检查 microtask 队列中是否有任务，发现了 Promise 对象的 then 回调函数产生的 microtask，推入 stack，执行。输出 b，event loop的列队为空，stack 为空，脚本执行完毕。**\n\n### Promise 构造函数，选择平台的 microtask 实现\n\n```js\n// Simply choose a microtask\nconst asyncFn = function() {\n  if (typeof process === 'object' && process !== null && typeof(process.nextTick) === 'function') {\n    return process.nextTick\n  }\n  if (typeof(setImmediate) === 'function') {\n    return setImmediate\n  }\n  return setTimeout\n}()\n\n// States\nconst PENDING = 'PENDING'\n\nconst RESOLVED = 'RESOLVED'\n\nconst REJECTED = 'REJECTED'\n\n// Constructor\nfunction MimiPromise(executor) {\n  this.state = PENDING\n  this.executedData = undefined\n  this.multiPromise2 = []\n\n  resolve = (value) => {\n    settlePromise(this, RESOLVED, value)\n  }\n\n  reject = (reason) => {\n    settlePromise(this, REJECTED, reason)\n  }\n\n  executor(resolve, reject)\n}\n```\n\nstate 和 executedData 都容易理解，但是必须要理解一下为什么要维护一个 multiPromise2 数组。由于规范中说明，每个调用过 then 方法的 promise 对象必须返回一个新的 promise2 对象，所以最好的方法是当调用 then 方法的时候将一个属于这个 then 方法的 promise2 加入队列，在 promise 对象中维护这些新的 promise2 的状态。\n\n- executor： promise 构造函数的执行函数参数\n- state：promise 的状态\n- multiPromise2：维护的每个注册 then 方法需要返回的新 promise2\n- resolve：函数定义了将对象设置为 RESOLVED 的过程\n- reject：函数定义了将对象设置为 REJECTED 的过程\n\n最后执行构造函数 executor，并调用 promise 内部的私有方法 resolve 和 reject。\n\n### settlePromise 如何将一个新建的 Promise settled\n\n```js\n// Settle any promise, set state and value, check if there is\n// any then callback and async process them with the origin promise,\n// return promise2(aka promise2), and callback itself.\nfunction settlePromise(promise, executedState, executedData) {\n  if (promise.state !== PENDING) {\n    return\n  }\n\n  promise.state = executedState\n  promise.executedData = executedData\n\n  if (promise.multiPromise2.length > 0) {\n    const callbackType = executedState === RESOLVED ? \"resolvedCallback\" : \"rejectedCallback\"\n\n    for (promise2 of promise.multiPromise2) {\n      asyncProcessCallback(promise, promise2, promise2[callbackType])\n    }\n  }\n}\n```\n\n第一个判断条件很重要，因为 Promise 的状态是不可逆的。在 settlePromise 的过程中假如状态不是 PENDING，则不需要继续执行下去。\n\n当前 settlePromise 的环境，可以有三种情况：\n\n- 异步延迟执行 settlePromise 方法，线程已经同步注册好 then 方法，需要执行所有注册的 then 回调函数；\n- 同步执行 settlePromise 方法，then 方法未执行，后面需要执行的 then方法会在注册的过程中直接执行；\n- 无论执行异步 settlePromise 还是同步 settlePromise 方法，并没有注册的 then 方法需要执行，只需要将本 Promise 对象的状态设置好即可。\n\n### then 方法的注册和立即执行\n\n```js\nMimiPromise.prototype.then = function(resolvedCallback, rejectedCallback) {\n  let promise2 = new MimiPromise(() => {})\n\n  if (typeof resolvedCallback === \"function\") {\n    promise2.resolvedCallback = resolvedCallback;\n  }\n  if (typeof rejectedCallback === \"function\") {\n    promise2.rejectedCallback = rejectedCallback;\n  }\n\n  if (this.state === PENDING) {\n    this.multiPromise2.push(promise2)\n  } else if (this.state === RESOLVED) {\n    asyncProcessCallback(this, promise2, promise2.resolvedCallback)\n  } else if (this.state === REJECTED) {\n    asyncProcessCallback(this, promise2, promise2.rejectedCallback)\n  }\n\n  return promise2\n}\n```\n\n每个注册 then 方法都需要返回一个新的 promise2 对象，根据当前 promise 对象的 state，会出现三种情况：\n\n- 当前 promise 对象处于 PENDING 状态。构造函数异步执行了 settlePromise 方法，需要将这个 then 方法对应返回的 promise2 放入当前 promise 的 multiPromise2 队列当中，返回这个 promise2。以后当 settlePromise 方法异步执行的时候，执行全部注册的 then 回调方法\n- 当前 promise 对象处于 RESOLVED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。\n- 当前 promise 对象处于 REJECTED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。\n\n### 异步执行回调函数\n\n```js\n// Async process callback with origin promise and promise2\nfunction asyncProcessCallback(promise, promise2, callback) {\n  asyncFn(() => {\n    if (!callback) {\n      settlePromise(promise2, promise.state, promise.executedData);\n      return;\n    }\n\n    let x\n\n    try {\n      x = callback(promise.executedData)\n    } catch (e) {\n      settlePromise(promise2, REJECTED, e)\n      return\n    }\n\n    settleWithX(promise2, x)\n  })\n}\n```\n\n这里用到我们之前选取的平台异步执行函数，异步执行 callback。假如 callback 没有定义，则将返回 promise2 的状态转换为当前 promise 的状态。然后将 callback 执行。最后再 settleWithX promise2 与 callback 返回的对象 x。\n\n### 最后的 settleWithX 和 settleXthen\n\n```js\nfunction settleWithX (p, x) {\n  if (x === p && x) {\n    settlePromise(p, REJECTED, new TypeError(\"promise_circular_chain\"));\n    return;\n  }\n\n  var xthen, type = typeof x;\n  if (x !== null && (type === \"function\" || type === \"object\")) {\n    try {\n      xthen = x.then;\n    } catch (err) {\n      settlePromise(p, REJECTED, err);\n      return;\n    }\n    if (typeof xthen === \"function\") {\n      settleXthen(p, x, xthen);\n    } else {\n      settlePromise(p, RESOLVED, x);\n    }\n  } else {\n    settlePromise(p, RESOLVED, x);\n  }\n  return p;\n}\n\nfunction settleXthen (p, x, xthen) {\n  try {\n    xthen.call(x, function (y) {\n      if (!x) return;\n      x = null;\n\n      settleWithX(p, y);\n    }, function (r) {\n      if (!x) return;\n      x = null;\n\n      settlePromise(p, REJECTED, r);\n    });\n  } catch (err) {\n    if (x) {\n      settlePromise(p, REJECTED, err);\n      x = null;\n    }\n  }\n}\n```\n","source":"_posts/2018-11-20-Promise实现详解.md","raw":"---\nlayout:     post\ntitle:      \"[转]写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise\"\ndate:       2018-11-20\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - ES6\n    - Promise\n---\n\n### Promise 只是一个 Event Loop 中的 microtask\n\n深入了解过 Promise 的人都知道，Promise 所说的异步执行，只是将 Promise 构造函数中 resolve，reject 方法和注册的 callback 转化为 eventLoop的 microtask/Promise Job，并放到 Event Loop 队列中等待执行，也就是 Javascript 单线程中的“异步执行”。\n\n[Promise/A+ 规范](https://promisesaplus.com/#point-67)中，并没有明确是以 microtask 还是 macrotask 形式放入队列，对没有 microtask 概念的宿主环境采用 setTimeout 等 task/Job 类的任务。规范中另外明确的一点也非常重要：回调函数的异步调用必须在当前 context，也就是 JS stack 为空之后执行。\n\n在最新的 [ECMAScript 规范](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-promisereactionjob)中，明确了 Promise 必须以 Promise Job 的形式入 Job 队列（也就是 microtask），并仅在没有运行的 stack(stack 为空的情况下)才可以初始化执行。\n\nHTML 规范也提出，在 stack 清空后，执行 microtask 的检查方法。也就是必须在 stack 为空的情况下才能执行。\n\nGoogle Chrome 的开发者 Jake Archibald （ES6-promise 作者）的文章将这个区分的问题描述得很清楚。假如要在 Javascript 平台或者引擎中实现 Promise，优先以 microtask/Promise Job 方式实现。目前主流浏览器的 Javascript 引擎原生实现，主流的 Promise 库（es6-promise，bluebrid）基本都是使用 microtask/Promise Job 的形式将 Promise 放入队列。\n\n其他以 microtask/Promise Job 形式实现的方法还有：process.nextTick，setImmediate，postMessage，MessageChannel 等\n\n根据规范，microtask 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 microtask。原生的 setTimeout 就算是将延迟设置为 0 也会有 4 ms 的延迟，会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 microtask。\n\n对于在不通宿主环境中选择合适的 microtask，可以选择 asap 和 setImmediate的代码作为参考。\n\n### Promise 的中的同步与异步\n\n```js\nnew Promise((resolve) => {\n  console.log('a')\n  resolve('b')\n  console.log('c')\n}).then((data) => {\n  console.log(data)\n})\n\n// a, c, b\n```\n\n使用过 Promise 的人都知道输出 a, c, b，但有多少人可以清楚地说出从创建 Promise 对象到执行完回调的过程？下面是一个完整的解释：\n\n**构造函数中的输出执行是同步的，输出 a, 执行 resolve 函数，将 Promise 对象状态置为 resolved，输出 c。同时注册这个 Promise 对象的回调 then 函数。整个脚本执行完，stack 清空。event loop 检查到 stack 为空，再检查 microtask 队列中是否有任务，发现了 Promise 对象的 then 回调函数产生的 microtask，推入 stack，执行。输出 b，event loop的列队为空，stack 为空，脚本执行完毕。**\n\n### Promise 构造函数，选择平台的 microtask 实现\n\n```js\n// Simply choose a microtask\nconst asyncFn = function() {\n  if (typeof process === 'object' && process !== null && typeof(process.nextTick) === 'function') {\n    return process.nextTick\n  }\n  if (typeof(setImmediate) === 'function') {\n    return setImmediate\n  }\n  return setTimeout\n}()\n\n// States\nconst PENDING = 'PENDING'\n\nconst RESOLVED = 'RESOLVED'\n\nconst REJECTED = 'REJECTED'\n\n// Constructor\nfunction MimiPromise(executor) {\n  this.state = PENDING\n  this.executedData = undefined\n  this.multiPromise2 = []\n\n  resolve = (value) => {\n    settlePromise(this, RESOLVED, value)\n  }\n\n  reject = (reason) => {\n    settlePromise(this, REJECTED, reason)\n  }\n\n  executor(resolve, reject)\n}\n```\n\nstate 和 executedData 都容易理解，但是必须要理解一下为什么要维护一个 multiPromise2 数组。由于规范中说明，每个调用过 then 方法的 promise 对象必须返回一个新的 promise2 对象，所以最好的方法是当调用 then 方法的时候将一个属于这个 then 方法的 promise2 加入队列，在 promise 对象中维护这些新的 promise2 的状态。\n\n- executor： promise 构造函数的执行函数参数\n- state：promise 的状态\n- multiPromise2：维护的每个注册 then 方法需要返回的新 promise2\n- resolve：函数定义了将对象设置为 RESOLVED 的过程\n- reject：函数定义了将对象设置为 REJECTED 的过程\n\n最后执行构造函数 executor，并调用 promise 内部的私有方法 resolve 和 reject。\n\n### settlePromise 如何将一个新建的 Promise settled\n\n```js\n// Settle any promise, set state and value, check if there is\n// any then callback and async process them with the origin promise,\n// return promise2(aka promise2), and callback itself.\nfunction settlePromise(promise, executedState, executedData) {\n  if (promise.state !== PENDING) {\n    return\n  }\n\n  promise.state = executedState\n  promise.executedData = executedData\n\n  if (promise.multiPromise2.length > 0) {\n    const callbackType = executedState === RESOLVED ? \"resolvedCallback\" : \"rejectedCallback\"\n\n    for (promise2 of promise.multiPromise2) {\n      asyncProcessCallback(promise, promise2, promise2[callbackType])\n    }\n  }\n}\n```\n\n第一个判断条件很重要，因为 Promise 的状态是不可逆的。在 settlePromise 的过程中假如状态不是 PENDING，则不需要继续执行下去。\n\n当前 settlePromise 的环境，可以有三种情况：\n\n- 异步延迟执行 settlePromise 方法，线程已经同步注册好 then 方法，需要执行所有注册的 then 回调函数；\n- 同步执行 settlePromise 方法，then 方法未执行，后面需要执行的 then方法会在注册的过程中直接执行；\n- 无论执行异步 settlePromise 还是同步 settlePromise 方法，并没有注册的 then 方法需要执行，只需要将本 Promise 对象的状态设置好即可。\n\n### then 方法的注册和立即执行\n\n```js\nMimiPromise.prototype.then = function(resolvedCallback, rejectedCallback) {\n  let promise2 = new MimiPromise(() => {})\n\n  if (typeof resolvedCallback === \"function\") {\n    promise2.resolvedCallback = resolvedCallback;\n  }\n  if (typeof rejectedCallback === \"function\") {\n    promise2.rejectedCallback = rejectedCallback;\n  }\n\n  if (this.state === PENDING) {\n    this.multiPromise2.push(promise2)\n  } else if (this.state === RESOLVED) {\n    asyncProcessCallback(this, promise2, promise2.resolvedCallback)\n  } else if (this.state === REJECTED) {\n    asyncProcessCallback(this, promise2, promise2.rejectedCallback)\n  }\n\n  return promise2\n}\n```\n\n每个注册 then 方法都需要返回一个新的 promise2 对象，根据当前 promise 对象的 state，会出现三种情况：\n\n- 当前 promise 对象处于 PENDING 状态。构造函数异步执行了 settlePromise 方法，需要将这个 then 方法对应返回的 promise2 放入当前 promise 的 multiPromise2 队列当中，返回这个 promise2。以后当 settlePromise 方法异步执行的时候，执行全部注册的 then 回调方法\n- 当前 promise 对象处于 RESOLVED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。\n- 当前 promise 对象处于 REJECTED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。\n\n### 异步执行回调函数\n\n```js\n// Async process callback with origin promise and promise2\nfunction asyncProcessCallback(promise, promise2, callback) {\n  asyncFn(() => {\n    if (!callback) {\n      settlePromise(promise2, promise.state, promise.executedData);\n      return;\n    }\n\n    let x\n\n    try {\n      x = callback(promise.executedData)\n    } catch (e) {\n      settlePromise(promise2, REJECTED, e)\n      return\n    }\n\n    settleWithX(promise2, x)\n  })\n}\n```\n\n这里用到我们之前选取的平台异步执行函数，异步执行 callback。假如 callback 没有定义，则将返回 promise2 的状态转换为当前 promise 的状态。然后将 callback 执行。最后再 settleWithX promise2 与 callback 返回的对象 x。\n\n### 最后的 settleWithX 和 settleXthen\n\n```js\nfunction settleWithX (p, x) {\n  if (x === p && x) {\n    settlePromise(p, REJECTED, new TypeError(\"promise_circular_chain\"));\n    return;\n  }\n\n  var xthen, type = typeof x;\n  if (x !== null && (type === \"function\" || type === \"object\")) {\n    try {\n      xthen = x.then;\n    } catch (err) {\n      settlePromise(p, REJECTED, err);\n      return;\n    }\n    if (typeof xthen === \"function\") {\n      settleXthen(p, x, xthen);\n    } else {\n      settlePromise(p, RESOLVED, x);\n    }\n  } else {\n    settlePromise(p, RESOLVED, x);\n  }\n  return p;\n}\n\nfunction settleXthen (p, x, xthen) {\n  try {\n    xthen.call(x, function (y) {\n      if (!x) return;\n      x = null;\n\n      settleWithX(p, y);\n    }, function (r) {\n      if (!x) return;\n      x = null;\n\n      settlePromise(p, REJECTED, r);\n    });\n  } catch (err) {\n    if (x) {\n      settlePromise(p, REJECTED, err);\n      x = null;\n    }\n  }\n}\n```\n","slug":"2018-11-20-Promise实现详解","published":1,"updated":"2019-01-02T08:49:00.261Z","comments":0,"photos":[],"link":"post/2018-11-20-Promise实现详解","_id":"cjz2epjfi001an3w5pkvpilx7","content":"<h3 id=\"Promise-只是一个-Event-Loop-中的-microtask\">Promise 只是一个 Event Loop 中的 microtask<a href=\"post/2018-11-20-Promise实现详解#Promise-只是一个-Event-Loop-中的-microtask\"></a></h3><p>深入了解过 Promise 的人都知道，Promise 所说的异步执行，只是将 Promise 构造函数中 resolve，reject 方法和注册的 callback 转化为 eventLoop的 microtask/Promise Job，并放到 Event Loop 队列中等待执行，也就是 Javascript 单线程中的“异步执行”。</p>\n<p><a href=\"https://promisesaplus.com/#point-67\" target=\"_blank\" rel=\"noopener\">Promise/A+ 规范</a>中，并没有明确是以 microtask 还是 macrotask 形式放入队列，对没有 microtask 概念的宿主环境采用 setTimeout 等 task/Job 类的任务。规范中另外明确的一点也非常重要：回调函数的异步调用必须在当前 context，也就是 JS stack 为空之后执行。</p>\n<p>在最新的 <a href=\"http://www.ecma-international.org/ecma-262/7.0/index.html#sec-promisereactionjob\" target=\"_blank\" rel=\"noopener\">ECMAScript 规范</a>中，明确了 Promise 必须以 Promise Job 的形式入 Job 队列（也就是 microtask），并仅在没有运行的 stack(stack 为空的情况下)才可以初始化执行。</p>\n<p>HTML 规范也提出，在 stack 清空后，执行 microtask 的检查方法。也就是必须在 stack 为空的情况下才能执行。</p>\n<p>Google Chrome 的开发者 Jake Archibald （ES6-promise 作者）的文章将这个区分的问题描述得很清楚。假如要在 Javascript 平台或者引擎中实现 Promise，优先以 microtask/Promise Job 方式实现。目前主流浏览器的 Javascript 引擎原生实现，主流的 Promise 库（es6-promise，bluebrid）基本都是使用 microtask/Promise Job 的形式将 Promise 放入队列。</p>\n<p>其他以 microtask/Promise Job 形式实现的方法还有：process.nextTick，setImmediate，postMessage，MessageChannel 等</p>\n<p>根据规范，microtask 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 microtask。原生的 setTimeout 就算是将延迟设置为 0 也会有 4 ms 的延迟，会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 microtask。</p>\n<p>对于在不通宿主环境中选择合适的 microtask，可以选择 asap 和 setImmediate的代码作为参考。</p>\n<h3 id=\"Promise-的中的同步与异步\">Promise 的中的同步与异步<a href=\"post/2018-11-20-Promise实现详解#Promise-的中的同步与异步\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  resolve(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a, c, b</span></span><br></pre></td></tr></table></div></figure>\n<p>使用过 Promise 的人都知道输出 a, c, b，但有多少人可以清楚地说出从创建 Promise 对象到执行完回调的过程？下面是一个完整的解释：</p>\n<p><strong>构造函数中的输出执行是同步的，输出 a, 执行 resolve 函数，将 Promise 对象状态置为 resolved，输出 c。同时注册这个 Promise 对象的回调 then 函数。整个脚本执行完，stack 清空。event loop 检查到 stack 为空，再检查 microtask 队列中是否有任务，发现了 Promise 对象的 then 回调函数产生的 microtask，推入 stack，执行。输出 b，event loop的列队为空，stack 为空，脚本执行完毕。</strong></p>\n<h3 id=\"Promise-构造函数，选择平台的-microtask-实现\">Promise 构造函数，选择平台的 microtask 实现<a href=\"post/2018-11-20-Promise实现详解#Promise-构造函数，选择平台的-microtask-实现\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Simply choose a microtask</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncFn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> process === <span class=\"string\">'object'</span> &amp;&amp; process !== <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">typeof</span>(process.nextTick) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> process.nextTick</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(setImmediate) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setImmediate</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> setTimeout</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// States</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'PENDING'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">'RESOLVED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'REJECTED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Constructor</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MimiPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = PENDING</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.executedData = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.multiPromise2 = []</span><br><span class=\"line\"></span><br><span class=\"line\">  resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    settlePromise(<span class=\"keyword\">this</span>, RESOLVED, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  reject = <span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    settlePromise(<span class=\"keyword\">this</span>, REJECTED, reason)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  executor(resolve, reject)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>state 和 executedData 都容易理解，但是必须要理解一下为什么要维护一个 multiPromise2 数组。由于规范中说明，每个调用过 then 方法的 promise 对象必须返回一个新的 promise2 对象，所以最好的方法是当调用 then 方法的时候将一个属于这个 then 方法的 promise2 加入队列，在 promise 对象中维护这些新的 promise2 的状态。</p>\n<ul>\n<li>executor： promise 构造函数的执行函数参数</li>\n<li>state：promise 的状态</li>\n<li>multiPromise2：维护的每个注册 then 方法需要返回的新 promise2</li>\n<li>resolve：函数定义了将对象设置为 RESOLVED 的过程</li>\n<li>reject：函数定义了将对象设置为 REJECTED 的过程</li>\n</ul>\n<p>最后执行构造函数 executor，并调用 promise 内部的私有方法 resolve 和 reject。</p>\n<h3 id=\"settlePromise-如何将一个新建的-Promise-settled\">settlePromise 如何将一个新建的 Promise settled<a href=\"post/2018-11-20-Promise实现详解#settlePromise-如何将一个新建的-Promise-settled\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Settle any promise, set state and value, check if there is</span></span><br><span class=\"line\"><span class=\"comment\">// any then callback and async process them with the origin promise,</span></span><br><span class=\"line\"><span class=\"comment\">// return promise2(aka promise2), and callback itself.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settlePromise</span>(<span class=\"params\">promise, executedState, executedData</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (promise.state !== PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  promise.state = executedState</span><br><span class=\"line\">  promise.executedData = executedData</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (promise.multiPromise2.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> callbackType = executedState === RESOLVED ? <span class=\"string\">\"resolvedCallback\"</span> : <span class=\"string\">\"rejectedCallback\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (promise2 <span class=\"keyword\">of</span> promise.multiPromise2) &#123;</span><br><span class=\"line\">      asyncProcessCallback(promise, promise2, promise2[callbackType])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>第一个判断条件很重要，因为 Promise 的状态是不可逆的。在 settlePromise 的过程中假如状态不是 PENDING，则不需要继续执行下去。</p>\n<p>当前 settlePromise 的环境，可以有三种情况：</p>\n<ul>\n<li>异步延迟执行 settlePromise 方法，线程已经同步注册好 then 方法，需要执行所有注册的 then 回调函数；</li>\n<li>同步执行 settlePromise 方法，then 方法未执行，后面需要执行的 then方法会在注册的过程中直接执行；</li>\n<li>无论执行异步 settlePromise 还是同步 settlePromise 方法，并没有注册的 then 方法需要执行，只需要将本 Promise 对象的状态设置好即可。</li>\n</ul>\n<h3 id=\"then-方法的注册和立即执行\">then 方法的注册和立即执行<a href=\"post/2018-11-20-Promise实现详解#then-方法的注册和立即执行\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MimiPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolvedCallback, rejectedCallback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2 = <span class=\"keyword\">new</span> MimiPromise(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> resolvedCallback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    promise2.resolvedCallback = resolvedCallback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> rejectedCallback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    promise2.rejectedCallback = rejectedCallback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.multiPromise2.push(promise2)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === RESOLVED) &#123;</span><br><span class=\"line\">    asyncProcessCallback(<span class=\"keyword\">this</span>, promise2, promise2.resolvedCallback)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === REJECTED) &#123;</span><br><span class=\"line\">    asyncProcessCallback(<span class=\"keyword\">this</span>, promise2, promise2.rejectedCallback)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>每个注册 then 方法都需要返回一个新的 promise2 对象，根据当前 promise 对象的 state，会出现三种情况：</p>\n<ul>\n<li>当前 promise 对象处于 PENDING 状态。构造函数异步执行了 settlePromise 方法，需要将这个 then 方法对应返回的 promise2 放入当前 promise 的 multiPromise2 队列当中，返回这个 promise2。以后当 settlePromise 方法异步执行的时候，执行全部注册的 then 回调方法</li>\n<li>当前 promise 对象处于 RESOLVED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。</li>\n<li>当前 promise 对象处于 REJECTED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。</li>\n</ul>\n<h3 id=\"异步执行回调函数\">异步执行回调函数<a href=\"post/2018-11-20-Promise实现详解#异步执行回调函数\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Async process callback with origin promise and promise2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncProcessCallback</span>(<span class=\"params\">promise, promise2, callback</span>) </span>&#123;</span><br><span class=\"line\">  asyncFn(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!callback) &#123;</span><br><span class=\"line\">      settlePromise(promise2, promise.state, promise.executedData);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      x = callback(promise.executedData)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      settlePromise(promise2, REJECTED, e)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    settleWithX(promise2, x)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里用到我们之前选取的平台异步执行函数，异步执行 callback。假如 callback 没有定义，则将返回 promise2 的状态转换为当前 promise 的状态。然后将 callback 执行。最后再 settleWithX promise2 与 callback 返回的对象 x。</p>\n<h3 id=\"最后的-settleWithX-和-settleXthen\">最后的 settleWithX 和 settleXthen<a href=\"post/2018-11-20-Promise实现详解#最后的-settleWithX-和-settleXthen\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settleWithX</span> (<span class=\"params\">p, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === p &amp;&amp; x) &#123;</span><br><span class=\"line\">    settlePromise(p, REJECTED, <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"promise_circular_chain\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xthen, type = <span class=\"keyword\">typeof</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (type === <span class=\"string\">\"function\"</span> || type === <span class=\"string\">\"object\"</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xthen = x.then;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      settlePromise(p, REJECTED, err);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> xthen === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">      settleXthen(p, x, xthen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      settlePromise(p, RESOLVED, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    settlePromise(p, RESOLVED, x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settleXthen</span> (<span class=\"params\">p, x, xthen</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xthen.call(x, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      settleWithX(p, y);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      settlePromise(p, REJECTED, r);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x) &#123;</span><br><span class=\"line\">      settlePromise(p, REJECTED, err);</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Promise-只是一个-Event-Loop-中的-microtask\"><a href=\"#Promise-只是一个-Event-Loop-中的-microtask\" class=\"headerlink\" title=\"Promise 只是一个 Event Loop 中的 microtask\"></a>Promise 只是一个 Event Loop 中的 microtask</h3><p>深入了解过 Promise 的人都知道，Promise 所说的异步执行，只是将 Promise 构造函数中 resolve，reject 方法和注册的 callback 转化为 eventLoop的 microtask/Promise Job，并放到 Event Loop 队列中等待执行，也就是 Javascript 单线程中的“异步执行”。</p>\n<p><a href=\"https://promisesaplus.com/#point-67\" target=\"_blank\" rel=\"noopener\">Promise/A+ 规范</a>中，并没有明确是以 microtask 还是 macrotask 形式放入队列，对没有 microtask 概念的宿主环境采用 setTimeout 等 task/Job 类的任务。规范中另外明确的一点也非常重要：回调函数的异步调用必须在当前 context，也就是 JS stack 为空之后执行。</p>\n<p>在最新的 <a href=\"http://www.ecma-international.org/ecma-262/7.0/index.html#sec-promisereactionjob\" target=\"_blank\" rel=\"noopener\">ECMAScript 规范</a>中，明确了 Promise 必须以 Promise Job 的形式入 Job 队列（也就是 microtask），并仅在没有运行的 stack(stack 为空的情况下)才可以初始化执行。</p>\n<p>HTML 规范也提出，在 stack 清空后，执行 microtask 的检查方法。也就是必须在 stack 为空的情况下才能执行。</p>\n<p>Google Chrome 的开发者 Jake Archibald （ES6-promise 作者）的文章将这个区分的问题描述得很清楚。假如要在 Javascript 平台或者引擎中实现 Promise，优先以 microtask/Promise Job 方式实现。目前主流浏览器的 Javascript 引擎原生实现，主流的 Promise 库（es6-promise，bluebrid）基本都是使用 microtask/Promise Job 的形式将 Promise 放入队列。</p>\n<p>其他以 microtask/Promise Job 形式实现的方法还有：process.nextTick，setImmediate，postMessage，MessageChannel 等</p>\n<p>根据规范，microtask 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 microtask。原生的 setTimeout 就算是将延迟设置为 0 也会有 4 ms 的延迟，会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 microtask。</p>\n<p>对于在不通宿主环境中选择合适的 microtask，可以选择 asap 和 setImmediate的代码作为参考。</p>\n<h3 id=\"Promise-的中的同步与异步\"><a href=\"#Promise-的中的同步与异步\" class=\"headerlink\" title=\"Promise 的中的同步与异步\"></a>Promise 的中的同步与异步</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  resolve(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a, c, b</span></span><br></pre></td></tr></table></figure>\n<p>使用过 Promise 的人都知道输出 a, c, b，但有多少人可以清楚地说出从创建 Promise 对象到执行完回调的过程？下面是一个完整的解释：</p>\n<p><strong>构造函数中的输出执行是同步的，输出 a, 执行 resolve 函数，将 Promise 对象状态置为 resolved，输出 c。同时注册这个 Promise 对象的回调 then 函数。整个脚本执行完，stack 清空。event loop 检查到 stack 为空，再检查 microtask 队列中是否有任务，发现了 Promise 对象的 then 回调函数产生的 microtask，推入 stack，执行。输出 b，event loop的列队为空，stack 为空，脚本执行完毕。</strong></p>\n<h3 id=\"Promise-构造函数，选择平台的-microtask-实现\"><a href=\"#Promise-构造函数，选择平台的-microtask-实现\" class=\"headerlink\" title=\"Promise 构造函数，选择平台的 microtask 实现\"></a>Promise 构造函数，选择平台的 microtask 实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Simply choose a microtask</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncFn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> process === <span class=\"string\">'object'</span> &amp;&amp; process !== <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">typeof</span>(process.nextTick) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> process.nextTick</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(setImmediate) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setImmediate</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> setTimeout</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// States</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'PENDING'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">'RESOLVED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'REJECTED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Constructor</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MimiPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = PENDING</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.executedData = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.multiPromise2 = []</span><br><span class=\"line\"></span><br><span class=\"line\">  resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    settlePromise(<span class=\"keyword\">this</span>, RESOLVED, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  reject = <span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    settlePromise(<span class=\"keyword\">this</span>, REJECTED, reason)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  executor(resolve, reject)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>state 和 executedData 都容易理解，但是必须要理解一下为什么要维护一个 multiPromise2 数组。由于规范中说明，每个调用过 then 方法的 promise 对象必须返回一个新的 promise2 对象，所以最好的方法是当调用 then 方法的时候将一个属于这个 then 方法的 promise2 加入队列，在 promise 对象中维护这些新的 promise2 的状态。</p>\n<ul>\n<li>executor： promise 构造函数的执行函数参数</li>\n<li>state：promise 的状态</li>\n<li>multiPromise2：维护的每个注册 then 方法需要返回的新 promise2</li>\n<li>resolve：函数定义了将对象设置为 RESOLVED 的过程</li>\n<li>reject：函数定义了将对象设置为 REJECTED 的过程</li>\n</ul>\n<p>最后执行构造函数 executor，并调用 promise 内部的私有方法 resolve 和 reject。</p>\n<h3 id=\"settlePromise-如何将一个新建的-Promise-settled\"><a href=\"#settlePromise-如何将一个新建的-Promise-settled\" class=\"headerlink\" title=\"settlePromise 如何将一个新建的 Promise settled\"></a>settlePromise 如何将一个新建的 Promise settled</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Settle any promise, set state and value, check if there is</span></span><br><span class=\"line\"><span class=\"comment\">// any then callback and async process them with the origin promise,</span></span><br><span class=\"line\"><span class=\"comment\">// return promise2(aka promise2), and callback itself.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settlePromise</span>(<span class=\"params\">promise, executedState, executedData</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (promise.state !== PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  promise.state = executedState</span><br><span class=\"line\">  promise.executedData = executedData</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (promise.multiPromise2.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> callbackType = executedState === RESOLVED ? <span class=\"string\">\"resolvedCallback\"</span> : <span class=\"string\">\"rejectedCallback\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (promise2 <span class=\"keyword\">of</span> promise.multiPromise2) &#123;</span><br><span class=\"line\">      asyncProcessCallback(promise, promise2, promise2[callbackType])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个判断条件很重要，因为 Promise 的状态是不可逆的。在 settlePromise 的过程中假如状态不是 PENDING，则不需要继续执行下去。</p>\n<p>当前 settlePromise 的环境，可以有三种情况：</p>\n<ul>\n<li>异步延迟执行 settlePromise 方法，线程已经同步注册好 then 方法，需要执行所有注册的 then 回调函数；</li>\n<li>同步执行 settlePromise 方法，then 方法未执行，后面需要执行的 then方法会在注册的过程中直接执行；</li>\n<li>无论执行异步 settlePromise 还是同步 settlePromise 方法，并没有注册的 then 方法需要执行，只需要将本 Promise 对象的状态设置好即可。</li>\n</ul>\n<h3 id=\"then-方法的注册和立即执行\"><a href=\"#then-方法的注册和立即执行\" class=\"headerlink\" title=\"then 方法的注册和立即执行\"></a>then 方法的注册和立即执行</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MimiPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolvedCallback, rejectedCallback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2 = <span class=\"keyword\">new</span> MimiPromise(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> resolvedCallback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    promise2.resolvedCallback = resolvedCallback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> rejectedCallback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    promise2.rejectedCallback = rejectedCallback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.multiPromise2.push(promise2)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === RESOLVED) &#123;</span><br><span class=\"line\">    asyncProcessCallback(<span class=\"keyword\">this</span>, promise2, promise2.resolvedCallback)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === REJECTED) &#123;</span><br><span class=\"line\">    asyncProcessCallback(<span class=\"keyword\">this</span>, promise2, promise2.rejectedCallback)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个注册 then 方法都需要返回一个新的 promise2 对象，根据当前 promise 对象的 state，会出现三种情况：</p>\n<ul>\n<li>当前 promise 对象处于 PENDING 状态。构造函数异步执行了 settlePromise 方法，需要将这个 then 方法对应返回的 promise2 放入当前 promise 的 multiPromise2 队列当中，返回这个 promise2。以后当 settlePromise 方法异步执行的时候，执行全部注册的 then 回调方法</li>\n<li>当前 promise 对象处于 RESOLVED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。</li>\n<li>当前 promise 对象处于 REJECTED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。</li>\n</ul>\n<h3 id=\"异步执行回调函数\"><a href=\"#异步执行回调函数\" class=\"headerlink\" title=\"异步执行回调函数\"></a>异步执行回调函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Async process callback with origin promise and promise2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncProcessCallback</span>(<span class=\"params\">promise, promise2, callback</span>) </span>&#123;</span><br><span class=\"line\">  asyncFn(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!callback) &#123;</span><br><span class=\"line\">      settlePromise(promise2, promise.state, promise.executedData);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      x = callback(promise.executedData)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      settlePromise(promise2, REJECTED, e)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    settleWithX(promise2, x)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用到我们之前选取的平台异步执行函数，异步执行 callback。假如 callback 没有定义，则将返回 promise2 的状态转换为当前 promise 的状态。然后将 callback 执行。最后再 settleWithX promise2 与 callback 返回的对象 x。</p>\n<h3 id=\"最后的-settleWithX-和-settleXthen\"><a href=\"#最后的-settleWithX-和-settleXthen\" class=\"headerlink\" title=\"最后的 settleWithX 和 settleXthen\"></a>最后的 settleWithX 和 settleXthen</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settleWithX</span> (<span class=\"params\">p, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === p &amp;&amp; x) &#123;</span><br><span class=\"line\">    settlePromise(p, REJECTED, <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"promise_circular_chain\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xthen, type = <span class=\"keyword\">typeof</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (type === <span class=\"string\">\"function\"</span> || type === <span class=\"string\">\"object\"</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xthen = x.then;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      settlePromise(p, REJECTED, err);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> xthen === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">      settleXthen(p, x, xthen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      settlePromise(p, RESOLVED, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    settlePromise(p, RESOLVED, x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settleXthen</span> (<span class=\"params\">p, x, xthen</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xthen.call(x, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      settleWithX(p, y);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      settlePromise(p, REJECTED, r);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x) &#123;</span><br><span class=\"line\">      settlePromise(p, REJECTED, err);</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","plink":"https://vincentdou.github.io/blog/post/2018-11-20-Promise实现详解/","type":"post"},{"layout":"post","title":"[转]Vuex框架原理与源码分析","date":"2018-07-24T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> 原文：[Vuex 框架原理与源码分析](https://juejin.im/entry/5af5d048f265da0b7b35f94e)\n\nVuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过 action–mutation–state change 的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。\n\n最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。\n\n先将问题抛出来，使学习和研究更有针对性：\n\n**1. 使用 Vuex 只需执行`Vue.use(Vuex)`，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？**\n**2. state 内部是如何实现支持模块配置和模块嵌套的？**\n**3. 在执行 dispatch 触发 action（commit 同理）的时候，只需传入`（type, payload）`，action 执行函数中第一个参数 store 从哪里获取的？**\n**4. 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？**\n**5. 调试时的“时空穿梭”功能是如何实现的？**\n\n> 注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex 官方文档进行基础概念的学习。\n\n## 一、框架核心流程\n\n进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb55247?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：\n\n- Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。\n- dispatch：操作行为触发方法，是唯一能执行 action 的方法。\n- actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了`Promise`的封装，以支持 action 的链式触发。\n- commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。\n- mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。\n- state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。\n- getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了  render 中，Vue Components 通过该方法读取全局 state 对象。\n- Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。\n\n## 二、目录结构介绍\n\n打开 Vuex 项目，看下源码目录结构。\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb88ab4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\nVuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：\n\n- module：提供 module 对象与 module 对象树的创建功能；\n- plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；\n- helpers.js：提供 action、mutations 以及 getters 的查找 API；\n- index.js：是源码主入口文件，提供 store 的各 module 构建安装；\n- mixin.js：提供了 store 在 Vue 实例上的装载注入；\n- util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。\n\n## 三、初始化装载与注入\n\n了解大概的目录及对应功能后，下面开始进行源码分析。index.js 中包含了所有的核心代码，从该文件入手进行分析。\n\n### 3.1 装载实例\n\n先看个简单的例子：\n\n```js\n/**\n *  store.js 文件\n *  创建 store 对象，配置 state、action、mutation 以及 getter\n *   \n **/\n \nimport Vue from 'vue'\nimport Vuex from 'vuex'\n \n// install Vuex 框架\nVue.use(Vuex)\n \n// 创建并导出 store 对象。为了方便，不配置任何参数\nexport default new Vuex.Store()\n```\n\nstore.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。\n\n```js\n/**\n *  vue-index.js 文件\n *  \n *\n **/\n \nimport Vue from 'vue'\nimport App from './../pages/app.vue'\nimport store from './store.js'\n \nnew Vue({\n  el: '#root',\n  router,\n  store, \n  render: h => h(App)\n})\n```\n\n然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。\n\n如**问题1**所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。\n\n### 3.2 装载分析\n\nindex.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。\n\n```js\nlet Vue\n```\n\n然后判断若处于浏览器环境下且加载过 Vue，则执行`install`方法。\n\n```js\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n```\n\n`install`方法将 Vuex 装载到 Vue 对象上，`Vue.use(Vuex)`也是通过它执行，先看下`Vue.use`方法实现：\n\n```js\nfunction (plugin: Function | Object) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    // 实际执行插件的 install 方法\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}\n```\n\n若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行`applyMixin`方法，`install`实现如下：\n\n```js\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n\n来看下`applyMixin`方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的`_init`方法，实现注入。\n\n```js\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n \n  if (version >= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n}\n```\n\n具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的 `$store`属性上，子组件从其父组件引用`$store`属性，层层嵌套进行设置。在任意组件中执行`this.$store`都能找到装载的那个 store 对象，`vuexInit`方法实现如下：\n\n```js\nfunction vuexInit () {\n  const options = this.$options\n  // store injection\n  if (options.store) {\n    this.$store = options.store\n  } else if (options.parent && options.parent.$store) {\n    this.$store = options.parent.$store\n  }\n}\n```\n\n看个图例理解下 store 的传递。\n\n页面 Vue 结构图：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4ba6e4a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n对应 store 流向：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bc0c0a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n## 四、store 对象构造\n\n上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了**问题1**。接下来详细分析 store 对象的内部功能和具体实现，来解答 **为什么actions、getters、mutations 中能从 arguments[0] 中拿到 store 的相关数据?** 等问题。\n\nstore 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b774c3c40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### 4.1 环境判断\n\n开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。\n\n```js\nconstructor (options = {}) {\n  assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n  assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n}\n```\n\n在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：\n\n1. 已经执行安装函数进行装载；\n2. 支持`Promise`语法。\n\n`assert`函数是一个简单的断言函数的实现，一行代码即可实现。\n\n```js\nfunction assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n```\n\n### 4.2 数据初始化、module 树构造\n\n环境判断后，根据`new`构造传入的`options`或默认值，初始化内部数据。\n\n```js\nconst {\n    state = {},\n    plugins = [],\n    strict = false\n} = options\n \n// store internal state\nthis._committing = false // 是否在进行提交状态标识\nthis._actions = Object.create(null) // acitons 操作对象\nthis._mutations = Object.create(null) // mutations 操作对象\nthis._wrappedGetters = Object.create(null) // 封装后的 getters 集合对象\nthis._modules = new ModuleCollection(options) // Vuex 支持 store 分模块传入，存储分析后的 modules\nthis._modulesNamespaceMap = Object.create(null) // 模块命名空间 map\nthis._subscribers = [] // 订阅函数集合，Vuex 提供了 subscribe 功能\nthis._watcherVM = new Vue() // Vue 组件用于 watch 监视变化\n```\n\n调用`new Vuex.store(options)`时传入的`options`对象，用于构造`ModuleCollection`类，下面看看其功能。\n\n```js\nconstructor (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false)\n \n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, (rawModule, key) => {\n      this.register([key], rawModule, false)\n    })\n  }\n}\n```\n\n`ModuleCollection`主要将传入的`options`对象整个构造为一个 module 对象，并循环调用`this.register([key], rawModule, false)`为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后`options`对象被构造成一个完整的组件树。`ModuleCollection`类还提供了 modules 的更替功能，详细实现可以查看源文件 [module-collection.js](https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js)。\n\n### 4.3 dispatch 与 commit 设置\n\n继续回到 store 的构造函数代码。\n\n```js\n// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\n \nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\n \nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}\n```\n\n封装替换原型中的 dispatch 和 commit 方法，**将 this 指向当前 store 对象**。dispatch 和 commit 方法具体实现如下：\n\n```js\ndispatch (_type, _payload) {\n  // check object-style dispatch\n  const {\n      type,\n      payload\n  } = unifyObjectStyle(_type, _payload) // 配置参数处理\n \n  // 当前 type 下所有 action 处理函数集合\n  const entry = this._actions[type]\n  if (!entry) {\n    console.error(`[vuex] unknown action type: ${type}`)\n    return\n  }\n  return entry.length > 1\n      ? Promise.all(entry.map(handler => handler(payload)))\n      : entry[0](payload)\n}\n```\n\n前面提到，dispatch 的功能是触发并传递一些参数`(payload)`给对应 type 的 action 。因为其支持2种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的`this._actions[type]`以及下面的`this._mutations[type]`均是处理过的函数集合，具体内容留到后面进行分析）。\n\ncommit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。\n\n```js\ncommit (_type, _payload, _options) {\n  // check object-style commit\n  const {\n      type,\n      payload,\n      options\n  } = unifyObjectStyle(_type, _payload, _options)\n \n  const mutation = { type, payload }\n  const entry = this._mutations[type]\n  if (!entry) {\n    console.error(`[vuex] unknown mutation type: ${type}`)\n    return\n  }\n  // 专用修改 state 方法，其他修改 state 方法均是非法修改\n  this._withCommit(() => {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n \n  // 订阅者函数遍历执行，传入当前的 mutation 对象和当前的 state\n  this._subscribers.forEach(sub => sub(mutation, this.state))\n \n  if (options && options.silent) {\n    console.warn(\n        `[vuex] mutation type: ${type}. Silent option has been removed. ` +\n        'Use the filter functionality in the vue-devtools'\n    )\n  }\n}\n```\n\n该方法同样支持2种调用方法。先进行参数适配，判断触发 mutation type，利用`_withCommit`方法执行本次批量触发`mutation`处理函数，并传入`payload`参数。执行完成后，通知所有 `_subscribers`（订阅函数）本次操作的`mutation`对象以及当前的 state 状态，如果传入了已经移除的`silent`选项则进行提示警告。\n\n### 4.4 state修改方法\n\n`_withCommit`是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。\n\n```js\n_withCommit (fn) {\n  // 保存之前的提交状态\n  const committing = this._committing\n \n  // 进行本次提交，若不设置为 true，直接修改 state，strict 模式下，Vuex 将会产生非法修改 state 的警告\n  this._committing = true\n \n  // 执行 state 的修改操作\n  fn()\n \n  // 修改完成，还原本次修改之前的状态\n  this._committing = committing\n}\n```\n\n缓存执行时的`committing`状态将当前状态设置为`true`后进行本次提交操作，待操作完毕后，将`committing`状态还原为之前的状态。\n\n### 4.5 module安装\n\n绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（`installModule`）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。\n\n```js\n// strict mode\nthis.strict = strict\n \n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)\n```\n\n#### 4.5.1 初始化rootState\n\n上述代码的备注中，提到`installModule`方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到`this._wrappedGetters`属性中，让我们看看其中的代码实现。\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n \n  // register in namespace map\n  if (namespace) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n \n  // 非根组件设置 state 方法\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n \n  ······\n```\n\n`installModule`函数可接收5个参数，`store`、`rootState`、`path`、`module`、`hot`。`store`表示当前 Store 实例，`rootState`表示根 state，`path`表示当前嵌套模块的路径数组，`module`表示当前安装的模块，`hot`当动态改变 modules 或者热更新的时候为`true`。\n\n判断是否是根目录，以及是否设置了命名空间，若存在则在`namespace`中进行 module 的存储，在不是根组件且不是`hot`条件的情况下，通过`getNestedState`方法拿到该 module 父级的 state，拿到其所在的 moduleName，调用`Vue.set(parentState, moduleName, module.state)`方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。`getNestedState`方法代码很简单，分析 path 拿到 state，如下。\n\n\n```js\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) => state[key], state)\n    : state\n}\n```\n\n#### 4.5.2 module上下文环境设置\n\n```js\nconst local = module.context = makeLocalContext(store, namespace, path)\n```\n\n命名空间和根目录条件判断完毕后，接下来定义`local`变量和`module.context`的值，执行`makeLocalContext`方法，**为该 module 设置局部的`dispatch`、`commit`方法以及`getters`和`state`**（由于`namespace`的存在需要做兼容处理）。\n\n#### 4.5.3 mutations、actions以及getters注册\n\n定义`local`环境后，循环注册我们在`options`中配置的`action`以及`mutation`等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b78b2b58f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n下面分析代码逻辑：\n\n```js\n// 注册对应模块的 mutation，供 state 修改使用\nmodule.forEachMutation((mutation, key) => {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n \n// 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用\nmodule.forEachAction((action, key) => {\n  const namespacedType = namespace + key\n  registerAction(store, namespacedType, action, local)\n})\n \n// 注册对应模块的 getters，供 state 读取使用\nmodule.forEachGetter((getter, key) => {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})\n```\n\n`registerMutation`方法中，获取 store 中的对应`mutation type`的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行`commit(‘xxx’, payload)`的时候，type 为 xxx 的`mutation`的所有 handler 都会接收到`state`以及`payload`，这就是在 handler 里面拿到 state 的原因。\n\n```js\nfunction registerMutation (store, type, handler, local) {\n  // 取出对应 type 的 mutations-handler 集合\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  // commit 实际调用的不是我们传入的 handler，而是经过封装的\n  entry.push(function wrappedMutationHandler (payload) {\n    // 调用 handler 并将 state 传入\n    handler(local.state, payload)\n  })\n}\n```\n\naction 和 getter 的注册也是同理的，看一下代码（注：前面提到的 `this.actions`以及`this.mutations`在此处进行设置）。\n\n```js\nfunction registerAction (store, type, handler, local) {\n  // 取出对应 type 的 actions-handler 集合\n  const entry = store._actions[type] || (store._actions[type] = [])\n  // 存储新的封装过的 action-handler\n  entry.push(function wrappedActionHandler (payload, cb) {\n    // 传入 state 等对象供我们原 action-handler 使用\n    let res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    // action 需要支持 promise 进行链式调用，这里进行兼容处理\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n \nfunction registerGetter (store, type, rawGetter, local) {\n  // getters 只允许存在一个处理函数，若重复需要报错\n  if (store._wrappedGetters[type]) {\n    console.error(`[vuex] duplicate getter key: ${type}`)\n    return\n  }\n \n  // 存储封装过的 getters 处理函数\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    // 为原 getters 传入对应状态\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}\n```\n\n**action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。**\n\n#### 4.5.4 子module安装\n\n注册完了根组件的`actions`、`mutations`以及`getters`后，递归调用自身，为子组件注册其`state`、`actions`、`mutations`以及`getters`等。\n\n```js\nmodule.forEachChild((child, key) => {\n  installModule(store, rootState, path.concat(key), child, hot)\n})\n```\n\n#### 4.5.5 实例结合\n\n前面介绍了`dispatch`和`commit`方法以及`actions`等的实现，下面结合一个官方的购物车实例中的部分代码来加深理解。\n\nVuex 配置代码：\n\n```js\n/\n *  store-index.js store 配置文件\n *\n /\n \nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport * as actions from './actions'\nimport * as getters from './getters'\nimport cart from './modules/cart'\nimport products from './modules/products'\nimport createLogger from '../../../src/plugins/logger'\n \nVue.use(Vuex)\n \nconst debug = process.env.NODE_ENV !== 'production'\n \nexport default new Vuex.Store({\n  actions,\n  getters,\n  modules: {\n    cart,\n    products\n  },\n  strict: debug,\n  plugins: debug ? [createLogger()] : []\n})\n```\n\nVuex 组件 module 中各模块 state 配置代码部分：\n\n```js\n/**\n *  cart.js\n *\n **/\n \nconst state = {\n  added: [],\n  checkoutStatus: null\n}\n \n/**\n *  products.js\n *\n **/\n \nconst state = {\n  all: []\n}\n```\n\n加载上述配置后，页面 state 结构如下图：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b79f8a6e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\nstate 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。\n\nVuecart 组件代码部分：\n\n```js\n/**\n *  Cart.vue 省略 template 代码，只看 script 部分\n *\n **/\n \nexport default {\n  methods: {\n    // 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch 方法\n    checkout (products) {\n      this.$store.dispatch('checkout', products)\n    }\n  }\n}\n```\n\nVuexcart.js 组件 action 配置代码部分：\n\n```js\nconst actions = {\n  checkout ({ commit, state }, products) {\n    const savedCartItems = [...state.added] // 存储添加到购物车的商品\n    commit(types.CHECKOUT_REQUEST) // 设置提交结算状态\n    shop.buyProducts( // 提交 api 请求，并传入成功与失败的 cb-func\n      products,\n      () => commit(types.CHECKOUT_SUCCESS), // 请求返回成功则设置提交成功状态\n      () => commit(types.CHECKOUT_FAILURE, { savedCartItems }) // 请求返回失败则设置提交失败状态\n    )\n  }\n}\n```\n\nVue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 `checkout`，payload 值为`products`，在源码中 dispatch 方法在所有注册过的 actions 中查找`checkout`的对应执行数组，取出循环执行。执行的是被封装过的被命名为`wrappedActionHandler`的方法，真正传入的`checkout`的执行函数在`wrappedActionHandler`这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：\n\n```js\nfunction wrappedActionHandler (payload, cb) {\n  let res = handler({\n    dispatch: local.dispatch,\n    commit: local.commit,\n    getters: local.getters,\n    state: local.state,\n    rootGetters: store.getters,\n    rootState: store.state\n  }, payload, cb)\n  if (!isPromise(res)) {\n    res = Promise.resolve(res)\n  }\n  if (store._devtoolHook) {\n    return res.catch(err => {\n      store._devtoolHook.emit('vuex:error', err)\n      throw err\n    })\n  } else {\n    return res\n  }\n}\n```\n\nhandler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为`types.CHECKOUT_REQUEST`的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用`function wrappedMutationHandler (payload) { handler(local.state, payload)}`封装函数来实际调用配置的 mutation 方法。\n\n看到完源码分析和上面的小实例，应该能理解`dispatch`、`action`、`commit` 和`mutation`的工作原理了。接着看源码，看看`getters`是如何实现 state 实时访问的。\n\n### 4.6 store._vm组件设置\n\n执行完各 module 的 install 后，执行`resetStoreVM`方法，进行 store 组件的初始化。\n\n```js\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)\n```\n\n综合前面的分析可以了解到，**Vuex 其实构建的就是一个名为`store`的`vm`组件，所有配置的`state`、`actions`、`mutations`以及`getters`都是其组件的属性，所有的操作都是对这个`vm`组件进行的。**\n\n一起看下`resetStoreVM`方法的内部实现。\n\n```js\nfunction resetStoreVM (store, state) {\n  const oldVm = store._vm // 缓存前 vm 组件\n \n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n \n  // 循环所有处理过的 getters，并新建 computed 对象进行存储，通过Object.defineProperty 方法为 getters 对象建立属性，使得我们通过 this.$store.getters.xxxgetter 能够访问到该 getters\n  forEachValue(wrappedGetters, (fn, key) => {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n \n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n \n  // 暂时将 Vue 设为静默模式，避免报出用户加载的某些插件触发的警告\n  Vue.config.silent = true   \n  // 设置新的 storeVm，将当前初始化的 state 以及 getters 作为 computed 属性（刚刚遍历生成的）\n  store._vm = new Vue({\n    data: { state },\n    computed\n  })\n \n  // 恢复 Vue 的模式\n  Vue.config.silent = silent\n \n  // enable strict mode for new vm\n  if (store.strict) {\n    // 该方法对 state 执行 $watch 以禁止从 mutation 外部修改 state\n    enableStrictMode(store)\n  }\n \n  // 若不是初始化过程执行的该方法，将旧的组件 state 设置为 null，强制更新所有监听者(watchers)，待更新生效，DOM 更新完成后，执行 vm 组件的 destroy 方法进行销毁，减少内存的占用\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(() => {\n      oldVm.state = null\n    })\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n```\n\n`resetStoreVm`方法创建了当前`store`实例的`_vm`组件，至此`store`就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。\n\n```js\nfunction enableStrictMode (store) {\n  store._vm.$watch('state', () => {\n    assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n  }, { deep: true, sync: true })\n}\n```\n\n很简单的应用，监视 state 的变化，如果没有通过`this._withCommit()`方法进行 state 修改，则报错。\n\n### 4.7 plugin注入\n\n最后执行`plugin`的植入。\n\n```js\nplugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n```\n\n`devtoolPlugin`提供的功能有3个：\n\n```js\n// 1. 触发 Vuex 组件初始化的 hook\ndevtoolHook.emit('vuex:init', store)\n \n// 2. 提供“时空穿梭”功能，即 state 操作的前进和倒退\ndevtoolHook.on('vuex:travel-to-state', targetState => {\n  store.replaceState(targetState)\n})\n \n// 3. mutation 被执行时，触发 hook，并提供被触发的 mutation 函数和当前的 state 状态\nstore.subscribe((mutation, state) => {\n  devtoolHook.emit('vuex:mutation', mutation, state)\n})\n```\n\n源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。\n\n### 五、总结\n\n最后我们回过来看文章开始提出的5个问题。\n\n**1. 问：使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？**\n\n> 答：`Vue.use(Vuex)`方法执行的是`install`方法，它实现了 Vue 实例对象的`init`方法封装和注入，使传入的`store`对象被设置到 Vue 上下文环境的`$store`中。因此在 Vue Component 任意地方都能够通过`this.$store`访问到该`store`。\n\n**2. 问：state内部支持模块配置和模块嵌套，如何实现的？**\n\n> 答：在`store`构造方法中有`makeLocalContext`方法，所有`module`都会有一个`local context`，根据配置时的`path`进行匹配。所以执行如`dispatch(‘submitOrder’, payload)`这类`action`时，默认的拿到都是`module`的`local state` ，如果要访问最外层或者是其他`module`的`state`，只能从`rootState`按照`path`路径逐步进行访问。\n\n**3.  问：在执行dispatch触发action(commit同理)的时候，只需传入(type, payload)，action执行函数中第一个参数store从哪里获取的？**\n\n> 答：`store`初始化时，所有配置的`action`和`mutation`以及`getters`均被封装过。在执行如`dispatch(‘submitOrder’, payload)`的时候，`actions`中`type`为`submitOrder`的所有处理方法都是被封装后的，其第一个参数为当前的`store`对象，所以能够获取到`{ dispatch, commit, state, rootState }`等数据。\n\n**4. 问：Vuex如何区分state是外部直接修改，还是通过mutation方法修改的？**\n\n> 答：Vuex 中修改`state`的唯一渠道就是执行`commit(‘xx’, payload)`方法，其底层通过执行`this._withCommit(fn)`设置`_committing`标志变量为`true`，然后才能修改`state`，修改完毕还需要还原`_committing`变量。外部修改虽然能够直接修改`state`，但是并没有修改`_committing`标志位，所以只要`watch`一下`state`，`state` change 时判断是否`_committing`值为`true`，即可判断修改的合法性。\n\n**5. 问：调试时的”时空穿梭”功能是如何实现的？**\n\n> 答：`devtoolPlugin`中提供了此功能。因为`dev`模式下所有的`state` change 都会被记录下来，’时空穿梭’功能其实就是将当前的`state`替换为记录中某个时刻的`state`状态，利用`store.replaceState(targetState)`方法将执行`this._vm.state = state`实现。\n\n源码中还有一些工具函数类似`registerModule`、`unregisterModule`、`hotUpdate`、`watch`以及`subscribe`等，如有兴趣可以打开源码看看，这里不再细述。","source":"_posts/2018-07-25-Vuex框架原理与源码分析.markdown","raw":"---\nlayout:     post\ntitle:      \"[转]Vuex框架原理与源码分析\"\ndate:       2018-07-25\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - vue\n---\n\n> 原文：[Vuex 框架原理与源码分析](https://juejin.im/entry/5af5d048f265da0b7b35f94e)\n\nVuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过 action–mutation–state change 的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。\n\n最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。\n\n先将问题抛出来，使学习和研究更有针对性：\n\n**1. 使用 Vuex 只需执行`Vue.use(Vuex)`，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？**\n**2. state 内部是如何实现支持模块配置和模块嵌套的？**\n**3. 在执行 dispatch 触发 action（commit 同理）的时候，只需传入`（type, payload）`，action 执行函数中第一个参数 store 从哪里获取的？**\n**4. 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？**\n**5. 调试时的“时空穿梭”功能是如何实现的？**\n\n> 注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex 官方文档进行基础概念的学习。\n\n## 一、框架核心流程\n\n进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb55247?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：\n\n- Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。\n- dispatch：操作行为触发方法，是唯一能执行 action 的方法。\n- actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了`Promise`的封装，以支持 action 的链式触发。\n- commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。\n- mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。\n- state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。\n- getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了  render 中，Vue Components 通过该方法读取全局 state 对象。\n- Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。\n\n## 二、目录结构介绍\n\n打开 Vuex 项目，看下源码目录结构。\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb88ab4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\nVuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：\n\n- module：提供 module 对象与 module 对象树的创建功能；\n- plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；\n- helpers.js：提供 action、mutations 以及 getters 的查找 API；\n- index.js：是源码主入口文件，提供 store 的各 module 构建安装；\n- mixin.js：提供了 store 在 Vue 实例上的装载注入；\n- util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。\n\n## 三、初始化装载与注入\n\n了解大概的目录及对应功能后，下面开始进行源码分析。index.js 中包含了所有的核心代码，从该文件入手进行分析。\n\n### 3.1 装载实例\n\n先看个简单的例子：\n\n```js\n/**\n *  store.js 文件\n *  创建 store 对象，配置 state、action、mutation 以及 getter\n *   \n **/\n \nimport Vue from 'vue'\nimport Vuex from 'vuex'\n \n// install Vuex 框架\nVue.use(Vuex)\n \n// 创建并导出 store 对象。为了方便，不配置任何参数\nexport default new Vuex.Store()\n```\n\nstore.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。\n\n```js\n/**\n *  vue-index.js 文件\n *  \n *\n **/\n \nimport Vue from 'vue'\nimport App from './../pages/app.vue'\nimport store from './store.js'\n \nnew Vue({\n  el: '#root',\n  router,\n  store, \n  render: h => h(App)\n})\n```\n\n然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。\n\n如**问题1**所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。\n\n### 3.2 装载分析\n\nindex.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。\n\n```js\nlet Vue\n```\n\n然后判断若处于浏览器环境下且加载过 Vue，则执行`install`方法。\n\n```js\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n```\n\n`install`方法将 Vuex 装载到 Vue 对象上，`Vue.use(Vuex)`也是通过它执行，先看下`Vue.use`方法实现：\n\n```js\nfunction (plugin: Function | Object) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    // 实际执行插件的 install 方法\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}\n```\n\n若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行`applyMixin`方法，`install`实现如下：\n\n```js\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n\n来看下`applyMixin`方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的`_init`方法，实现注入。\n\n```js\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n \n  if (version >= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n}\n```\n\n具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的 `$store`属性上，子组件从其父组件引用`$store`属性，层层嵌套进行设置。在任意组件中执行`this.$store`都能找到装载的那个 store 对象，`vuexInit`方法实现如下：\n\n```js\nfunction vuexInit () {\n  const options = this.$options\n  // store injection\n  if (options.store) {\n    this.$store = options.store\n  } else if (options.parent && options.parent.$store) {\n    this.$store = options.parent.$store\n  }\n}\n```\n\n看个图例理解下 store 的传递。\n\n页面 Vue 结构图：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4ba6e4a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n对应 store 流向：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bc0c0a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n## 四、store 对象构造\n\n上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了**问题1**。接下来详细分析 store 对象的内部功能和具体实现，来解答 **为什么actions、getters、mutations 中能从 arguments[0] 中拿到 store 的相关数据?** 等问题。\n\nstore 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b774c3c40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### 4.1 环境判断\n\n开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。\n\n```js\nconstructor (options = {}) {\n  assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n  assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n}\n```\n\n在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：\n\n1. 已经执行安装函数进行装载；\n2. 支持`Promise`语法。\n\n`assert`函数是一个简单的断言函数的实现，一行代码即可实现。\n\n```js\nfunction assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n```\n\n### 4.2 数据初始化、module 树构造\n\n环境判断后，根据`new`构造传入的`options`或默认值，初始化内部数据。\n\n```js\nconst {\n    state = {},\n    plugins = [],\n    strict = false\n} = options\n \n// store internal state\nthis._committing = false // 是否在进行提交状态标识\nthis._actions = Object.create(null) // acitons 操作对象\nthis._mutations = Object.create(null) // mutations 操作对象\nthis._wrappedGetters = Object.create(null) // 封装后的 getters 集合对象\nthis._modules = new ModuleCollection(options) // Vuex 支持 store 分模块传入，存储分析后的 modules\nthis._modulesNamespaceMap = Object.create(null) // 模块命名空间 map\nthis._subscribers = [] // 订阅函数集合，Vuex 提供了 subscribe 功能\nthis._watcherVM = new Vue() // Vue 组件用于 watch 监视变化\n```\n\n调用`new Vuex.store(options)`时传入的`options`对象，用于构造`ModuleCollection`类，下面看看其功能。\n\n```js\nconstructor (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false)\n \n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, (rawModule, key) => {\n      this.register([key], rawModule, false)\n    })\n  }\n}\n```\n\n`ModuleCollection`主要将传入的`options`对象整个构造为一个 module 对象，并循环调用`this.register([key], rawModule, false)`为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后`options`对象被构造成一个完整的组件树。`ModuleCollection`类还提供了 modules 的更替功能，详细实现可以查看源文件 [module-collection.js](https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js)。\n\n### 4.3 dispatch 与 commit 设置\n\n继续回到 store 的构造函数代码。\n\n```js\n// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\n \nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\n \nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}\n```\n\n封装替换原型中的 dispatch 和 commit 方法，**将 this 指向当前 store 对象**。dispatch 和 commit 方法具体实现如下：\n\n```js\ndispatch (_type, _payload) {\n  // check object-style dispatch\n  const {\n      type,\n      payload\n  } = unifyObjectStyle(_type, _payload) // 配置参数处理\n \n  // 当前 type 下所有 action 处理函数集合\n  const entry = this._actions[type]\n  if (!entry) {\n    console.error(`[vuex] unknown action type: ${type}`)\n    return\n  }\n  return entry.length > 1\n      ? Promise.all(entry.map(handler => handler(payload)))\n      : entry[0](payload)\n}\n```\n\n前面提到，dispatch 的功能是触发并传递一些参数`(payload)`给对应 type 的 action 。因为其支持2种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的`this._actions[type]`以及下面的`this._mutations[type]`均是处理过的函数集合，具体内容留到后面进行分析）。\n\ncommit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。\n\n```js\ncommit (_type, _payload, _options) {\n  // check object-style commit\n  const {\n      type,\n      payload,\n      options\n  } = unifyObjectStyle(_type, _payload, _options)\n \n  const mutation = { type, payload }\n  const entry = this._mutations[type]\n  if (!entry) {\n    console.error(`[vuex] unknown mutation type: ${type}`)\n    return\n  }\n  // 专用修改 state 方法，其他修改 state 方法均是非法修改\n  this._withCommit(() => {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n \n  // 订阅者函数遍历执行，传入当前的 mutation 对象和当前的 state\n  this._subscribers.forEach(sub => sub(mutation, this.state))\n \n  if (options && options.silent) {\n    console.warn(\n        `[vuex] mutation type: ${type}. Silent option has been removed. ` +\n        'Use the filter functionality in the vue-devtools'\n    )\n  }\n}\n```\n\n该方法同样支持2种调用方法。先进行参数适配，判断触发 mutation type，利用`_withCommit`方法执行本次批量触发`mutation`处理函数，并传入`payload`参数。执行完成后，通知所有 `_subscribers`（订阅函数）本次操作的`mutation`对象以及当前的 state 状态，如果传入了已经移除的`silent`选项则进行提示警告。\n\n### 4.4 state修改方法\n\n`_withCommit`是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。\n\n```js\n_withCommit (fn) {\n  // 保存之前的提交状态\n  const committing = this._committing\n \n  // 进行本次提交，若不设置为 true，直接修改 state，strict 模式下，Vuex 将会产生非法修改 state 的警告\n  this._committing = true\n \n  // 执行 state 的修改操作\n  fn()\n \n  // 修改完成，还原本次修改之前的状态\n  this._committing = committing\n}\n```\n\n缓存执行时的`committing`状态将当前状态设置为`true`后进行本次提交操作，待操作完毕后，将`committing`状态还原为之前的状态。\n\n### 4.5 module安装\n\n绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（`installModule`）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。\n\n```js\n// strict mode\nthis.strict = strict\n \n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)\n```\n\n#### 4.5.1 初始化rootState\n\n上述代码的备注中，提到`installModule`方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到`this._wrappedGetters`属性中，让我们看看其中的代码实现。\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n \n  // register in namespace map\n  if (namespace) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n \n  // 非根组件设置 state 方法\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n \n  ······\n```\n\n`installModule`函数可接收5个参数，`store`、`rootState`、`path`、`module`、`hot`。`store`表示当前 Store 实例，`rootState`表示根 state，`path`表示当前嵌套模块的路径数组，`module`表示当前安装的模块，`hot`当动态改变 modules 或者热更新的时候为`true`。\n\n判断是否是根目录，以及是否设置了命名空间，若存在则在`namespace`中进行 module 的存储，在不是根组件且不是`hot`条件的情况下，通过`getNestedState`方法拿到该 module 父级的 state，拿到其所在的 moduleName，调用`Vue.set(parentState, moduleName, module.state)`方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。`getNestedState`方法代码很简单，分析 path 拿到 state，如下。\n\n\n```js\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) => state[key], state)\n    : state\n}\n```\n\n#### 4.5.2 module上下文环境设置\n\n```js\nconst local = module.context = makeLocalContext(store, namespace, path)\n```\n\n命名空间和根目录条件判断完毕后，接下来定义`local`变量和`module.context`的值，执行`makeLocalContext`方法，**为该 module 设置局部的`dispatch`、`commit`方法以及`getters`和`state`**（由于`namespace`的存在需要做兼容处理）。\n\n#### 4.5.3 mutations、actions以及getters注册\n\n定义`local`环境后，循环注册我们在`options`中配置的`action`以及`mutation`等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b78b2b58f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n下面分析代码逻辑：\n\n```js\n// 注册对应模块的 mutation，供 state 修改使用\nmodule.forEachMutation((mutation, key) => {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n \n// 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用\nmodule.forEachAction((action, key) => {\n  const namespacedType = namespace + key\n  registerAction(store, namespacedType, action, local)\n})\n \n// 注册对应模块的 getters，供 state 读取使用\nmodule.forEachGetter((getter, key) => {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})\n```\n\n`registerMutation`方法中，获取 store 中的对应`mutation type`的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行`commit(‘xxx’, payload)`的时候，type 为 xxx 的`mutation`的所有 handler 都会接收到`state`以及`payload`，这就是在 handler 里面拿到 state 的原因。\n\n```js\nfunction registerMutation (store, type, handler, local) {\n  // 取出对应 type 的 mutations-handler 集合\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  // commit 实际调用的不是我们传入的 handler，而是经过封装的\n  entry.push(function wrappedMutationHandler (payload) {\n    // 调用 handler 并将 state 传入\n    handler(local.state, payload)\n  })\n}\n```\n\naction 和 getter 的注册也是同理的，看一下代码（注：前面提到的 `this.actions`以及`this.mutations`在此处进行设置）。\n\n```js\nfunction registerAction (store, type, handler, local) {\n  // 取出对应 type 的 actions-handler 集合\n  const entry = store._actions[type] || (store._actions[type] = [])\n  // 存储新的封装过的 action-handler\n  entry.push(function wrappedActionHandler (payload, cb) {\n    // 传入 state 等对象供我们原 action-handler 使用\n    let res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    // action 需要支持 promise 进行链式调用，这里进行兼容处理\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n \nfunction registerGetter (store, type, rawGetter, local) {\n  // getters 只允许存在一个处理函数，若重复需要报错\n  if (store._wrappedGetters[type]) {\n    console.error(`[vuex] duplicate getter key: ${type}`)\n    return\n  }\n \n  // 存储封装过的 getters 处理函数\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    // 为原 getters 传入对应状态\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}\n```\n\n**action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。**\n\n#### 4.5.4 子module安装\n\n注册完了根组件的`actions`、`mutations`以及`getters`后，递归调用自身，为子组件注册其`state`、`actions`、`mutations`以及`getters`等。\n\n```js\nmodule.forEachChild((child, key) => {\n  installModule(store, rootState, path.concat(key), child, hot)\n})\n```\n\n#### 4.5.5 实例结合\n\n前面介绍了`dispatch`和`commit`方法以及`actions`等的实现，下面结合一个官方的购物车实例中的部分代码来加深理解。\n\nVuex 配置代码：\n\n```js\n/\n *  store-index.js store 配置文件\n *\n /\n \nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport * as actions from './actions'\nimport * as getters from './getters'\nimport cart from './modules/cart'\nimport products from './modules/products'\nimport createLogger from '../../../src/plugins/logger'\n \nVue.use(Vuex)\n \nconst debug = process.env.NODE_ENV !== 'production'\n \nexport default new Vuex.Store({\n  actions,\n  getters,\n  modules: {\n    cart,\n    products\n  },\n  strict: debug,\n  plugins: debug ? [createLogger()] : []\n})\n```\n\nVuex 组件 module 中各模块 state 配置代码部分：\n\n```js\n/**\n *  cart.js\n *\n **/\n \nconst state = {\n  added: [],\n  checkoutStatus: null\n}\n \n/**\n *  products.js\n *\n **/\n \nconst state = {\n  all: []\n}\n```\n\n加载上述配置后，页面 state 结构如下图：\n\n![](https://user-gold-cdn.xitu.io/2018/5/12/1635035b79f8a6e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\nstate 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。\n\nVuecart 组件代码部分：\n\n```js\n/**\n *  Cart.vue 省略 template 代码，只看 script 部分\n *\n **/\n \nexport default {\n  methods: {\n    // 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch 方法\n    checkout (products) {\n      this.$store.dispatch('checkout', products)\n    }\n  }\n}\n```\n\nVuexcart.js 组件 action 配置代码部分：\n\n```js\nconst actions = {\n  checkout ({ commit, state }, products) {\n    const savedCartItems = [...state.added] // 存储添加到购物车的商品\n    commit(types.CHECKOUT_REQUEST) // 设置提交结算状态\n    shop.buyProducts( // 提交 api 请求，并传入成功与失败的 cb-func\n      products,\n      () => commit(types.CHECKOUT_SUCCESS), // 请求返回成功则设置提交成功状态\n      () => commit(types.CHECKOUT_FAILURE, { savedCartItems }) // 请求返回失败则设置提交失败状态\n    )\n  }\n}\n```\n\nVue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 `checkout`，payload 值为`products`，在源码中 dispatch 方法在所有注册过的 actions 中查找`checkout`的对应执行数组，取出循环执行。执行的是被封装过的被命名为`wrappedActionHandler`的方法，真正传入的`checkout`的执行函数在`wrappedActionHandler`这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：\n\n```js\nfunction wrappedActionHandler (payload, cb) {\n  let res = handler({\n    dispatch: local.dispatch,\n    commit: local.commit,\n    getters: local.getters,\n    state: local.state,\n    rootGetters: store.getters,\n    rootState: store.state\n  }, payload, cb)\n  if (!isPromise(res)) {\n    res = Promise.resolve(res)\n  }\n  if (store._devtoolHook) {\n    return res.catch(err => {\n      store._devtoolHook.emit('vuex:error', err)\n      throw err\n    })\n  } else {\n    return res\n  }\n}\n```\n\nhandler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为`types.CHECKOUT_REQUEST`的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用`function wrappedMutationHandler (payload) { handler(local.state, payload)}`封装函数来实际调用配置的 mutation 方法。\n\n看到完源码分析和上面的小实例，应该能理解`dispatch`、`action`、`commit` 和`mutation`的工作原理了。接着看源码，看看`getters`是如何实现 state 实时访问的。\n\n### 4.6 store._vm组件设置\n\n执行完各 module 的 install 后，执行`resetStoreVM`方法，进行 store 组件的初始化。\n\n```js\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)\n```\n\n综合前面的分析可以了解到，**Vuex 其实构建的就是一个名为`store`的`vm`组件，所有配置的`state`、`actions`、`mutations`以及`getters`都是其组件的属性，所有的操作都是对这个`vm`组件进行的。**\n\n一起看下`resetStoreVM`方法的内部实现。\n\n```js\nfunction resetStoreVM (store, state) {\n  const oldVm = store._vm // 缓存前 vm 组件\n \n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n \n  // 循环所有处理过的 getters，并新建 computed 对象进行存储，通过Object.defineProperty 方法为 getters 对象建立属性，使得我们通过 this.$store.getters.xxxgetter 能够访问到该 getters\n  forEachValue(wrappedGetters, (fn, key) => {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n \n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n \n  // 暂时将 Vue 设为静默模式，避免报出用户加载的某些插件触发的警告\n  Vue.config.silent = true   \n  // 设置新的 storeVm，将当前初始化的 state 以及 getters 作为 computed 属性（刚刚遍历生成的）\n  store._vm = new Vue({\n    data: { state },\n    computed\n  })\n \n  // 恢复 Vue 的模式\n  Vue.config.silent = silent\n \n  // enable strict mode for new vm\n  if (store.strict) {\n    // 该方法对 state 执行 $watch 以禁止从 mutation 外部修改 state\n    enableStrictMode(store)\n  }\n \n  // 若不是初始化过程执行的该方法，将旧的组件 state 设置为 null，强制更新所有监听者(watchers)，待更新生效，DOM 更新完成后，执行 vm 组件的 destroy 方法进行销毁，减少内存的占用\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(() => {\n      oldVm.state = null\n    })\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n```\n\n`resetStoreVm`方法创建了当前`store`实例的`_vm`组件，至此`store`就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。\n\n```js\nfunction enableStrictMode (store) {\n  store._vm.$watch('state', () => {\n    assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n  }, { deep: true, sync: true })\n}\n```\n\n很简单的应用，监视 state 的变化，如果没有通过`this._withCommit()`方法进行 state 修改，则报错。\n\n### 4.7 plugin注入\n\n最后执行`plugin`的植入。\n\n```js\nplugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n```\n\n`devtoolPlugin`提供的功能有3个：\n\n```js\n// 1. 触发 Vuex 组件初始化的 hook\ndevtoolHook.emit('vuex:init', store)\n \n// 2. 提供“时空穿梭”功能，即 state 操作的前进和倒退\ndevtoolHook.on('vuex:travel-to-state', targetState => {\n  store.replaceState(targetState)\n})\n \n// 3. mutation 被执行时，触发 hook，并提供被触发的 mutation 函数和当前的 state 状态\nstore.subscribe((mutation, state) => {\n  devtoolHook.emit('vuex:mutation', mutation, state)\n})\n```\n\n源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。\n\n### 五、总结\n\n最后我们回过来看文章开始提出的5个问题。\n\n**1. 问：使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？**\n\n> 答：`Vue.use(Vuex)`方法执行的是`install`方法，它实现了 Vue 实例对象的`init`方法封装和注入，使传入的`store`对象被设置到 Vue 上下文环境的`$store`中。因此在 Vue Component 任意地方都能够通过`this.$store`访问到该`store`。\n\n**2. 问：state内部支持模块配置和模块嵌套，如何实现的？**\n\n> 答：在`store`构造方法中有`makeLocalContext`方法，所有`module`都会有一个`local context`，根据配置时的`path`进行匹配。所以执行如`dispatch(‘submitOrder’, payload)`这类`action`时，默认的拿到都是`module`的`local state` ，如果要访问最外层或者是其他`module`的`state`，只能从`rootState`按照`path`路径逐步进行访问。\n\n**3.  问：在执行dispatch触发action(commit同理)的时候，只需传入(type, payload)，action执行函数中第一个参数store从哪里获取的？**\n\n> 答：`store`初始化时，所有配置的`action`和`mutation`以及`getters`均被封装过。在执行如`dispatch(‘submitOrder’, payload)`的时候，`actions`中`type`为`submitOrder`的所有处理方法都是被封装后的，其第一个参数为当前的`store`对象，所以能够获取到`{ dispatch, commit, state, rootState }`等数据。\n\n**4. 问：Vuex如何区分state是外部直接修改，还是通过mutation方法修改的？**\n\n> 答：Vuex 中修改`state`的唯一渠道就是执行`commit(‘xx’, payload)`方法，其底层通过执行`this._withCommit(fn)`设置`_committing`标志变量为`true`，然后才能修改`state`，修改完毕还需要还原`_committing`变量。外部修改虽然能够直接修改`state`，但是并没有修改`_committing`标志位，所以只要`watch`一下`state`，`state` change 时判断是否`_committing`值为`true`，即可判断修改的合法性。\n\n**5. 问：调试时的”时空穿梭”功能是如何实现的？**\n\n> 答：`devtoolPlugin`中提供了此功能。因为`dev`模式下所有的`state` change 都会被记录下来，’时空穿梭’功能其实就是将当前的`state`替换为记录中某个时刻的`state`状态，利用`store.replaceState(targetState)`方法将执行`this._vm.state = state`实现。\n\n源码中还有一些工具函数类似`registerModule`、`unregisterModule`、`hotUpdate`、`watch`以及`subscribe`等，如有兴趣可以打开源码看看，这里不再细述。","slug":"2018-07-25-Vuex框架原理与源码分析","published":1,"updated":"2019-01-02T08:49:00.261Z","comments":0,"photos":[],"link":"post/2018-07-25-Vuex框架原理与源码分析","_id":"cjz2epjfv001wn3w51yjarq6j","content":"<blockquote>\n<p>原文：<a href=\"https://juejin.im/entry/5af5d048f265da0b7b35f94e\" target=\"_blank\" rel=\"noopener\">Vuex 框架原理与源码分析</a></p>\n</blockquote>\n<p>Vuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过 action–mutation–state change 的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。</p>\n<p>最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。</p>\n<p>先将问题抛出来，使学习和研究更有针对性：</p>\n<p><strong>1. 使用 Vuex 只需执行<code>Vue.use(Vuex)</code>，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</strong><br><strong>2. state 内部是如何实现支持模块配置和模块嵌套的？</strong><br><strong>3. 在执行 dispatch 触发 action（commit 同理）的时候，只需传入<code>（type, payload）</code>，action 执行函数中第一个参数 store 从哪里获取的？</strong><br><strong>4. 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</strong><br><strong>5. 调试时的“时空穿梭”功能是如何实现的？</strong></p>\n<blockquote>\n<p>注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex 官方文档进行基础概念的学习。</p>\n</blockquote>\n<h2 id=\"一、框架核心流程\">一、框架核心流程<a href=\"post/2018-07-25-Vuex框架原理与源码分析#一、框架核心流程\"></a></h2><p>进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb55247?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：</p>\n<ul>\n<li>Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。</li>\n<li>dispatch：操作行为触发方法，是唯一能执行 action 的方法。</li>\n<li>actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了<code>Promise</code>的封装，以支持 action 的链式触发。</li>\n<li>commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。</li>\n<li>mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。</li>\n<li>state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。</li>\n<li>getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了  render 中，Vue Components 通过该方法读取全局 state 对象。</li>\n<li>Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。</li>\n</ul>\n<h2 id=\"二、目录结构介绍\">二、目录结构介绍<a href=\"post/2018-07-25-Vuex框架原理与源码分析#二、目录结构介绍\"></a></h2><p>打开 Vuex 项目，看下源码目录结构。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb88ab4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>Vuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：</p>\n<ul>\n<li>module：提供 module 对象与 module 对象树的创建功能；</li>\n<li>plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；</li>\n<li>helpers.js：提供 action、mutations 以及 getters 的查找 API；</li>\n<li>index.js：是源码主入口文件，提供 store 的各 module 构建安装；</li>\n<li>mixin.js：提供了 store 在 Vue 实例上的装载注入；</li>\n<li>util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。</li>\n</ul>\n<h2 id=\"三、初始化装载与注入\">三、初始化装载与注入<a href=\"post/2018-07-25-Vuex框架原理与源码分析#三、初始化装载与注入\"></a></h2><p>了解大概的目录及对应功能后，下面开始进行源码分析。index.js 中包含了所有的核心代码，从该文件入手进行分析。</p>\n<h3 id=\"3-1-装载实例\">3.1 装载实例<a href=\"post/2018-07-25-Vuex框架原理与源码分析#3-1-装载实例\"></a></h3><p>先看个简单的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  store.js 文件</span></span><br><span class=\"line\"><span class=\"comment\"> *  创建 store 对象，配置 state、action、mutation 以及 getter</span></span><br><span class=\"line\"><span class=\"comment\"> *   </span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// install Vuex 框架</span></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 创建并导出 store 对象。为了方便，不配置任何参数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store()</span><br></pre></td></tr></table></div></figure>\n<p>store.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  vue-index.js 文件</span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./../pages/app.vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#root'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store, </span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。</p>\n<p>如<strong>问题1</strong>所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。</p>\n<h3 id=\"3-2-装载分析\">3.2 装载分析<a href=\"post/2018-07-25-Vuex框架原理与源码分析#3-2-装载分析\"></a></h3><p>index.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Vue</span><br></pre></td></tr></table></div></figure>\n<p>然后判断若处于浏览器环境下且加载过 Vue，则执行<code>install</code>方法。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// auto install in dist mode</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">window</span>.Vue) &#123;</span><br><span class=\"line\">  install(<span class=\"built_in\">window</span>.Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><code>install</code>方法将 Vuex 装载到 Vue 对象上，<code>Vue.use(Vuex)</code>也是通过它执行，先看下<code>Vue.use</code>方法实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">plugin: Function | Object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.installed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// additional parameters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = toArray(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  args.unshift(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.install === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际执行插件的 install 方法</span></span><br><span class=\"line\">    plugin.install.apply(plugin, args)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    plugin.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  plugin.installed = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行<code>applyMixin</code>方法，<code>install</code>实现如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">      <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>来看下<code>applyMixin</code>方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的<code>_init</code>方法，实现注入。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的 <code>$store</code>属性上，子组件从其父组件引用<code>$store</code>属性，层层嵌套进行设置。在任意组件中执行<code>this.$store</code>都能找到装载的那个 store 对象，<code>vuexInit</code>方法实现如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">  <span class=\"comment\">// store injection</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>看个图例理解下 store 的传递。</p>\n<p>页面 Vue 结构图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4ba6e4a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>对应 store 流向：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bc0c0a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<h2 id=\"四、store-对象构造\">四、store 对象构造<a href=\"post/2018-07-25-Vuex框架原理与源码分析#四、store-对象构造\"></a></h2><p>上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了<strong>问题1</strong>。接下来详细分析 store 对象的内部功能和具体实现，来解答 <strong>为什么actions、getters、mutations 中能从 arguments[0] 中拿到 store 的相关数据?</strong> 等问题。</p>\n<p>store 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b774c3c40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<h3 id=\"4-1-环境判断\">4.1 环境判断<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-1-环境判断\"></a></h3><p>开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  assert(Vue, <span class=\"string\">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class=\"line\">  assert(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span>, <span class=\"string\">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：</p>\n<ol>\n<li>已经执行安装函数进行装载；</li>\n<li>支持<code>Promise</code>语法。</li>\n</ol>\n<p><code>assert</code>函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"4-2-数据初始化、module-树构造\">4.2 数据初始化、module 树构造<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-2-数据初始化、module-树构造\"></a></h3><p>环境判断后，根据<code>new</code>构造传入的<code>options</code>或默认值，初始化内部数据。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    state = &#123;&#125;,</span><br><span class=\"line\">    plugins = [],</span><br><span class=\"line\">    strict = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125; = options</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// store internal state</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._committing = <span class=\"literal\">false</span> <span class=\"comment\">// 是否在进行提交状态标识</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// acitons 操作对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// mutations 操作对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// 封装后的 getters 集合对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._modules = <span class=\"keyword\">new</span> ModuleCollection(options) <span class=\"comment\">// Vuex 支持 store 分模块传入，存储分析后的 modules</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._modulesNamespaceMap = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// 模块命名空间 map</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._subscribers = [] <span class=\"comment\">// 订阅函数集合，Vuex 提供了 subscribe 功能</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._watcherVM = <span class=\"keyword\">new</span> Vue() <span class=\"comment\">// Vue 组件用于 watch 监视变化</span></span><br></pre></td></tr></table></div></figure>\n<p>调用<code>new Vuex.store(options)</code>时传入的<code>options</code>对象，用于构造<code>ModuleCollection</code>类，下面看看其功能。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (rawRootModule) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// register root module (Vuex.Store options)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> Module(rawRootModule, <span class=\"literal\">false</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// register all nested modules</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rawRootModule.modules) &#123;</span><br><span class=\"line\">    forEachValue(rawRootModule.modules, (rawModule, key) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.register([key], rawModule, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><code>ModuleCollection</code>主要将传入的<code>options</code>对象整个构造为一个 module 对象，并循环调用<code>this.register([key], rawModule, false)</code>为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后<code>options</code>对象被构造成一个完整的组件树。<code>ModuleCollection</code>类还提供了 modules 的更替功能，详细实现可以查看源文件 <a href=\"https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js\" target=\"_blank\" rel=\"noopener\">module-collection.js</a>。</p>\n<h3 id=\"4-3-dispatch-与-commit-设置\">4.3 dispatch 与 commit 设置<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-3-dispatch-与-commit-设置\"></a></h3><p>继续回到 store 的构造函数代码。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind commit and dispatch to self</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">this</span>.dispatch = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundDispatch</span> (<span class=\"params\">type, payload</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch.call(store, type, payload)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">this</span>.commit = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundCommit</span> (<span class=\"params\">type, payload, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> commit.call(store, type, payload, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>封装替换原型中的 dispatch 和 commit 方法，<strong>将 this 指向当前 store 对象</strong>。dispatch 和 commit 方法具体实现如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch (_type, _payload) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      type,</span><br><span class=\"line\">      payload</span><br><span class=\"line\">  &#125; = unifyObjectStyle(_type, _payload) <span class=\"comment\">// 配置参数处理</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 当前 type 下所有 action 处理函数集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._actions[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown action type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> entry.length &gt; <span class=\"number\">1</span></span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.all(entry.map(<span class=\"function\"><span class=\"params\">handler</span> =&gt;</span> handler(payload)))</span><br><span class=\"line\">      : entry[<span class=\"number\">0</span>](payload)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>前面提到，dispatch 的功能是触发并传递一些参数<code>(payload)</code>给对应 type 的 action 。因为其支持2种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的<code>this._actions[type]</code>以及下面的<code>this._mutations[type]</code>均是处理过的函数集合，具体内容留到后面进行分析）。</p>\n<p>commit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit (_type, _payload, _options) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style commit</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      type,</span><br><span class=\"line\">      payload,</span><br><span class=\"line\">      options</span><br><span class=\"line\">  &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> mutation = &#123; type, payload &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._mutations[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown mutation type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 专用修改 state 方法，其他修改 state 方法均是非法修改</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    entry.forEach(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitIterator</span> (<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">      handler(payload)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 订阅者函数遍历执行，传入当前的 mutation 对象和当前的 state</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._subscribers.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> sub(mutation, <span class=\"keyword\">this</span>.state))</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options &amp;&amp; options.silent) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.warn(</span><br><span class=\"line\">        <span class=\"string\">`[vuex] mutation type: <span class=\"subst\">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class=\"line\">        <span class=\"string\">'Use the filter functionality in the vue-devtools'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>该方法同样支持2种调用方法。先进行参数适配，判断触发 mutation type，利用<code>_withCommit</code>方法执行本次批量触发<code>mutation</code>处理函数，并传入<code>payload</code>参数。执行完成后，通知所有 <code>_subscribers</code>（订阅函数）本次操作的<code>mutation</code>对象以及当前的 state 状态，如果传入了已经移除的<code>silent</code>选项则进行提示警告。</p>\n<h3 id=\"4-4-state修改方法\">4.4 state修改方法<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-4-state修改方法\"></a></h3><p><code>_withCommit</code>是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 保存之前的提交状态</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 进行本次提交，若不设置为 true，直接修改 state，strict 模式下，Vuex 将会产生非法修改 state 的警告</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 执行 state 的修改操作</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 修改完成，还原本次修改之前的状态</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>缓存执行时的<code>committing</code>状态将当前状态设置为<code>true</code>后进行本次提交操作，待操作完毕后，将<code>committing</code>状态还原为之前的状态。</p>\n<h3 id=\"4-5-module安装\">4.5 module安装<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-module安装\"></a></h3><p>绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（<code>installModule</code>）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strict mode</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.strict = strict</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// init root module.</span></span><br><span class=\"line\"><span class=\"comment\">// this also recursively registers all sub-modules</span></span><br><span class=\"line\"><span class=\"comment\">// and collects all module getters inside this._wrappedGetters</span></span><br><span class=\"line\">installModule(<span class=\"keyword\">this</span>, state, [], <span class=\"keyword\">this</span>._modules.root)</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"4-5-1-初始化rootState\">4.5.1 初始化rootState<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-1-初始化rootState\"></a></h4><p>上述代码的备注中，提到<code>installModule</code>方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到<code>this._wrappedGetters</code>属性中，让我们看看其中的代码实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">installModule</span> (<span class=\"params\">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isRoot = !path.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespace = store._modules.getNamespace(path)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// register in namespace map</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (namespace) &#123;</span><br><span class=\"line\">    store._modulesNamespaceMap[namespace] = <span class=\"built_in\">module</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 非根组件设置 state 方法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      Vue.set(parentState, moduleName, <span class=\"built_in\">module</span>.state)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  ······</span><br></pre></td></tr></table></div></figure>\n<p><code>installModule</code>函数可接收5个参数，<code>store</code>、<code>rootState</code>、<code>path</code>、<code>module</code>、<code>hot</code>。<code>store</code>表示当前 Store 实例，<code>rootState</code>表示根 state，<code>path</code>表示当前嵌套模块的路径数组，<code>module</code>表示当前安装的模块，<code>hot</code>当动态改变 modules 或者热更新的时候为<code>true</code>。</p>\n<p>判断是否是根目录，以及是否设置了命名空间，若存在则在<code>namespace</code>中进行 module 的存储，在不是根组件且不是<code>hot</code>条件的情况下，通过<code>getNestedState</code>方法拿到该 module 父级的 state，拿到其所在的 moduleName，调用<code>Vue.set(parentState, moduleName, module.state)</code>方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。<code>getNestedState</code>方法代码很简单，分析 path 拿到 state，如下。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNestedState</span> (<span class=\"params\">state, path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> path.length</span><br><span class=\"line\">    ? path.reduce(<span class=\"function\">(<span class=\"params\">state, key</span>) =&gt;</span> state[key], state)</span><br><span class=\"line\">    : state</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"4-5-2-module上下文环境设置\">4.5.2 module上下文环境设置<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-2-module上下文环境设置\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> local = <span class=\"built_in\">module</span>.context = makeLocalContext(store, namespace, path)</span><br></pre></td></tr></table></div></figure>\n<p>命名空间和根目录条件判断完毕后，接下来定义<code>local</code>变量和<code>module.context</code>的值，执行<code>makeLocalContext</code>方法，<strong>为该 module 设置局部的<code>dispatch</code>、<code>commit</code>方法以及<code>getters</code>和<code>state</code></strong>（由于<code>namespace</code>的存在需要做兼容处理）。</p>\n<h4 id=\"4-5-3-mutations、actions以及getters注册\">4.5.3 mutations、actions以及getters注册<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-3-mutations、actions以及getters注册\"></a></h4><p>定义<code>local</code>环境后，循环注册我们在<code>options</code>中配置的<code>action</code>以及<code>mutation</code>等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b78b2b58f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>下面分析代码逻辑：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册对应模块的 mutation，供 state 修改使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachMutation(<span class=\"function\">(<span class=\"params\">mutation, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerMutation(store, namespacedType, mutation, local)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachAction(<span class=\"function\">(<span class=\"params\">action, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerAction(store, namespacedType, action, local)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 注册对应模块的 getters，供 state 读取使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachGetter(<span class=\"function\">(<span class=\"params\">getter, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerGetter(store, namespacedType, getter, local)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p><code>registerMutation</code>方法中，获取 store 中的对应<code>mutation type</code>的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行<code>commit(‘xxx’, payload)</code>的时候，type 为 xxx 的<code>mutation</code>的所有 handler 都会接收到<code>state</code>以及<code>payload</code>，这就是在 handler 里面拿到 state 的原因。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerMutation</span> (<span class=\"params\">store, type, handler, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取出对应 type 的 mutations-handler 集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class=\"line\">  <span class=\"comment\">// commit 实际调用的不是我们传入的 handler，而是经过封装的</span></span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedMutationHandler</span> (<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 handler 并将 state 传入</span></span><br><span class=\"line\">    handler(local.state, payload)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>action 和 getter 的注册也是同理的，看一下代码（注：前面提到的 <code>this.actions</code>以及<code>this.mutations</code>在此处进行设置）。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerAction</span> (<span class=\"params\">store, type, handler, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取出对应 type 的 actions-handler 集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class=\"line\">  <span class=\"comment\">// 存储新的封装过的 action-handler</span></span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入 state 等对象供我们原 action-handler 使用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">      dispatch: local.dispatch,</span><br><span class=\"line\">      commit: local.commit,</span><br><span class=\"line\">      getters: local.getters,</span><br><span class=\"line\">      state: local.state,</span><br><span class=\"line\">      rootGetters: store.getters,</span><br><span class=\"line\">      rootState: store.state</span><br><span class=\"line\">    &#125;, payload, cb)</span><br><span class=\"line\">    <span class=\"comment\">// action 需要支持 promise 进行链式调用，这里进行兼容处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">      res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerGetter</span> (<span class=\"params\">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// getters 只允许存在一个处理函数，若重复需要报错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] duplicate getter key: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 存储封装过的 getters 处理函数</span></span><br><span class=\"line\">  store._wrappedGetters[type] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedGetter</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为原 getters 传入对应状态</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> rawGetter(</span><br><span class=\"line\">      local.state, <span class=\"comment\">// local state</span></span><br><span class=\"line\">      local.getters, <span class=\"comment\">// local getters</span></span><br><span class=\"line\">      store.state, <span class=\"comment\">// root state</span></span><br><span class=\"line\">      store.getters <span class=\"comment\">// root getters</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><strong>action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。</strong></p>\n<h4 id=\"4-5-4-子module安装\">4.5.4 子module安装<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-4-子module安装\"></a></h4><p>注册完了根组件的<code>actions</code>、<code>mutations</code>以及<code>getters</code>后，递归调用自身，为子组件注册其<code>state</code>、<code>actions</code>、<code>mutations</code>以及<code>getters</code>等。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.forEachChild(<span class=\"function\">(<span class=\"params\">child, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  installModule(store, rootState, path.concat(key), child, hot)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"4-5-5-实例结合\">4.5.5 实例结合<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-5-实例结合\"></a></h4><p>前面介绍了<code>dispatch</code>和<code>commit</code>方法以及<code>actions</code>等的实现，下面结合一个官方的购物车实例中的部分代码来加深理解。</p>\n<p>Vuex 配置代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/</span><br><span class=\"line\"> *  store-index.js store 配置文件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> /</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> getters <span class=\"keyword\">from</span> <span class=\"string\">'./getters'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cart <span class=\"keyword\">from</span> <span class=\"string\">'./modules/cart'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> products <span class=\"keyword\">from</span> <span class=\"string\">'./modules/products'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createLogger <span class=\"keyword\">from</span> <span class=\"string\">'../../../src/plugins/logger'</span></span><br><span class=\"line\"> </span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> debug = process.env.NODE_ENV !== <span class=\"string\">'production'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    cart,</span><br><span class=\"line\">    products</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  strict: debug,</span><br><span class=\"line\">  plugins: debug ? [createLogger()] : []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>Vuex 组件 module 中各模块 state 配置代码部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  cart.js</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  added: [],</span><br><span class=\"line\">  checkoutStatus: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  products.js</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  all: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>加载上述配置后，页面 state 结构如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b79f8a6e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>state 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。</p>\n<p>Vuecart 组件代码部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Cart.vue 省略 template 代码，只看 script 部分</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch 方法</span></span><br><span class=\"line\">    checkout (products) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'checkout'</span>, products)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Vuexcart.js 组件 action 配置代码部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> savedCartItems = [...state.added] <span class=\"comment\">// 存储添加到购物车的商品</span></span><br><span class=\"line\">    commit(types.CHECKOUT_REQUEST) <span class=\"comment\">// 设置提交结算状态</span></span><br><span class=\"line\">    shop.buyProducts( <span class=\"comment\">// 提交 api 请求，并传入成功与失败的 cb-func</span></span><br><span class=\"line\">      products,</span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_SUCCESS), <span class=\"comment\">// 请求返回成功则设置提交成功状态</span></span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_FAILURE, &#123; savedCartItems &#125;) <span class=\"comment\">// 请求返回失败则设置提交失败状态</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Vue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 <code>checkout</code>，payload 值为<code>products</code>，在源码中 dispatch 方法在所有注册过的 actions 中查找<code>checkout</code>的对应执行数组，取出循环执行。执行的是被封装过的被命名为<code>wrappedActionHandler</code>的方法，真正传入的<code>checkout</code>的执行函数在<code>wrappedActionHandler</code>这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">    dispatch: local.dispatch,</span><br><span class=\"line\">    commit: local.commit,</span><br><span class=\"line\">    getters: local.getters,</span><br><span class=\"line\">    state: local.state,</span><br><span class=\"line\">    rootGetters: store.getters,</span><br><span class=\"line\">    rootState: store.state</span><br><span class=\"line\">  &#125;, payload, cb)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">    res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>handler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为<code>types.CHECKOUT_REQUEST</code>的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用<code>function wrappedMutationHandler (payload) { handler(local.state, payload)}</code>封装函数来实际调用配置的 mutation 方法。</p>\n<p>看到完源码分析和上面的小实例，应该能理解<code>dispatch</code>、<code>action</code>、<code>commit</code> 和<code>mutation</code>的工作原理了。接着看源码，看看<code>getters</code>是如何实现 state 实时访问的。</p>\n<h3 id=\"4-6-store-vm组件设置\">4.6 store._vm组件设置<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-6-store-vm组件设置\"></a></h3><p>执行完各 module 的 install 后，执行<code>resetStoreVM</code>方法，进行 store 组件的初始化。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class=\"line\"><span class=\"comment\">// (also registers _wrappedGetters as computed properties)</span></span><br><span class=\"line\">resetStoreVM(<span class=\"keyword\">this</span>, state)</span><br></pre></td></tr></table></div></figure>\n<p>综合前面的分析可以了解到，<strong>Vuex 其实构建的就是一个名为<code>store</code>的<code>vm</code>组件，所有配置的<code>state</code>、<code>actions</code>、<code>mutations</code>以及<code>getters</code>都是其组件的属性，所有的操作都是对这个<code>vm</code>组件进行的。</strong></p>\n<p>一起看下<code>resetStoreVM</code>方法的内部实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetStoreVM</span> (<span class=\"params\">store, state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldVm = store._vm <span class=\"comment\">// 缓存前 vm 组件</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// bind store public getters</span></span><br><span class=\"line\">  store.getters = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrappedGetters = store._wrappedGetters</span><br><span class=\"line\">  <span class=\"keyword\">const</span> computed = &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 循环所有处理过的 getters，并新建 computed 对象进行存储，通过Object.defineProperty 方法为 getters 对象建立属性，使得我们通过 this.$store.getters.xxxgetter 能够访问到该 getters</span></span><br><span class=\"line\">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// use computed to leverage its lazy-caching mechanism</span></span><br><span class=\"line\">    computed[key] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn(store)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">      get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store._vm[key],</span><br><span class=\"line\">      enumerable: <span class=\"literal\">true</span> <span class=\"comment\">// for local getters</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// use a Vue instance to store the state tree</span></span><br><span class=\"line\">  <span class=\"comment\">// suppress warnings just in case the user has added</span></span><br><span class=\"line\">  <span class=\"comment\">// some funky global mixins</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> silent = Vue.config.silent</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 暂时将 Vue 设为静默模式，避免报出用户加载的某些插件触发的警告</span></span><br><span class=\"line\">  Vue.config.silent = <span class=\"literal\">true</span>   </span><br><span class=\"line\">  <span class=\"comment\">// 设置新的 storeVm，将当前初始化的 state 以及 getters 作为 computed 属性（刚刚遍历生成的）</span></span><br><span class=\"line\">  store._vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    data: &#123; state &#125;,</span><br><span class=\"line\">    computed</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 恢复 Vue 的模式</span></span><br><span class=\"line\">  Vue.config.silent = silent</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// enable strict mode for new vm</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store.strict) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该方法对 state 执行 $watch 以禁止从 mutation 外部修改 state</span></span><br><span class=\"line\">    enableStrictMode(store)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 若不是初始化过程执行的该方法，将旧的组件 state 设置为 null，强制更新所有监听者(watchers)，待更新生效，DOM 更新完成后，执行 vm 组件的 destroy 方法进行销毁，减少内存的占用</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldVm) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// dispatch changes in all subscribed watchers</span></span><br><span class=\"line\">    <span class=\"comment\">// to force getter re-evaluation.</span></span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      oldVm.state = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><code>resetStoreVm</code>方法创建了当前<code>store</code>实例的<code>_vm</code>组件，至此<code>store</code>就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"string\">'state'</span>, () =&gt; &#123;</span><br><span class=\"line\">    assert(store._committing, <span class=\"string\">`Do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>很简单的应用，监视 state 的变化，如果没有通过<code>this._withCommit()</code>方法进行 state 修改，则报错。</p>\n<h3 id=\"4-7-plugin注入\">4.7 plugin注入<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-7-plugin注入\"></a></h3><p>最后执行<code>plugin</code>的植入。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></div></figure>\n<p><code>devtoolPlugin</code>提供的功能有3个：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 触发 Vuex 组件初始化的 hook</span></span><br><span class=\"line\">devtoolHook.emit(<span class=\"string\">'vuex:init'</span>, store)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 2. 提供“时空穿梭”功能，即 state 操作的前进和倒退</span></span><br><span class=\"line\">devtoolHook.on(<span class=\"string\">'vuex:travel-to-state'</span>, targetState =&gt; &#123;</span><br><span class=\"line\">  store.replaceState(targetState)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 3. mutation 被执行时，触发 hook，并提供被触发的 mutation 函数和当前的 state 状态</span></span><br><span class=\"line\">store.subscribe(<span class=\"function\">(<span class=\"params\">mutation, state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  devtoolHook.emit(<span class=\"string\">'vuex:mutation'</span>, mutation, state)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。</p>\n<h3 id=\"五、总结\">五、总结<a href=\"post/2018-07-25-Vuex框架原理与源码分析#五、总结\"></a></h3><p>最后我们回过来看文章开始提出的5个问题。</p>\n<p><strong>1. 问：使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？</strong></p>\n<blockquote>\n<p>答：<code>Vue.use(Vuex)</code>方法执行的是<code>install</code>方法，它实现了 Vue 实例对象的<code>init</code>方法封装和注入，使传入的<code>store</code>对象被设置到 Vue 上下文环境的<code>$store</code>中。因此在 Vue Component 任意地方都能够通过<code>this.$store</code>访问到该<code>store</code>。</p>\n</blockquote>\n<p><strong>2. 问：state内部支持模块配置和模块嵌套，如何实现的？</strong></p>\n<blockquote>\n<p>答：在<code>store</code>构造方法中有<code>makeLocalContext</code>方法，所有<code>module</code>都会有一个<code>local context</code>，根据配置时的<code>path</code>进行匹配。所以执行如<code>dispatch(‘submitOrder’, payload)</code>这类<code>action</code>时，默认的拿到都是<code>module</code>的<code>local state</code> ，如果要访问最外层或者是其他<code>module</code>的<code>state</code>，只能从<code>rootState</code>按照<code>path</code>路径逐步进行访问。</p>\n</blockquote>\n<p><strong>3.  问：在执行dispatch触发action(commit同理)的时候，只需传入(type, payload)，action执行函数中第一个参数store从哪里获取的？</strong></p>\n<blockquote>\n<p>答：<code>store</code>初始化时，所有配置的<code>action</code>和<code>mutation</code>以及<code>getters</code>均被封装过。在执行如<code>dispatch(‘submitOrder’, payload)</code>的时候，<code>actions</code>中<code>type</code>为<code>submitOrder</code>的所有处理方法都是被封装后的，其第一个参数为当前的<code>store</code>对象，所以能够获取到<code>{ dispatch, commit, state, rootState }</code>等数据。</p>\n</blockquote>\n<p><strong>4. 问：Vuex如何区分state是外部直接修改，还是通过mutation方法修改的？</strong></p>\n<blockquote>\n<p>答：Vuex 中修改<code>state</code>的唯一渠道就是执行<code>commit(‘xx’, payload)</code>方法，其底层通过执行<code>this._withCommit(fn)</code>设置<code>_committing</code>标志变量为<code>true</code>，然后才能修改<code>state</code>，修改完毕还需要还原<code>_committing</code>变量。外部修改虽然能够直接修改<code>state</code>，但是并没有修改<code>_committing</code>标志位，所以只要<code>watch</code>一下<code>state</code>，<code>state</code> change 时判断是否<code>_committing</code>值为<code>true</code>，即可判断修改的合法性。</p>\n</blockquote>\n<p><strong>5. 问：调试时的”时空穿梭”功能是如何实现的？</strong></p>\n<blockquote>\n<p>答：<code>devtoolPlugin</code>中提供了此功能。因为<code>dev</code>模式下所有的<code>state</code> change 都会被记录下来，’时空穿梭’功能其实就是将当前的<code>state</code>替换为记录中某个时刻的<code>state</code>状态，利用<code>store.replaceState(targetState)</code>方法将执行<code>this._vm.state = state</code>实现。</p>\n</blockquote>\n<p>源码中还有一些工具函数类似<code>registerModule</code>、<code>unregisterModule</code>、<code>hotUpdate</code>、<code>watch</code>以及<code>subscribe</code>等，如有兴趣可以打开源码看看，这里不再细述。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://juejin.im/entry/5af5d048f265da0b7b35f94e\" target=\"_blank\" rel=\"noopener\">Vuex 框架原理与源码分析</a></p>\n</blockquote>\n<p>Vuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过 action–mutation–state change 的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。</p>\n<p>最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。</p>\n<p>先将问题抛出来，使学习和研究更有针对性：</p>\n<p><strong>1. 使用 Vuex 只需执行<code>Vue.use(Vuex)</code>，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</strong><br><strong>2. state 内部是如何实现支持模块配置和模块嵌套的？</strong><br><strong>3. 在执行 dispatch 触发 action（commit 同理）的时候，只需传入<code>（type, payload）</code>，action 执行函数中第一个参数 store 从哪里获取的？</strong><br><strong>4. 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</strong><br><strong>5. 调试时的“时空穿梭”功能是如何实现的？</strong></p>\n<blockquote>\n<p>注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex 官方文档进行基础概念的学习。</p>\n</blockquote>\n<h2 id=\"一、框架核心流程\"><a href=\"#一、框架核心流程\" class=\"headerlink\" title=\"一、框架核心流程\"></a>一、框架核心流程</h2><p>进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb55247?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<p>如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：</p>\n<ul>\n<li>Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。</li>\n<li>dispatch：操作行为触发方法，是唯一能执行 action 的方法。</li>\n<li>actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了<code>Promise</code>的封装，以支持 action 的链式触发。</li>\n<li>commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。</li>\n<li>mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。</li>\n<li>state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。</li>\n<li>getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了  render 中，Vue Components 通过该方法读取全局 state 对象。</li>\n<li>Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。</li>\n</ul>\n<h2 id=\"二、目录结构介绍\"><a href=\"#二、目录结构介绍\" class=\"headerlink\" title=\"二、目录结构介绍\"></a>二、目录结构介绍</h2><p>打开 Vuex 项目，看下源码目录结构。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb88ab4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<p>Vuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：</p>\n<ul>\n<li>module：提供 module 对象与 module 对象树的创建功能；</li>\n<li>plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；</li>\n<li>helpers.js：提供 action、mutations 以及 getters 的查找 API；</li>\n<li>index.js：是源码主入口文件，提供 store 的各 module 构建安装；</li>\n<li>mixin.js：提供了 store 在 Vue 实例上的装载注入；</li>\n<li>util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。</li>\n</ul>\n<h2 id=\"三、初始化装载与注入\"><a href=\"#三、初始化装载与注入\" class=\"headerlink\" title=\"三、初始化装载与注入\"></a>三、初始化装载与注入</h2><p>了解大概的目录及对应功能后，下面开始进行源码分析。index.js 中包含了所有的核心代码，从该文件入手进行分析。</p>\n<h3 id=\"3-1-装载实例\"><a href=\"#3-1-装载实例\" class=\"headerlink\" title=\"3.1 装载实例\"></a>3.1 装载实例</h3><p>先看个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  store.js 文件</span></span><br><span class=\"line\"><span class=\"comment\"> *  创建 store 对象，配置 state、action、mutation 以及 getter</span></span><br><span class=\"line\"><span class=\"comment\"> *   </span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// install Vuex 框架</span></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 创建并导出 store 对象。为了方便，不配置任何参数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store()</span><br></pre></td></tr></table></figure>\n<p>store.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  vue-index.js 文件</span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./../pages/app.vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#root'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store, </span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。</p>\n<p>如<strong>问题1</strong>所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。</p>\n<h3 id=\"3-2-装载分析\"><a href=\"#3-2-装载分析\" class=\"headerlink\" title=\"3.2 装载分析\"></a>3.2 装载分析</h3><p>index.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Vue</span><br></pre></td></tr></table></figure>\n<p>然后判断若处于浏览器环境下且加载过 Vue，则执行<code>install</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// auto install in dist mode</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">window</span>.Vue) &#123;</span><br><span class=\"line\">  install(<span class=\"built_in\">window</span>.Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>install</code>方法将 Vuex 装载到 Vue 对象上，<code>Vue.use(Vuex)</code>也是通过它执行，先看下<code>Vue.use</code>方法实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">plugin: Function | Object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.installed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// additional parameters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = toArray(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  args.unshift(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.install === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际执行插件的 install 方法</span></span><br><span class=\"line\">    plugin.install.apply(plugin, args)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    plugin.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  plugin.installed = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行<code>applyMixin</code>方法，<code>install</code>实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">      <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看下<code>applyMixin</code>方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的<code>_init</code>方法，实现注入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的 <code>$store</code>属性上，子组件从其父组件引用<code>$store</code>属性，层层嵌套进行设置。在任意组件中执行<code>this.$store</code>都能找到装载的那个 store 对象，<code>vuexInit</code>方法实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">  <span class=\"comment\">// store injection</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看个图例理解下 store 的传递。</p>\n<p>页面 Vue 结构图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4ba6e4a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<p>对应 store 流向：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bc0c0a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<h2 id=\"四、store-对象构造\"><a href=\"#四、store-对象构造\" class=\"headerlink\" title=\"四、store 对象构造\"></a>四、store 对象构造</h2><p>上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了<strong>问题1</strong>。接下来详细分析 store 对象的内部功能和具体实现，来解答 <strong>为什么actions、getters、mutations 中能从 arguments[0] 中拿到 store 的相关数据?</strong> 等问题。</p>\n<p>store 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b774c3c40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<h3 id=\"4-1-环境判断\"><a href=\"#4-1-环境判断\" class=\"headerlink\" title=\"4.1 环境判断\"></a>4.1 环境判断</h3><p>开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  assert(Vue, <span class=\"string\">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class=\"line\">  assert(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span>, <span class=\"string\">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：</p>\n<ol>\n<li>已经执行安装函数进行装载；</li>\n<li>支持<code>Promise</code>语法。</li>\n</ol>\n<p><code>assert</code>函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-数据初始化、module-树构造\"><a href=\"#4-2-数据初始化、module-树构造\" class=\"headerlink\" title=\"4.2 数据初始化、module 树构造\"></a>4.2 数据初始化、module 树构造</h3><p>环境判断后，根据<code>new</code>构造传入的<code>options</code>或默认值，初始化内部数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    state = &#123;&#125;,</span><br><span class=\"line\">    plugins = [],</span><br><span class=\"line\">    strict = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125; = options</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// store internal state</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._committing = <span class=\"literal\">false</span> <span class=\"comment\">// 是否在进行提交状态标识</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// acitons 操作对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// mutations 操作对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// 封装后的 getters 集合对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._modules = <span class=\"keyword\">new</span> ModuleCollection(options) <span class=\"comment\">// Vuex 支持 store 分模块传入，存储分析后的 modules</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._modulesNamespaceMap = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// 模块命名空间 map</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._subscribers = [] <span class=\"comment\">// 订阅函数集合，Vuex 提供了 subscribe 功能</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._watcherVM = <span class=\"keyword\">new</span> Vue() <span class=\"comment\">// Vue 组件用于 watch 监视变化</span></span><br></pre></td></tr></table></figure>\n<p>调用<code>new Vuex.store(options)</code>时传入的<code>options</code>对象，用于构造<code>ModuleCollection</code>类，下面看看其功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (rawRootModule) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// register root module (Vuex.Store options)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> Module(rawRootModule, <span class=\"literal\">false</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// register all nested modules</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rawRootModule.modules) &#123;</span><br><span class=\"line\">    forEachValue(rawRootModule.modules, (rawModule, key) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.register([key], rawModule, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ModuleCollection</code>主要将传入的<code>options</code>对象整个构造为一个 module 对象，并循环调用<code>this.register([key], rawModule, false)</code>为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后<code>options</code>对象被构造成一个完整的组件树。<code>ModuleCollection</code>类还提供了 modules 的更替功能，详细实现可以查看源文件 <a href=\"https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js\" target=\"_blank\" rel=\"noopener\">module-collection.js</a>。</p>\n<h3 id=\"4-3-dispatch-与-commit-设置\"><a href=\"#4-3-dispatch-与-commit-设置\" class=\"headerlink\" title=\"4.3 dispatch 与 commit 设置\"></a>4.3 dispatch 与 commit 设置</h3><p>继续回到 store 的构造函数代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind commit and dispatch to self</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">this</span>.dispatch = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundDispatch</span> (<span class=\"params\">type, payload</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch.call(store, type, payload)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">this</span>.commit = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundCommit</span> (<span class=\"params\">type, payload, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> commit.call(store, type, payload, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>封装替换原型中的 dispatch 和 commit 方法，<strong>将 this 指向当前 store 对象</strong>。dispatch 和 commit 方法具体实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch (_type, _payload) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      type,</span><br><span class=\"line\">      payload</span><br><span class=\"line\">  &#125; = unifyObjectStyle(_type, _payload) <span class=\"comment\">// 配置参数处理</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 当前 type 下所有 action 处理函数集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._actions[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown action type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> entry.length &gt; <span class=\"number\">1</span></span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.all(entry.map(<span class=\"function\"><span class=\"params\">handler</span> =&gt;</span> handler(payload)))</span><br><span class=\"line\">      : entry[<span class=\"number\">0</span>](payload)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前面提到，dispatch 的功能是触发并传递一些参数<code>(payload)</code>给对应 type 的 action 。因为其支持2种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的<code>this._actions[type]</code>以及下面的<code>this._mutations[type]</code>均是处理过的函数集合，具体内容留到后面进行分析）。</p>\n<p>commit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit (_type, _payload, _options) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style commit</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      type,</span><br><span class=\"line\">      payload,</span><br><span class=\"line\">      options</span><br><span class=\"line\">  &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> mutation = &#123; type, payload &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._mutations[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown mutation type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 专用修改 state 方法，其他修改 state 方法均是非法修改</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    entry.forEach(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitIterator</span> (<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">      handler(payload)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 订阅者函数遍历执行，传入当前的 mutation 对象和当前的 state</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._subscribers.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> sub(mutation, <span class=\"keyword\">this</span>.state))</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options &amp;&amp; options.silent) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.warn(</span><br><span class=\"line\">        <span class=\"string\">`[vuex] mutation type: <span class=\"subst\">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class=\"line\">        <span class=\"string\">'Use the filter functionality in the vue-devtools'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法同样支持2种调用方法。先进行参数适配，判断触发 mutation type，利用<code>_withCommit</code>方法执行本次批量触发<code>mutation</code>处理函数，并传入<code>payload</code>参数。执行完成后，通知所有 <code>_subscribers</code>（订阅函数）本次操作的<code>mutation</code>对象以及当前的 state 状态，如果传入了已经移除的<code>silent</code>选项则进行提示警告。</p>\n<h3 id=\"4-4-state修改方法\"><a href=\"#4-4-state修改方法\" class=\"headerlink\" title=\"4.4 state修改方法\"></a>4.4 state修改方法</h3><p><code>_withCommit</code>是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 保存之前的提交状态</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 进行本次提交，若不设置为 true，直接修改 state，strict 模式下，Vuex 将会产生非法修改 state 的警告</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 执行 state 的修改操作</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 修改完成，还原本次修改之前的状态</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缓存执行时的<code>committing</code>状态将当前状态设置为<code>true</code>后进行本次提交操作，待操作完毕后，将<code>committing</code>状态还原为之前的状态。</p>\n<h3 id=\"4-5-module安装\"><a href=\"#4-5-module安装\" class=\"headerlink\" title=\"4.5 module安装\"></a>4.5 module安装</h3><p>绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（<code>installModule</code>）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strict mode</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.strict = strict</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// init root module.</span></span><br><span class=\"line\"><span class=\"comment\">// this also recursively registers all sub-modules</span></span><br><span class=\"line\"><span class=\"comment\">// and collects all module getters inside this._wrappedGetters</span></span><br><span class=\"line\">installModule(<span class=\"keyword\">this</span>, state, [], <span class=\"keyword\">this</span>._modules.root)</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-5-1-初始化rootState\"><a href=\"#4-5-1-初始化rootState\" class=\"headerlink\" title=\"4.5.1 初始化rootState\"></a>4.5.1 初始化rootState</h4><p>上述代码的备注中，提到<code>installModule</code>方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到<code>this._wrappedGetters</code>属性中，让我们看看其中的代码实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">installModule</span> (<span class=\"params\">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isRoot = !path.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespace = store._modules.getNamespace(path)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// register in namespace map</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (namespace) &#123;</span><br><span class=\"line\">    store._modulesNamespaceMap[namespace] = <span class=\"built_in\">module</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 非根组件设置 state 方法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      Vue.set(parentState, moduleName, <span class=\"built_in\">module</span>.state)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  ······</span><br></pre></td></tr></table></figure>\n<p><code>installModule</code>函数可接收5个参数，<code>store</code>、<code>rootState</code>、<code>path</code>、<code>module</code>、<code>hot</code>。<code>store</code>表示当前 Store 实例，<code>rootState</code>表示根 state，<code>path</code>表示当前嵌套模块的路径数组，<code>module</code>表示当前安装的模块，<code>hot</code>当动态改变 modules 或者热更新的时候为<code>true</code>。</p>\n<p>判断是否是根目录，以及是否设置了命名空间，若存在则在<code>namespace</code>中进行 module 的存储，在不是根组件且不是<code>hot</code>条件的情况下，通过<code>getNestedState</code>方法拿到该 module 父级的 state，拿到其所在的 moduleName，调用<code>Vue.set(parentState, moduleName, module.state)</code>方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。<code>getNestedState</code>方法代码很简单，分析 path 拿到 state，如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNestedState</span> (<span class=\"params\">state, path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> path.length</span><br><span class=\"line\">    ? path.reduce(<span class=\"function\">(<span class=\"params\">state, key</span>) =&gt;</span> state[key], state)</span><br><span class=\"line\">    : state</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-5-2-module上下文环境设置\"><a href=\"#4-5-2-module上下文环境设置\" class=\"headerlink\" title=\"4.5.2 module上下文环境设置\"></a>4.5.2 module上下文环境设置</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> local = <span class=\"built_in\">module</span>.context = makeLocalContext(store, namespace, path)</span><br></pre></td></tr></table></figure>\n<p>命名空间和根目录条件判断完毕后，接下来定义<code>local</code>变量和<code>module.context</code>的值，执行<code>makeLocalContext</code>方法，<strong>为该 module 设置局部的<code>dispatch</code>、<code>commit</code>方法以及<code>getters</code>和<code>state</code></strong>（由于<code>namespace</code>的存在需要做兼容处理）。</p>\n<h4 id=\"4-5-3-mutations、actions以及getters注册\"><a href=\"#4-5-3-mutations、actions以及getters注册\" class=\"headerlink\" title=\"4.5.3 mutations、actions以及getters注册\"></a>4.5.3 mutations、actions以及getters注册</h4><p>定义<code>local</code>环境后，循环注册我们在<code>options</code>中配置的<code>action</code>以及<code>mutation</code>等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b78b2b58f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<p>下面分析代码逻辑：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册对应模块的 mutation，供 state 修改使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachMutation(<span class=\"function\">(<span class=\"params\">mutation, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerMutation(store, namespacedType, mutation, local)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachAction(<span class=\"function\">(<span class=\"params\">action, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerAction(store, namespacedType, action, local)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 注册对应模块的 getters，供 state 读取使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachGetter(<span class=\"function\">(<span class=\"params\">getter, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerGetter(store, namespacedType, getter, local)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>registerMutation</code>方法中，获取 store 中的对应<code>mutation type</code>的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行<code>commit(‘xxx’, payload)</code>的时候，type 为 xxx 的<code>mutation</code>的所有 handler 都会接收到<code>state</code>以及<code>payload</code>，这就是在 handler 里面拿到 state 的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerMutation</span> (<span class=\"params\">store, type, handler, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取出对应 type 的 mutations-handler 集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class=\"line\">  <span class=\"comment\">// commit 实际调用的不是我们传入的 handler，而是经过封装的</span></span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedMutationHandler</span> (<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 handler 并将 state 传入</span></span><br><span class=\"line\">    handler(local.state, payload)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>action 和 getter 的注册也是同理的，看一下代码（注：前面提到的 <code>this.actions</code>以及<code>this.mutations</code>在此处进行设置）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerAction</span> (<span class=\"params\">store, type, handler, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取出对应 type 的 actions-handler 集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class=\"line\">  <span class=\"comment\">// 存储新的封装过的 action-handler</span></span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入 state 等对象供我们原 action-handler 使用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">      dispatch: local.dispatch,</span><br><span class=\"line\">      commit: local.commit,</span><br><span class=\"line\">      getters: local.getters,</span><br><span class=\"line\">      state: local.state,</span><br><span class=\"line\">      rootGetters: store.getters,</span><br><span class=\"line\">      rootState: store.state</span><br><span class=\"line\">    &#125;, payload, cb)</span><br><span class=\"line\">    <span class=\"comment\">// action 需要支持 promise 进行链式调用，这里进行兼容处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">      res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerGetter</span> (<span class=\"params\">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// getters 只允许存在一个处理函数，若重复需要报错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] duplicate getter key: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 存储封装过的 getters 处理函数</span></span><br><span class=\"line\">  store._wrappedGetters[type] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedGetter</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为原 getters 传入对应状态</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> rawGetter(</span><br><span class=\"line\">      local.state, <span class=\"comment\">// local state</span></span><br><span class=\"line\">      local.getters, <span class=\"comment\">// local getters</span></span><br><span class=\"line\">      store.state, <span class=\"comment\">// root state</span></span><br><span class=\"line\">      store.getters <span class=\"comment\">// root getters</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。</strong></p>\n<h4 id=\"4-5-4-子module安装\"><a href=\"#4-5-4-子module安装\" class=\"headerlink\" title=\"4.5.4 子module安装\"></a>4.5.4 子module安装</h4><p>注册完了根组件的<code>actions</code>、<code>mutations</code>以及<code>getters</code>后，递归调用自身，为子组件注册其<code>state</code>、<code>actions</code>、<code>mutations</code>以及<code>getters</code>等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.forEachChild(<span class=\"function\">(<span class=\"params\">child, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  installModule(store, rootState, path.concat(key), child, hot)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-5-5-实例结合\"><a href=\"#4-5-5-实例结合\" class=\"headerlink\" title=\"4.5.5 实例结合\"></a>4.5.5 实例结合</h4><p>前面介绍了<code>dispatch</code>和<code>commit</code>方法以及<code>actions</code>等的实现，下面结合一个官方的购物车实例中的部分代码来加深理解。</p>\n<p>Vuex 配置代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/</span><br><span class=\"line\"> *  store-index.js store 配置文件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> /</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> getters <span class=\"keyword\">from</span> <span class=\"string\">'./getters'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cart <span class=\"keyword\">from</span> <span class=\"string\">'./modules/cart'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> products <span class=\"keyword\">from</span> <span class=\"string\">'./modules/products'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createLogger <span class=\"keyword\">from</span> <span class=\"string\">'../../../src/plugins/logger'</span></span><br><span class=\"line\"> </span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> debug = process.env.NODE_ENV !== <span class=\"string\">'production'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    cart,</span><br><span class=\"line\">    products</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  strict: debug,</span><br><span class=\"line\">  plugins: debug ? [createLogger()] : []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Vuex 组件 module 中各模块 state 配置代码部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  cart.js</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  added: [],</span><br><span class=\"line\">  checkoutStatus: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  products.js</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  all: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加载上述配置后，页面 state 结构如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b79f8a6e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\"></p>\n<p>state 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。</p>\n<p>Vuecart 组件代码部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Cart.vue 省略 template 代码，只看 script 部分</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch 方法</span></span><br><span class=\"line\">    checkout (products) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'checkout'</span>, products)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vuexcart.js 组件 action 配置代码部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> savedCartItems = [...state.added] <span class=\"comment\">// 存储添加到购物车的商品</span></span><br><span class=\"line\">    commit(types.CHECKOUT_REQUEST) <span class=\"comment\">// 设置提交结算状态</span></span><br><span class=\"line\">    shop.buyProducts( <span class=\"comment\">// 提交 api 请求，并传入成功与失败的 cb-func</span></span><br><span class=\"line\">      products,</span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_SUCCESS), <span class=\"comment\">// 请求返回成功则设置提交成功状态</span></span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_FAILURE, &#123; savedCartItems &#125;) <span class=\"comment\">// 请求返回失败则设置提交失败状态</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 <code>checkout</code>，payload 值为<code>products</code>，在源码中 dispatch 方法在所有注册过的 actions 中查找<code>checkout</code>的对应执行数组，取出循环执行。执行的是被封装过的被命名为<code>wrappedActionHandler</code>的方法，真正传入的<code>checkout</code>的执行函数在<code>wrappedActionHandler</code>这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">    dispatch: local.dispatch,</span><br><span class=\"line\">    commit: local.commit,</span><br><span class=\"line\">    getters: local.getters,</span><br><span class=\"line\">    state: local.state,</span><br><span class=\"line\">    rootGetters: store.getters,</span><br><span class=\"line\">    rootState: store.state</span><br><span class=\"line\">  &#125;, payload, cb)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">    res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>handler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为<code>types.CHECKOUT_REQUEST</code>的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用<code>function wrappedMutationHandler (payload) { handler(local.state, payload)}</code>封装函数来实际调用配置的 mutation 方法。</p>\n<p>看到完源码分析和上面的小实例，应该能理解<code>dispatch</code>、<code>action</code>、<code>commit</code> 和<code>mutation</code>的工作原理了。接着看源码，看看<code>getters</code>是如何实现 state 实时访问的。</p>\n<h3 id=\"4-6-store-vm组件设置\"><a href=\"#4-6-store-vm组件设置\" class=\"headerlink\" title=\"4.6 store._vm组件设置\"></a>4.6 store._vm组件设置</h3><p>执行完各 module 的 install 后，执行<code>resetStoreVM</code>方法，进行 store 组件的初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class=\"line\"><span class=\"comment\">// (also registers _wrappedGetters as computed properties)</span></span><br><span class=\"line\">resetStoreVM(<span class=\"keyword\">this</span>, state)</span><br></pre></td></tr></table></figure>\n<p>综合前面的分析可以了解到，<strong>Vuex 其实构建的就是一个名为<code>store</code>的<code>vm</code>组件，所有配置的<code>state</code>、<code>actions</code>、<code>mutations</code>以及<code>getters</code>都是其组件的属性，所有的操作都是对这个<code>vm</code>组件进行的。</strong></p>\n<p>一起看下<code>resetStoreVM</code>方法的内部实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetStoreVM</span> (<span class=\"params\">store, state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldVm = store._vm <span class=\"comment\">// 缓存前 vm 组件</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// bind store public getters</span></span><br><span class=\"line\">  store.getters = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrappedGetters = store._wrappedGetters</span><br><span class=\"line\">  <span class=\"keyword\">const</span> computed = &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 循环所有处理过的 getters，并新建 computed 对象进行存储，通过Object.defineProperty 方法为 getters 对象建立属性，使得我们通过 this.$store.getters.xxxgetter 能够访问到该 getters</span></span><br><span class=\"line\">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// use computed to leverage its lazy-caching mechanism</span></span><br><span class=\"line\">    computed[key] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn(store)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">      get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store._vm[key],</span><br><span class=\"line\">      enumerable: <span class=\"literal\">true</span> <span class=\"comment\">// for local getters</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// use a Vue instance to store the state tree</span></span><br><span class=\"line\">  <span class=\"comment\">// suppress warnings just in case the user has added</span></span><br><span class=\"line\">  <span class=\"comment\">// some funky global mixins</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> silent = Vue.config.silent</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 暂时将 Vue 设为静默模式，避免报出用户加载的某些插件触发的警告</span></span><br><span class=\"line\">  Vue.config.silent = <span class=\"literal\">true</span>   </span><br><span class=\"line\">  <span class=\"comment\">// 设置新的 storeVm，将当前初始化的 state 以及 getters 作为 computed 属性（刚刚遍历生成的）</span></span><br><span class=\"line\">  store._vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    data: &#123; state &#125;,</span><br><span class=\"line\">    computed</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 恢复 Vue 的模式</span></span><br><span class=\"line\">  Vue.config.silent = silent</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// enable strict mode for new vm</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store.strict) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该方法对 state 执行 $watch 以禁止从 mutation 外部修改 state</span></span><br><span class=\"line\">    enableStrictMode(store)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 若不是初始化过程执行的该方法，将旧的组件 state 设置为 null，强制更新所有监听者(watchers)，待更新生效，DOM 更新完成后，执行 vm 组件的 destroy 方法进行销毁，减少内存的占用</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldVm) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// dispatch changes in all subscribed watchers</span></span><br><span class=\"line\">    <span class=\"comment\">// to force getter re-evaluation.</span></span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      oldVm.state = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>resetStoreVm</code>方法创建了当前<code>store</code>实例的<code>_vm</code>组件，至此<code>store</code>就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"string\">'state'</span>, () =&gt; &#123;</span><br><span class=\"line\">    assert(store._committing, <span class=\"string\">`Do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单的应用，监视 state 的变化，如果没有通过<code>this._withCommit()</code>方法进行 state 修改，则报错。</p>\n<h3 id=\"4-7-plugin注入\"><a href=\"#4-7-plugin注入\" class=\"headerlink\" title=\"4.7 plugin注入\"></a>4.7 plugin注入</h3><p>最后执行<code>plugin</code>的植入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></figure>\n<p><code>devtoolPlugin</code>提供的功能有3个：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 触发 Vuex 组件初始化的 hook</span></span><br><span class=\"line\">devtoolHook.emit(<span class=\"string\">'vuex:init'</span>, store)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 2. 提供“时空穿梭”功能，即 state 操作的前进和倒退</span></span><br><span class=\"line\">devtoolHook.on(<span class=\"string\">'vuex:travel-to-state'</span>, targetState =&gt; &#123;</span><br><span class=\"line\">  store.replaceState(targetState)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 3. mutation 被执行时，触发 hook，并提供被触发的 mutation 函数和当前的 state 状态</span></span><br><span class=\"line\">store.subscribe(<span class=\"function\">(<span class=\"params\">mutation, state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  devtoolHook.emit(<span class=\"string\">'vuex:mutation'</span>, mutation, state)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。</p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><p>最后我们回过来看文章开始提出的5个问题。</p>\n<p><strong>1. 问：使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？</strong></p>\n<blockquote>\n<p>答：<code>Vue.use(Vuex)</code>方法执行的是<code>install</code>方法，它实现了 Vue 实例对象的<code>init</code>方法封装和注入，使传入的<code>store</code>对象被设置到 Vue 上下文环境的<code>$store</code>中。因此在 Vue Component 任意地方都能够通过<code>this.$store</code>访问到该<code>store</code>。</p>\n</blockquote>\n<p><strong>2. 问：state内部支持模块配置和模块嵌套，如何实现的？</strong></p>\n<blockquote>\n<p>答：在<code>store</code>构造方法中有<code>makeLocalContext</code>方法，所有<code>module</code>都会有一个<code>local context</code>，根据配置时的<code>path</code>进行匹配。所以执行如<code>dispatch(‘submitOrder’, payload)</code>这类<code>action</code>时，默认的拿到都是<code>module</code>的<code>local state</code> ，如果要访问最外层或者是其他<code>module</code>的<code>state</code>，只能从<code>rootState</code>按照<code>path</code>路径逐步进行访问。</p>\n</blockquote>\n<p><strong>3.  问：在执行dispatch触发action(commit同理)的时候，只需传入(type, payload)，action执行函数中第一个参数store从哪里获取的？</strong></p>\n<blockquote>\n<p>答：<code>store</code>初始化时，所有配置的<code>action</code>和<code>mutation</code>以及<code>getters</code>均被封装过。在执行如<code>dispatch(‘submitOrder’, payload)</code>的时候，<code>actions</code>中<code>type</code>为<code>submitOrder</code>的所有处理方法都是被封装后的，其第一个参数为当前的<code>store</code>对象，所以能够获取到<code>{ dispatch, commit, state, rootState }</code>等数据。</p>\n</blockquote>\n<p><strong>4. 问：Vuex如何区分state是外部直接修改，还是通过mutation方法修改的？</strong></p>\n<blockquote>\n<p>答：Vuex 中修改<code>state</code>的唯一渠道就是执行<code>commit(‘xx’, payload)</code>方法，其底层通过执行<code>this._withCommit(fn)</code>设置<code>_committing</code>标志变量为<code>true</code>，然后才能修改<code>state</code>，修改完毕还需要还原<code>_committing</code>变量。外部修改虽然能够直接修改<code>state</code>，但是并没有修改<code>_committing</code>标志位，所以只要<code>watch</code>一下<code>state</code>，<code>state</code> change 时判断是否<code>_committing</code>值为<code>true</code>，即可判断修改的合法性。</p>\n</blockquote>\n<p><strong>5. 问：调试时的”时空穿梭”功能是如何实现的？</strong></p>\n<blockquote>\n<p>答：<code>devtoolPlugin</code>中提供了此功能。因为<code>dev</code>模式下所有的<code>state</code> change 都会被记录下来，’时空穿梭’功能其实就是将当前的<code>state</code>替换为记录中某个时刻的<code>state</code>状态，利用<code>store.replaceState(targetState)</code>方法将执行<code>this._vm.state = state</code>实现。</p>\n</blockquote>\n<p>源码中还有一些工具函数类似<code>registerModule</code>、<code>unregisterModule</code>、<code>hotUpdate</code>、<code>watch</code>以及<code>subscribe</code>等，如有兴趣可以打开源码看看，这里不再细述。</p>\n","plink":"https://vincentdou.github.io/blog/post/2018-07-25-Vuex框架原理与源码分析/","type":"post","toc":[{"title":"一、框架核心流程","id":"一、框架核心流程","index":"1"},{"title":"二、目录结构介绍","id":"二、目录结构介绍","index":"2"},{"title":"三、初始化装载与注入","id":"三、初始化装载与注入","index":"3","children":[{"title":"3.1 装载实例","id":"3-1-装载实例","index":"3.1"},{"title":"3.2 装载分析","id":"3-2-装载分析","index":"3.2"}]},{"title":"四、store 对象构造","id":"四、store-对象构造","index":"4","children":[{"title":"4.1 环境判断","id":"4-1-环境判断","index":"4.1"},{"title":"4.2 数据初始化、module 树构造","id":"4-2-数据初始化、module-树构造","index":"4.2"},{"title":"4.3 dispatch 与 commit 设置","id":"4-3-dispatch-与-commit-设置","index":"4.3"},{"title":"4.4 state修改方法","id":"4-4-state修改方法","index":"4.4"},{"title":"4.5 module安装","id":"4-5-module安装","index":"4.5","children":[{"title":"4.5.1 初始化rootState","id":"4-5-1-初始化rootState","index":"4.5.1"},{"title":"4.5.2 module上下文环境设置","id":"4-5-2-module上下文环境设置","index":"4.5.2"},{"title":"4.5.3 mutations、actions以及getters注册","id":"4-5-3-mutations、actions以及getters注册","index":"4.5.3"},{"title":"4.5.4 子module安装","id":"4-5-4-子module安装","index":"4.5.4"},{"title":"4.5.5 实例结合","id":"4-5-5-实例结合","index":"4.5.5"}]},{"title":"4.6 store._vm组件设置","id":"4-6-store-vm组件设置","index":"4.6"},{"title":"4.7 plugin注入","id":"4-7-plugin注入","index":"4.7"},{"title":"五、总结","id":"五、总结","index":"4.8"}]}]},{"layout":"post","title":"你不知道的JS-this与对象原型-this","date":"2018-05-24T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n## this是什么？\n\n- 函数内部的`this`并不是指向函数自己；\n- `this`不会以任何方式指向函数的词法作用域；\n- `this`不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。`this`绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。\n\n当一个函数被调用时，会建立 **活动记录** （有时也称为执行上下文）。这个记录包含函数是从何处（调用栈 —— call-stack）被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的`this`引用。\n\n## this全面解析\n\n### 调用点（Call-site）\n\n寻找调用点就是寻找函数被调用的位置，最重要的是分析调用栈，调用点就在当前执行中的函数的前一个调用中。\n\n> 调用栈: 使我们到达当前执行位置而被调用的所有方法的堆栈\n\n```js\nfunction baz() {\n\t// 调用栈是: `baz`\n\t// 我们的调用点是 global scope（全局作用域）\n\n\tconsole.log( \"baz\" );\n\tbar(); // <-- `bar` 的调用点\n}\n\nfunction bar() {\n\t// 调用栈是: `baz` -> `bar`\n\t// 我们的调用点位于 `baz`\n\n\tconsole.log( \"bar\" );\n\tfoo(); // <-- `foo` 的 call-site\n}\n\nfunction foo() {\n  // 调用栈是: `baz` -> `bar` -> `foo`\n  // 我们的调用点位于 `bar`\n\n  console.log( \"foo\" );\n}\n\nbaz(); // <-- `baz` 的调用点\n```\n\n### 绑定规则\n\n#### 默认绑定（Default Binding）\n\n当我们直接使用不带任何修饰的函数引用进行调用时，对应默认绑定。\n\n```js\nfunction foo() {\n  // 这里 this 指向全局对象\n  console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // 2\n```\n\nstrict 模式下对于默认绑定来说全局对象是不合法的，所以`this`将被设置为`undefined`。\n\n```js\nfunction foo() {\n  \"use strict\";\n\n  console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // TypeError: `this` is `undefined`\n```\n\n注意：this的绑定规则基于调用点，但判断是否在 strict 模式则是取决于函数体。\n\n```js\nfunction foo() {\n  // 这里不是严格模式\n  console.log( this.a );\n}\n\nvar a = 2;\n\n(function(){\n  \"use strict\";\n\n  foo(); // 2\n})();\n```\n\n#### 隐式绑定（Implicit Binding）\n\n另一种要考虑的规则是：调用点是否有上下文对象，或者说是否被某个对象拥有或者包含。\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n};\n\nobj.foo(); // 2\n\n// 这里函数 foo() 是先定义然后作为引用属性添加到 obj 中的，严格说函数 foo() 不属于 obj。\n// 然而调用栈会使用 obj 上下文来引用函数，因此可以说函数被调用的时候 obj “拥有”或“包含”它。\n```\n\n当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此`this.a`和`obj.a`是一样的。\n\n> 对象属性引用链中只有最顶层或者说最后一层会影响调用位置\n\n**隐式丢失**\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n};\n\nvar bar = obj.foo; // 函数引用！\n\nvar a = \"oops, global\"; // `a` 也是一个全局对象的属性\n\nbar(); // \"oops, global\"\n```\n\n尽管`bar`似乎是`obj.foo`的引用，但实际上它只是另一个`foo`本身的引用而已。另外，起作用的调用点是`bar()`，一个直白，毫无修饰的调用，因此这里适用默认绑定。\n\n当我们传递一个回调函数时，参数传递其实就是一种隐式赋值，因此我们在传入参数时也会被隐式的引用赋值：\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nfunction doFoo(fn) {\n  // `fn` 只不过 `foo` 的另一个引用\n\n  fn(); // <-- 调用点!\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n};\n\nvar a = \"oops, global\"; // `a` 也是一个全局对象的属性\n\ndoFoo( obj.foo ); // \"oops, global\"\n```\n\n#### 显式绑定（Explicit Binding）\n\nJavaScript 中绝大多数内置的函数以及你创建的所有的函数，都可以访问`call(..)`和`apply(..)`。我们可以通过它来进行显式绑定。不过单独依靠明确绑定仍然不能解决函数“丢失”自己原本的`this`绑定的问题。\n\n**硬绑定（Hard Binding）**\n\nES5 的内建工具提供`Function.prototype.bind`进行硬绑定：\n\n```js\nfunction foo(something) {\n  console.log( this.a, something );\n  return this.a + something;\n}\n\nvar obj = {\n  a: 2\n};\n\nvar bar = foo.bind( obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n`bind(..)`返回一个硬编码的新函数，它使用你指定的`this`环境来调用原本的函数。\n\n它的思想来自这里：\n\n```js\nfunction foo(something) {\n  console.log( this.a, something );\n  return this.a + something;\n}\n\n// 简单的 `bind` 帮助函数\nfunction bind(fn, obj) {\n  return function() {\n    return fn.apply( obj, arguments );\n  };\n}\n\nvar obj = {\n  a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n这里创建了一个函数，在它的内部手动调用`fn.apply(obj, arguments)`，由此强制`this`绑定到`obj`并调用`fn`。无论你过后怎样调用函数，它总是手动使用`obj`调用`foo`。\n\n#### new 绑定（new Binding）\n\n在 JavaScript 中，构造函数只是一些使用`new`操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，他们只是被`new`操作符调用的普通函数而已。\n\n可以说任何函数，都可以在前面加上`new`来被调用，这使函数调用成为一个构造器调用（constructor call）。这是一个重要而微妙的区别：实际上不存在“构造器函数”这样的东西，而只有函数的构造器调用。\n\n### 优先级\n\n判定`this`的顺序：\n\n1. 函数是通过`new`被调用的吗（new 绑定）？如果是，`this`就是新构建的对象。\n2. 函数是通过`call`或`apply`被调用（明确绑定），甚至是隐藏在`bind`硬绑定之中吗？如果是，`this`就是那个被明确指定的对象。\n3. 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，`this`就是那个环境对象。\n4. 否则，使用默认的`this`（默认绑定）。如果在 strict mode 下，就是`undefined`，否则是`global`对象。\n\n### 绑定的特例\n\n#### 被忽略的 this\n\n如果你传递`null`或`undefined`作为`call`、`apply`或`bind`的`this`绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar a = 2;\n\nfoo.call( null ); // 2\n```\n\n进行`this`绑定的时候故意传`null`可以对参数进行柯里化：\n\n```js\nfunction foo(a,b) {\n  console.log( \"a:\" + a + \", b:\" + b );\n}\n\n// 将数组散开作为参数\nfoo.apply( null, [2, 3] ); // a:2, b:3\n\n// 用 `bind(..)` 进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2, b:3\n```\n\n**更安全的this**\n\n对于那些确实使用了`this`引用的函数，默认绑定规则会把`this`绑定到全局对象（在浏览器中是 window）上，这将导致不可预计的后果（比如修改全局对象）。\n\n> DMZ（demilitarized zone，非军事区）对象：空的非委托的对象\n\n```js\nfunction foo(a,b) {\n  console.log( \"a:\" + a + \", b:\" + b );\n}\n\n// 我们的 DMZ 空对象\nvar ø = Object.create( null );\n\n// 将数组散开作为参数\nfoo.apply( ø, [2, 3] ); // a:2, b:3\n\n// 用 `bind(..)` 进行 currying\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2, b:3\n```\n\n> `Object.create(null)`是创建完全为空的对象的最简单方法。`Object.create(null) `和`{}`很相似，但是没有指向`Object.prototype`的委托，所以它比`{}`“空得更彻底”。\n\n#### 间接\n\n对函数的“间接引用”适用默认绑定规则：\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4 };\n\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n```\n\n赋值表达式`p.foo = o.foo`的返回值是目标函数的引用。所以调用点就是`foo()`而不是`p.foo()`或`o.foo()`。所以这里适用默认绑定。\n\n### 词法this\n\nES6 引入的箭头函数不适用于这些规则，箭头函数从外层作用域来决定`this`绑定。\n\n```js\nfunction foo() {\n  // 返回一个箭头函数\n  return (a) => {\n    // this 遵从词法作用域继承自 foo()\n    console.log( this.a );\n  };\n}\n\nvar obj1 = {\n  a: 2\n};\n\nvar obj2 = {\n  a: 3\n};\n\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2, 不是3!\n```\n\n> 箭头函数的绑定是无法被修改的（`new`也不行！）\n","source":"_posts/2018-05-25-你不知道的JS-2.markdown","raw":"---\nlayout:     post\ntitle:      \"你不知道的JS-this与对象原型-this\"\ndate:       2018-05-25\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - 你不知道的JS\n---\n\n## this是什么？\n\n- 函数内部的`this`并不是指向函数自己；\n- `this`不会以任何方式指向函数的词法作用域；\n- `this`不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。`this`绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。\n\n当一个函数被调用时，会建立 **活动记录** （有时也称为执行上下文）。这个记录包含函数是从何处（调用栈 —— call-stack）被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的`this`引用。\n\n## this全面解析\n\n### 调用点（Call-site）\n\n寻找调用点就是寻找函数被调用的位置，最重要的是分析调用栈，调用点就在当前执行中的函数的前一个调用中。\n\n> 调用栈: 使我们到达当前执行位置而被调用的所有方法的堆栈\n\n```js\nfunction baz() {\n\t// 调用栈是: `baz`\n\t// 我们的调用点是 global scope（全局作用域）\n\n\tconsole.log( \"baz\" );\n\tbar(); // <-- `bar` 的调用点\n}\n\nfunction bar() {\n\t// 调用栈是: `baz` -> `bar`\n\t// 我们的调用点位于 `baz`\n\n\tconsole.log( \"bar\" );\n\tfoo(); // <-- `foo` 的 call-site\n}\n\nfunction foo() {\n  // 调用栈是: `baz` -> `bar` -> `foo`\n  // 我们的调用点位于 `bar`\n\n  console.log( \"foo\" );\n}\n\nbaz(); // <-- `baz` 的调用点\n```\n\n### 绑定规则\n\n#### 默认绑定（Default Binding）\n\n当我们直接使用不带任何修饰的函数引用进行调用时，对应默认绑定。\n\n```js\nfunction foo() {\n  // 这里 this 指向全局对象\n  console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // 2\n```\n\nstrict 模式下对于默认绑定来说全局对象是不合法的，所以`this`将被设置为`undefined`。\n\n```js\nfunction foo() {\n  \"use strict\";\n\n  console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // TypeError: `this` is `undefined`\n```\n\n注意：this的绑定规则基于调用点，但判断是否在 strict 模式则是取决于函数体。\n\n```js\nfunction foo() {\n  // 这里不是严格模式\n  console.log( this.a );\n}\n\nvar a = 2;\n\n(function(){\n  \"use strict\";\n\n  foo(); // 2\n})();\n```\n\n#### 隐式绑定（Implicit Binding）\n\n另一种要考虑的规则是：调用点是否有上下文对象，或者说是否被某个对象拥有或者包含。\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n};\n\nobj.foo(); // 2\n\n// 这里函数 foo() 是先定义然后作为引用属性添加到 obj 中的，严格说函数 foo() 不属于 obj。\n// 然而调用栈会使用 obj 上下文来引用函数，因此可以说函数被调用的时候 obj “拥有”或“包含”它。\n```\n\n当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此`this.a`和`obj.a`是一样的。\n\n> 对象属性引用链中只有最顶层或者说最后一层会影响调用位置\n\n**隐式丢失**\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n};\n\nvar bar = obj.foo; // 函数引用！\n\nvar a = \"oops, global\"; // `a` 也是一个全局对象的属性\n\nbar(); // \"oops, global\"\n```\n\n尽管`bar`似乎是`obj.foo`的引用，但实际上它只是另一个`foo`本身的引用而已。另外，起作用的调用点是`bar()`，一个直白，毫无修饰的调用，因此这里适用默认绑定。\n\n当我们传递一个回调函数时，参数传递其实就是一种隐式赋值，因此我们在传入参数时也会被隐式的引用赋值：\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nfunction doFoo(fn) {\n  // `fn` 只不过 `foo` 的另一个引用\n\n  fn(); // <-- 调用点!\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n};\n\nvar a = \"oops, global\"; // `a` 也是一个全局对象的属性\n\ndoFoo( obj.foo ); // \"oops, global\"\n```\n\n#### 显式绑定（Explicit Binding）\n\nJavaScript 中绝大多数内置的函数以及你创建的所有的函数，都可以访问`call(..)`和`apply(..)`。我们可以通过它来进行显式绑定。不过单独依靠明确绑定仍然不能解决函数“丢失”自己原本的`this`绑定的问题。\n\n**硬绑定（Hard Binding）**\n\nES5 的内建工具提供`Function.prototype.bind`进行硬绑定：\n\n```js\nfunction foo(something) {\n  console.log( this.a, something );\n  return this.a + something;\n}\n\nvar obj = {\n  a: 2\n};\n\nvar bar = foo.bind( obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n`bind(..)`返回一个硬编码的新函数，它使用你指定的`this`环境来调用原本的函数。\n\n它的思想来自这里：\n\n```js\nfunction foo(something) {\n  console.log( this.a, something );\n  return this.a + something;\n}\n\n// 简单的 `bind` 帮助函数\nfunction bind(fn, obj) {\n  return function() {\n    return fn.apply( obj, arguments );\n  };\n}\n\nvar obj = {\n  a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n这里创建了一个函数，在它的内部手动调用`fn.apply(obj, arguments)`，由此强制`this`绑定到`obj`并调用`fn`。无论你过后怎样调用函数，它总是手动使用`obj`调用`foo`。\n\n#### new 绑定（new Binding）\n\n在 JavaScript 中，构造函数只是一些使用`new`操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，他们只是被`new`操作符调用的普通函数而已。\n\n可以说任何函数，都可以在前面加上`new`来被调用，这使函数调用成为一个构造器调用（constructor call）。这是一个重要而微妙的区别：实际上不存在“构造器函数”这样的东西，而只有函数的构造器调用。\n\n### 优先级\n\n判定`this`的顺序：\n\n1. 函数是通过`new`被调用的吗（new 绑定）？如果是，`this`就是新构建的对象。\n2. 函数是通过`call`或`apply`被调用（明确绑定），甚至是隐藏在`bind`硬绑定之中吗？如果是，`this`就是那个被明确指定的对象。\n3. 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，`this`就是那个环境对象。\n4. 否则，使用默认的`this`（默认绑定）。如果在 strict mode 下，就是`undefined`，否则是`global`对象。\n\n### 绑定的特例\n\n#### 被忽略的 this\n\n如果你传递`null`或`undefined`作为`call`、`apply`或`bind`的`this`绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar a = 2;\n\nfoo.call( null ); // 2\n```\n\n进行`this`绑定的时候故意传`null`可以对参数进行柯里化：\n\n```js\nfunction foo(a,b) {\n  console.log( \"a:\" + a + \", b:\" + b );\n}\n\n// 将数组散开作为参数\nfoo.apply( null, [2, 3] ); // a:2, b:3\n\n// 用 `bind(..)` 进行柯里化\nvar bar = foo.bind( null, 2 );\nbar( 3 ); // a:2, b:3\n```\n\n**更安全的this**\n\n对于那些确实使用了`this`引用的函数，默认绑定规则会把`this`绑定到全局对象（在浏览器中是 window）上，这将导致不可预计的后果（比如修改全局对象）。\n\n> DMZ（demilitarized zone，非军事区）对象：空的非委托的对象\n\n```js\nfunction foo(a,b) {\n  console.log( \"a:\" + a + \", b:\" + b );\n}\n\n// 我们的 DMZ 空对象\nvar ø = Object.create( null );\n\n// 将数组散开作为参数\nfoo.apply( ø, [2, 3] ); // a:2, b:3\n\n// 用 `bind(..)` 进行 currying\nvar bar = foo.bind( ø, 2 );\nbar( 3 ); // a:2, b:3\n```\n\n> `Object.create(null)`是创建完全为空的对象的最简单方法。`Object.create(null) `和`{}`很相似，但是没有指向`Object.prototype`的委托，所以它比`{}`“空得更彻底”。\n\n#### 间接\n\n对函数的“间接引用”适用默认绑定规则：\n\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4 };\n\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n```\n\n赋值表达式`p.foo = o.foo`的返回值是目标函数的引用。所以调用点就是`foo()`而不是`p.foo()`或`o.foo()`。所以这里适用默认绑定。\n\n### 词法this\n\nES6 引入的箭头函数不适用于这些规则，箭头函数从外层作用域来决定`this`绑定。\n\n```js\nfunction foo() {\n  // 返回一个箭头函数\n  return (a) => {\n    // this 遵从词法作用域继承自 foo()\n    console.log( this.a );\n  };\n}\n\nvar obj1 = {\n  a: 2\n};\n\nvar obj2 = {\n  a: 3\n};\n\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2, 不是3!\n```\n\n> 箭头函数的绑定是无法被修改的（`new`也不行！）\n","slug":"2018-05-25-你不知道的JS-2","published":1,"updated":"2019-01-02T08:49:00.266Z","comments":0,"photos":[],"link":"post/2018-05-25-你不知道的JS-2","_id":"cjz2epjfw001xn3w54mqytm4o","content":"<h2 id=\"this是什么？\">this是什么？<a href=\"post/2018-05-25-你不知道的JS-2#this是什么？\"></a></h2><ul>\n<li>函数内部的<code>this</code>并不是指向函数自己；</li>\n<li><code>this</code>不会以任何方式指向函数的词法作用域；</li>\n<li><code>this</code>不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。<code>this</code>绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</li>\n</ul>\n<p>当一个函数被调用时，会建立 <strong>活动记录</strong> （有时也称为执行上下文）。这个记录包含函数是从何处（调用栈 —— call-stack）被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的<code>this</code>引用。</p>\n<h2 id=\"this全面解析\">this全面解析<a href=\"post/2018-05-25-你不知道的JS-2#this全面解析\"></a></h2><h3 id=\"调用点（Call-site）\">调用点（Call-site）<a href=\"post/2018-05-25-你不知道的JS-2#调用点（Call-site）\"></a></h3><p>寻找调用点就是寻找函数被调用的位置，最重要的是分析调用栈，调用点就在当前执行中的函数的前一个调用中。</p>\n<blockquote>\n<p>调用栈: 使我们到达当前执行位置而被调用的所有方法的堆栈</p>\n</blockquote>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用栈是: `baz`</span></span><br><span class=\"line\">\t<span class=\"comment\">// 我们的调用点是 global scope（全局作用域）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"baz\"</span> );</span><br><span class=\"line\">\tbar(); <span class=\"comment\">// &lt;-- `bar` 的调用点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用栈是: `baz` -&gt; `bar`</span></span><br><span class=\"line\">\t<span class=\"comment\">// 我们的调用点位于 `baz`</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\">\tfoo(); <span class=\"comment\">// &lt;-- `foo` 的 call-site</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用栈是: `baz` -&gt; `bar` -&gt; `foo`</span></span><br><span class=\"line\">  <span class=\"comment\">// 我们的调用点位于 `bar`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); <span class=\"comment\">// &lt;-- `baz` 的调用点</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"绑定规则\">绑定规则<a href=\"post/2018-05-25-你不知道的JS-2#绑定规则\"></a></h3><h4 id=\"默认绑定（Default-Binding）\">默认绑定（Default Binding）<a href=\"post/2018-05-25-你不知道的JS-2#默认绑定（Default-Binding）\"></a></h4><p>当我们直接使用不带任何修饰的函数引用进行调用时，对应默认绑定。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里 this 指向全局对象</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n<p>strict 模式下对于默认绑定来说全局对象是不合法的，所以<code>this</code>将被设置为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: `this` is `undefined`</span></span><br></pre></td></tr></table></div></figure>\n<p>注意：this的绑定规则基于调用点，但判断是否在 strict 模式则是取决于函数体。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里不是严格模式</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"隐式绑定（Implicit-Binding）\">隐式绑定（Implicit Binding）<a href=\"post/2018-05-25-你不知道的JS-2#隐式绑定（Implicit-Binding）\"></a></h4><p>另一种要考虑的规则是：调用点是否有上下文对象，或者说是否被某个对象拥有或者包含。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里函数 foo() 是先定义然后作为引用属性添加到 obj 中的，严格说函数 foo() 不属于 obj。</span></span><br><span class=\"line\"><span class=\"comment\">// 然而调用栈会使用 obj 上下文来引用函数，因此可以说函数被调用的时候 obj “拥有”或“包含”它。</span></span><br></pre></td></tr></table></div></figure>\n<p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的<code>this</code>绑定到这个上下文对象。因此<code>this.a</code>和<code>obj.a</code>是一样的。</p>\n<blockquote>\n<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</p>\n</blockquote>\n<p><strong>隐式丢失</strong></p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo; <span class=\"comment\">// 函数引用！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// `a` 也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></div></figure>\n<p>尽管<code>bar</code>似乎是<code>obj.foo</code>的引用，但实际上它只是另一个<code>foo</code>本身的引用而已。另外，起作用的调用点是<code>bar()</code>，一个直白，毫无修饰的调用，因此这里适用默认绑定。</p>\n<p>当我们传递一个回调函数时，参数传递其实就是一种隐式赋值，因此我们在传入参数时也会被隐式的引用赋值：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">  fn(); <span class=\"comment\">// &lt;-- 调用点!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// `a` 也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">doFoo( obj.foo ); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></div></figure>\n<h4 id=\"显式绑定（Explicit-Binding）\">显式绑定（Explicit Binding）<a href=\"post/2018-05-25-你不知道的JS-2#显式绑定（Explicit-Binding）\"></a></h4><p>JavaScript 中绝大多数内置的函数以及你创建的所有的函数，都可以访问<code>call(..)</code>和<code>apply(..)</code>。我们可以通过它来进行显式绑定。不过单独依靠明确绑定仍然不能解决函数“丢失”自己原本的<code>this</code>绑定的问题。</p>\n<p><strong>硬绑定（Hard Binding）</strong></p>\n<p>ES5 的内建工具提供<code>Function.prototype.bind</code>进行硬绑定：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></div></figure>\n<p><code>bind(..)</code>返回一个硬编码的新函数，它使用你指定的<code>this</code>环境来调用原本的函数。</p>\n<p>它的思想来自这里：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单的 `bind` 帮助函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = bind( foo, obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></div></figure>\n<p>这里创建了一个函数，在它的内部手动调用<code>fn.apply(obj, arguments)</code>，由此强制<code>this</code>绑定到<code>obj</code>并调用<code>fn</code>。无论你过后怎样调用函数，它总是手动使用<code>obj</code>调用<code>foo</code>。</p>\n<h4 id=\"new-绑定（new-Binding）\">new 绑定（new Binding）<a href=\"post/2018-05-25-你不知道的JS-2#new-绑定（new-Binding）\"></a></h4><p>在 JavaScript 中，构造函数只是一些使用<code>new</code>操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，他们只是被<code>new</code>操作符调用的普通函数而已。</p>\n<p>可以说任何函数，都可以在前面加上<code>new</code>来被调用，这使函数调用成为一个构造器调用（constructor call）。这是一个重要而微妙的区别：实际上不存在“构造器函数”这样的东西，而只有函数的构造器调用。</p>\n<h3 id=\"优先级\">优先级<a href=\"post/2018-05-25-你不知道的JS-2#优先级\"></a></h3><p>判定<code>this</code>的顺序：</p>\n<ol>\n<li>函数是通过<code>new</code>被调用的吗（new 绑定）？如果是，<code>this</code>就是新构建的对象。</li>\n<li>函数是通过<code>call</code>或<code>apply</code>被调用（明确绑定），甚至是隐藏在<code>bind</code>硬绑定之中吗？如果是，<code>this</code>就是那个被明确指定的对象。</li>\n<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，<code>this</code>就是那个环境对象。</li>\n<li>否则，使用默认的<code>this</code>（默认绑定）。如果在 strict mode 下，就是<code>undefined</code>，否则是<code>global</code>对象。</li>\n</ol>\n<h3 id=\"绑定的特例\">绑定的特例<a href=\"post/2018-05-25-你不知道的JS-2#绑定的特例\"></a></h3><h4 id=\"被忽略的-this\">被忽略的 this<a href=\"post/2018-05-25-你不知道的JS-2#被忽略的-this\"></a></h4><p>如果你传递<code>null</code>或<code>undefined</code>作为<code>call</code>、<code>apply</code>或<code>bind</code>的<code>this</code>绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call( <span class=\"literal\">null</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n<p>进行<code>this</code>绑定的时候故意传<code>null</code>可以对参数进行柯里化：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组散开作为参数</span></span><br><span class=\"line\">foo.apply( <span class=\"literal\">null</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `bind(..)` 进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( <span class=\"literal\">null</span>, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></div></figure>\n<p><strong>更安全的this</strong></p>\n<p>对于那些确实使用了<code>this</code>引用的函数，默认绑定规则会把<code>this</code>绑定到全局对象（在浏览器中是 window）上，这将导致不可预计的后果（比如修改全局对象）。</p>\n<blockquote>\n<p>DMZ（demilitarized zone，非军事区）对象：空的非委托的对象</p>\n</blockquote>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们的 DMZ 空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ø = <span class=\"built_in\">Object</span>.create( <span class=\"literal\">null</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组散开作为参数</span></span><br><span class=\"line\">foo.apply( ø, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `bind(..)` 进行 currying</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( ø, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p><code>Object.create(null)</code>是创建完全为空的对象的最简单方法。<code>Object.create(null)</code>和<code>{}</code>很相似，但是没有指向<code>Object.prototype</code>的委托，所以它比<code>{}</code>“空得更彻底”。</p>\n</blockquote>\n<h4 id=\"间接\">间接<a href=\"post/2018-05-25-你不知道的JS-2#间接\"></a></h4><p>对函数的“间接引用”适用默认绑定规则：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n<p>赋值表达式<code>p.foo = o.foo</code>的返回值是目标函数的引用。所以调用点就是<code>foo()</code>而不是<code>p.foo()</code>或<code>o.foo()</code>。所以这里适用默认绑定。</p>\n<h3 id=\"词法this\">词法this<a href=\"post/2018-05-25-你不知道的JS-2#词法this\"></a></h3><p>ES6 引入的箭头函数不适用于这些规则，箭头函数从外层作用域来决定<code>this</code>绑定。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// this 遵从词法作用域继承自 foo()</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2, 不是3!</span></span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>箭头函数的绑定是无法被修改的（<code>new</code>也不行！）</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"this是什么？\"><a href=\"#this是什么？\" class=\"headerlink\" title=\"this是什么？\"></a>this是什么？</h2><ul>\n<li>函数内部的<code>this</code>并不是指向函数自己；</li>\n<li><code>this</code>不会以任何方式指向函数的词法作用域；</li>\n<li><code>this</code>不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。<code>this</code>绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</li>\n</ul>\n<p>当一个函数被调用时，会建立 <strong>活动记录</strong> （有时也称为执行上下文）。这个记录包含函数是从何处（调用栈 —— call-stack）被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的<code>this</code>引用。</p>\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><h3 id=\"调用点（Call-site）\"><a href=\"#调用点（Call-site）\" class=\"headerlink\" title=\"调用点（Call-site）\"></a>调用点（Call-site）</h3><p>寻找调用点就是寻找函数被调用的位置，最重要的是分析调用栈，调用点就在当前执行中的函数的前一个调用中。</p>\n<blockquote>\n<p>调用栈: 使我们到达当前执行位置而被调用的所有方法的堆栈</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用栈是: `baz`</span></span><br><span class=\"line\">\t<span class=\"comment\">// 我们的调用点是 global scope（全局作用域）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"baz\"</span> );</span><br><span class=\"line\">\tbar(); <span class=\"comment\">// &lt;-- `bar` 的调用点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用栈是: `baz` -&gt; `bar`</span></span><br><span class=\"line\">\t<span class=\"comment\">// 我们的调用点位于 `baz`</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\">\tfoo(); <span class=\"comment\">// &lt;-- `foo` 的 call-site</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用栈是: `baz` -&gt; `bar` -&gt; `foo`</span></span><br><span class=\"line\">  <span class=\"comment\">// 我们的调用点位于 `bar`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); <span class=\"comment\">// &lt;-- `baz` 的调用点</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><h4 id=\"默认绑定（Default-Binding）\"><a href=\"#默认绑定（Default-Binding）\" class=\"headerlink\" title=\"默认绑定（Default Binding）\"></a>默认绑定（Default Binding）</h4><p>当我们直接使用不带任何修饰的函数引用进行调用时，对应默认绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里 this 指向全局对象</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>strict 模式下对于默认绑定来说全局对象是不合法的，所以<code>this</code>将被设置为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: `this` is `undefined`</span></span><br></pre></td></tr></table></figure>\n<p>注意：this的绑定规则基于调用点，但判断是否在 strict 模式则是取决于函数体。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里不是严格模式</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式绑定（Implicit-Binding）\"><a href=\"#隐式绑定（Implicit-Binding）\" class=\"headerlink\" title=\"隐式绑定（Implicit Binding）\"></a>隐式绑定（Implicit Binding）</h4><p>另一种要考虑的规则是：调用点是否有上下文对象，或者说是否被某个对象拥有或者包含。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里函数 foo() 是先定义然后作为引用属性添加到 obj 中的，严格说函数 foo() 不属于 obj。</span></span><br><span class=\"line\"><span class=\"comment\">// 然而调用栈会使用 obj 上下文来引用函数，因此可以说函数被调用的时候 obj “拥有”或“包含”它。</span></span><br></pre></td></tr></table></figure>\n<p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的<code>this</code>绑定到这个上下文对象。因此<code>this.a</code>和<code>obj.a</code>是一样的。</p>\n<blockquote>\n<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</p>\n</blockquote>\n<p><strong>隐式丢失</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo; <span class=\"comment\">// 函数引用！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// `a` 也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<p>尽管<code>bar</code>似乎是<code>obj.foo</code>的引用，但实际上它只是另一个<code>foo</code>本身的引用而已。另外，起作用的调用点是<code>bar()</code>，一个直白，毫无修饰的调用，因此这里适用默认绑定。</p>\n<p>当我们传递一个回调函数时，参数传递其实就是一种隐式赋值，因此我们在传入参数时也会被隐式的引用赋值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">  fn(); <span class=\"comment\">// &lt;-- 调用点!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// `a` 也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">doFoo( obj.foo ); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"显式绑定（Explicit-Binding）\"><a href=\"#显式绑定（Explicit-Binding）\" class=\"headerlink\" title=\"显式绑定（Explicit Binding）\"></a>显式绑定（Explicit Binding）</h4><p>JavaScript 中绝大多数内置的函数以及你创建的所有的函数，都可以访问<code>call(..)</code>和<code>apply(..)</code>。我们可以通过它来进行显式绑定。不过单独依靠明确绑定仍然不能解决函数“丢失”自己原本的<code>this</code>绑定的问题。</p>\n<p><strong>硬绑定（Hard Binding）</strong></p>\n<p>ES5 的内建工具提供<code>Function.prototype.bind</code>进行硬绑定：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p><code>bind(..)</code>返回一个硬编码的新函数，它使用你指定的<code>this</code>环境来调用原本的函数。</p>\n<p>它的思想来自这里：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单的 `bind` 帮助函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = bind( foo, obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>这里创建了一个函数，在它的内部手动调用<code>fn.apply(obj, arguments)</code>，由此强制<code>this</code>绑定到<code>obj</code>并调用<code>fn</code>。无论你过后怎样调用函数，它总是手动使用<code>obj</code>调用<code>foo</code>。</p>\n<h4 id=\"new-绑定（new-Binding）\"><a href=\"#new-绑定（new-Binding）\" class=\"headerlink\" title=\"new 绑定（new Binding）\"></a>new 绑定（new Binding）</h4><p>在 JavaScript 中，构造函数只是一些使用<code>new</code>操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，他们只是被<code>new</code>操作符调用的普通函数而已。</p>\n<p>可以说任何函数，都可以在前面加上<code>new</code>来被调用，这使函数调用成为一个构造器调用（constructor call）。这是一个重要而微妙的区别：实际上不存在“构造器函数”这样的东西，而只有函数的构造器调用。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>判定<code>this</code>的顺序：</p>\n<ol>\n<li>函数是通过<code>new</code>被调用的吗（new 绑定）？如果是，<code>this</code>就是新构建的对象。</li>\n<li>函数是通过<code>call</code>或<code>apply</code>被调用（明确绑定），甚至是隐藏在<code>bind</code>硬绑定之中吗？如果是，<code>this</code>就是那个被明确指定的对象。</li>\n<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，<code>this</code>就是那个环境对象。</li>\n<li>否则，使用默认的<code>this</code>（默认绑定）。如果在 strict mode 下，就是<code>undefined</code>，否则是<code>global</code>对象。</li>\n</ol>\n<h3 id=\"绑定的特例\"><a href=\"#绑定的特例\" class=\"headerlink\" title=\"绑定的特例\"></a>绑定的特例</h3><h4 id=\"被忽略的-this\"><a href=\"#被忽略的-this\" class=\"headerlink\" title=\"被忽略的 this\"></a>被忽略的 this</h4><p>如果你传递<code>null</code>或<code>undefined</code>作为<code>call</code>、<code>apply</code>或<code>bind</code>的<code>this</code>绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call( <span class=\"literal\">null</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>进行<code>this</code>绑定的时候故意传<code>null</code>可以对参数进行柯里化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组散开作为参数</span></span><br><span class=\"line\">foo.apply( <span class=\"literal\">null</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `bind(..)` 进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( <span class=\"literal\">null</span>, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></figure>\n<p><strong>更安全的this</strong></p>\n<p>对于那些确实使用了<code>this</code>引用的函数，默认绑定规则会把<code>this</code>绑定到全局对象（在浏览器中是 window）上，这将导致不可预计的后果（比如修改全局对象）。</p>\n<blockquote>\n<p>DMZ（demilitarized zone，非军事区）对象：空的非委托的对象</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们的 DMZ 空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ø = <span class=\"built_in\">Object</span>.create( <span class=\"literal\">null</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组散开作为参数</span></span><br><span class=\"line\">foo.apply( ø, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `bind(..)` 进行 currying</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( ø, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Object.create(null)</code>是创建完全为空的对象的最简单方法。<code>Object.create(null)</code>和<code>{}</code>很相似，但是没有指向<code>Object.prototype</code>的委托，所以它比<code>{}</code>“空得更彻底”。</p>\n</blockquote>\n<h4 id=\"间接\"><a href=\"#间接\" class=\"headerlink\" title=\"间接\"></a>间接</h4><p>对函数的“间接引用”适用默认绑定规则：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>赋值表达式<code>p.foo = o.foo</code>的返回值是目标函数的引用。所以调用点就是<code>foo()</code>而不是<code>p.foo()</code>或<code>o.foo()</code>。所以这里适用默认绑定。</p>\n<h3 id=\"词法this\"><a href=\"#词法this\" class=\"headerlink\" title=\"词法this\"></a>词法this</h3><p>ES6 引入的箭头函数不适用于这些规则，箭头函数从外层作用域来决定<code>this</code>绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// this 遵从词法作用域继承自 foo()</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2, 不是3!</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>箭头函数的绑定是无法被修改的（<code>new</code>也不行！）</p>\n</blockquote>\n","plink":"https://vincentdou.github.io/blog/post/2018-05-25-你不知道的JS-2/","type":"post","toc":[{"title":"this是什么？","id":"this是什么？","index":"1"},{"title":"this全面解析","id":"this全面解析","index":"2","children":[{"title":"调用点（Call-site）","id":"调用点（Call-site）","index":"2.1"},{"title":"绑定规则","id":"绑定规则","index":"2.2","children":[{"title":"默认绑定（Default Binding）","id":"默认绑定（Default-Binding）","index":"2.2.1"},{"title":"隐式绑定（Implicit Binding）","id":"隐式绑定（Implicit-Binding）","index":"2.2.2"},{"title":"显式绑定（Explicit Binding）","id":"显式绑定（Explicit-Binding）","index":"2.2.3"},{"title":"new 绑定（new Binding）","id":"new-绑定（new-Binding）","index":"2.2.4"}]},{"title":"优先级","id":"优先级","index":"2.3"},{"title":"绑定的特例","id":"绑定的特例","index":"2.4","children":[{"title":"被忽略的 this","id":"被忽略的-this","index":"2.4.1"},{"title":"间接","id":"间接","index":"2.4.2"}]},{"title":"词法this","id":"词法this","index":"2.5"}]}]},{"layout":"post","title":"[转]Vuex 2.0 源码分析","date":"2018-07-25T16:00:00.000Z","author":"Vincent","catalog":true,"_content":"\n> 原文：[Vuex 2.0 源码分析](https://github.com/DDFE/DDFE-blog/issues/8)\n\n## 目录结构\n\nVuex 的源码托管在 github，我们首先通过 git 把代码 clone 到本地，选一款适合自己的 IDE 打开源码，展开 src 目录，如下图所示：\n\n![](https://camo.githubusercontent.com/4c0c82eb95a6d128f80355522e266fe5220ca863/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565785f7372632e706e67)\n\nsrc 目录下的文件并不多，包含几个 js 文件和 plugins 目录， plugins 目录里面包含 2 个 Vuex 的内置插件，整个源码加起来不过 500-600 行，可谓非常轻巧的一个库。\n\n麻雀虽小，五脏俱全，我们先直观的感受一下源码的结构，接下来看一下其中的实现细节。\n\n## 源码分析\n\n本文的源码分析过程不会是自上而下的给代码加注释，我更倾向于是从 Vuex 提供的 API 和我们的使用方法等维度去分析。Vuex 的源码是基于 es6 的语法编写的，对于不了解 es6 的同学，建议还是先学习一下 es6。\n\n### 从入口开始\n\n看源码一般是从入口开始，Vuex 源码的入口是 src/index.js，先来打开这个文件。\n\n我们首先看这个库的 export ，在 index.js 代码最后。\n\n```js\nexport default {\n  Store,\n  install,\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions\n}\n```\n\n这里可以一目了然地看到 Vuex 对外暴露的 API。其中, Store 是 Vuex 提供的状态存储类，通常我们使用 Vuex 就是通过创建 Store 的实例，稍后我们会详细介绍。接着是 install 方法，这个方法通常是我们编写第三方 Vue 插件的“套路”，先来看一下“套路”代码：\n\n```js\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n```\n\n我们实现了一个 install 方法，这个方法当我们全局引用 Vue ，也就是 window 上有 Vue 对象的时候，会手动调用 install 方法，并传入 Vue 的引用；当 Vue 通过 npm 安装到项目中的时候，我们在代码中引入第三方 Vue 插件通常会编写如下代码：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n...\nVue.use(Vuex)\n```\n\n当我们执行 Vue.use(Vuex) 这句代码的时候，实际上就是调用了 install 的方法并传入 Vue 的引用。install 方法顾名思义，现在让我们来看看它的实现。它接受了一个参数 _Vue，函数体首先判断 Vue ，这个变量的定义在 index.js 文件的开头部分：\n\n```js\nlet Vue // bind on install\n```\n\n对 Vue 的判断主要是保证 install 方法只执行一次，这里把 install 方法的参数 _Vue 对象赋值给 Vue 变量，这样我们就可以在 index.js 文件的其它地方使用 Vue 这个变量了。install 方法的最后调用了 applyMixin 方法，我们顺便来看一下这个方法的实现，在 src/mixin.js 文件里定义：\n\n```js\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n```\n\n这段代码的作用就是在 Vue 的生命周期中的初始化（1.0 版本是 init，2.0 版本是 beforeCreated）钩子前插入一段 Vuex 初始化代码。这里做的事情很简单——给 Vue 的实例注入一个 `$store` 的属性，这也就是为什么我们在 Vue 的组件中可以通过 `this.$store.xxx` 访问到 Vuex 的各种数据和状态。\n\n### 认识 Store 构造函数\n\n我们在使用 Vuex 的时候，通常会实例化 Store 类，然后传入一个对象，包括我们定义好的 actions、getters、mutations、state等，甚至当我们有多个子模块的时候，我们可以添加一个 modules 对象。那么实例化的时候，到底做了哪些事情呢？带着这个疑问，让我们回到 index.js 文件，重点看一下 Store 类的定义。Store 类定义的代码略长，我不会一下就贴上所有代码，我们来拆解分析它，首先看一下构造函数的实现：\n\n```js\nclass Store {\n  constructor (options = {}) {\n    assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n    assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n\n    const {\n      state = {},\n      plugins = [],\n      strict = false\n    } = options\n\n    // store internal state\n    this._options = options\n    this._committing = false\n    this._actions = Object.create(null)\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    this._runtimeModules = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // bind commit and dispatch to self\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // strict mode\n    this.strict = strict\n\n    // init root module.\n    // this also recursively registers all sub-modules\n    // and collects all module getters inside this._wrappedGetters\n    installModule(this, state, [], options)\n\n    // initialize the store vm, which is responsible for the reactivity\n    // (also registers _wrappedGetters as computed properties)\n    resetStoreVM(this, state)\n\n    // apply plugins\n    plugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n  }\n  ...\n}\n```\n\n构造函数的一开始就用了“断言函数”，来判断是否满足一些条件。\n\n```js\nassert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n```\n\n这行代码的目的是确保 Vue 的存在，也就是在我们实例化 Store 之前，必须要保证之前的 install 方法已经执行了。\n\n```js\nassert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n```\n\n这行代码的目的是为了确保 Promsie 可以使用的，因为 Vuex 的源码是依赖 Promise 的。Promise 是 es6 提供新的 API，由于现在的浏览器并不是都支持 es6 语法的，所以通常我们会用 babel 编译我们的代码，如果想使用 Promise 这个 特性，我们需要在 package.json 中添加对 babel-polyfill 的依赖并在代码的入口加上 import 'babel-polyfill' 这段代码。\n\n再来看看 assert 这个函数，它并不是浏览器原生支持的，它的实现在 src/util.js 里，代码如下：\n\n```js\nexport function assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n```\n\n非常简单，对 condition 判断，如果不不为真，则抛出异常。这个函数虽然简单，但这种编程方式值得我们学习。\n\n再来看构造函数接下来的代码：\n\n```js\nconst {\n  state = {},\n  plugins = [],\n  strict = false\n} = options\n```\n\n这里就是利用 es6 的解构赋值拿到 options 里的 state，plugins 和 strict。state 表示 rootState，plugins 表示应用的插件、strict 表示是否开启严格模式。\n\n接着往下看：\n\n```js\n// store internal state\nthis._options = options\nthis._committing = false\nthis._actions = Object.create(null)\nthis._mutations = Object.create(null)\nthis._wrappedGetters = Object.create(null)\nthis._runtimeModules = Object.create(null)\nthis._subscribers = []\nthis._watcherVM = new Vue()\n```\n\n这里主要是创建一些内部的属性：\nthis._options 存储参数 options。\nthis._committing 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state。\nthis._actions 用来存储用户定义的所有的 actions。\nthis._mutations 用来存储用户定义所有的 mutatins。\nthis._wrappedGetters 用来存储用户定义的所有 getters 。\nthis._runtimeModules 用来存储所有的运行时的 modules。\nthis._subscribers 用来存储所有对 mutation 变化的订阅者。\nthis._watcherVM 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化的。\n\n继续往下看：\n\n```js\n// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}\n\n// strict mode\nthis.strict = strict\n```\n\n这里的代码也不难理解，把 Store 类的 dispatch 和 commit 的方法的 this 指针指向当前 store 的实例上，dispatch 和 commit 的实现我们稍后会分析。this.strict 表示是否开启严格模式，在严格模式下会观测所有的 state 的变化，建议在开发环境时开启严格模式，线上环境要关闭严格模式，否则会有一定的性能开销。\n\n### Vuex 的初始化核心\n\n#### installModule\n\n我们接着往下看：\n\n```js\n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], options)\n\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)\n\n// apply plugins\nplugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n```\n\n这段代码是 Vuex 的初始化的核心，其中，installModule 方法是把我们通过 options 传入的各种属性模块注册和安装；resetStoreVM 方法是初始化 store._vm，观测 state 和 getters 的变化；最后是应用传入的插件。\n\n下面，我们先来看一下 installModule 的实现：\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const {\n    state,\n    actions,\n    mutations,\n    getters,\n    modules\n  } = module\n\n  // set state\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, state || {})\n    })\n  }\n\n  if (mutations) {\n    Object.keys(mutations).forEach(key => {\n      registerMutation(store, key, mutations[key], path)\n    })\n  }\n\n  if (actions) {\n    Object.keys(actions).forEach(key => {\n      registerAction(store, key, actions[key], path)\n    })\n  }\n\n  if (getters) {\n    wrapGetters(store, getters, path)\n  }\n\n  if (modules) {\n    Object.keys(modules).forEach(key => {\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n    })\n  }\n}\n```\n\ninstallModule 函数可接收5个参数，store、rootState、path、module、hot，store 表示当前 Store 实例，rootState 表示根 state，path 表示当前嵌套模块的路径数组，module 表示当前安装的模块，hot 当动态改变 modules 或者热更新的时候为 true。\n\n先来看这部分代码：\n\n```js\nconst isRoot = !path.length\nconst {\n  state,\n  actions,\n  mutations,\n  getters,\n  modules\n} = module\n```\n\n代码首先通过 path 数组的长度判断是否为根。我们在构造函数调用的时候是 installModule(this, state, [], options)，所以这里 isRoot 为 true。module 为传入的 options，我们拿到了 module 下的 state、actions、mutations、getters 以及嵌套的 modules。\n\n接着看下面的代码：\n\n```js\n// set state\nif (!isRoot && !hot) {\n  const parentState = getNestedState(rootState, path.slice(0, -1))\n  const moduleName = path[path.length - 1]\n  store._withCommit(() => {\n    Vue.set(parentState, moduleName, state || {})\n  })\n}\n```\n\n这里判断当不为根且非热更新的情况，然后设置级联状态，这里乍一看不好理解，我们先放一放，稍后来回顾。\n\n再往下看代码：\n\n```js\nif (mutations) {\n  Object.keys(mutations).forEach(key => {\n    registerMutation(store, key, mutations[key], path)\n  })\n}\n\nif (actions) {\n  Object.keys(actions).forEach(key => {\n    registerAction(store, key, actions[key], path)\n  })\n}\n\nif (getters) {\n  wrapGetters(store, getters, path)\n}\n```\n\n这里分别是对 mutations、actions、getters 进行注册，如果我们实例化 Store 的时候通过 options 传入这些对象，那么会分别进行注册，我稍后再去介绍注册的具体实现。那么到这，如果 Vuex 没有 module ，这个 installModule 方法可以说已经做完了。但是 Vuex 巧妙了设计了 module 这个概念，因为 Vuex 本身是单一状态树，应用的所有状态都包含在一个大对象内，随着我们应用规模的不断增长，这个 Store 变得非常臃肿。为了解决这个问题，Vuex 允许我们把 store 分 module（模块）。每一个模块包含各自的 state、mutations、actions 和 getters，甚至是嵌套模块。所以，接下来还有一行代码：\n\n```js\nif (modules) {\n  Object.keys(modules).forEach(key => {\n    installModule(store, rootState, path.concat(key), modules[key], hot)\n  })\n}\n```\n\n这里通过遍历 modules，递归调用 installModule 去安装子模块。这里传入了 store、rootState、path.concat(key)、和 modules[key]，和刚才不同的是，path 不为空，module 对应为子模块，那么我们回到刚才那段代码：\n\n```js\n// set state\nif (!isRoot && !hot) {\n  const parentState = getNestedState(rootState, path.slice(0, -1))\n  const moduleName = path[path.length - 1]\n  store._withCommit(() => {\n    Vue.set(parentState, moduleName, state || {})\n  })\n}\n```\n\n当递归初始化子模块的时候，isRoot 为 false，注意这里有个方法getNestedState(rootState, path)，来看一下 getNestedState 函数的定义：\n\n```js\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) => state[key], state)\n    : state\n}\n```\n\n这个方法很简单，就是根据 path 查找 state 上的嵌套 state。在这里就是传入 rootState 和 path，计算出当前模块的父模块的 state，由于模块的 path 是根据模块的名称 concat 连接的，所以 path 的最后一个元素就是当前模块的模块名，最后调用\n\n```js\nstore._withCommit(() => {\n  Vue.set(parentState, moduleName, state || {})\n})\n```\n\n把当前模块的 state 添加到 parentState 中。\n这里注意一下我们用了 store._withCommit 方法，来看一下这个方法的定义：\n\n```js\n_withCommit (fn) {\n  const committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n}\n```\n\n由于我们是在修改 state，Vuex 中所有对 state 的修改都会用 _withCommit函数包装，保证在同步修改 state 的过程中 this._committing 的值始终为true。这样当我们观测 state 的变化时，如果 this._committing 的值不为 true，则能检查到这个状态修改是有问题的。\n\n看到这里，有些同学可能会有点困惑，举个例子来直观感受一下，以 Vuex 源码中的 example/shopping-cart 为例，打开 store/index.js，有这么一段代码：\n\n```js\nexport default new Vuex.Store({\n  actions,\n  getters,\n  modules: {\n    cart,\n    products\n  },\n  strict: debug,\n  plugins: debug ? [createLogger()] : []\n})\n```\n\n这里有两个子 module，cart 和 products，我们打开 store/modules/cart.js，看一下 cart 模块中的 state 定义，代码如下：\n\n```js\nconst state = {\n  added: [],\n  checkoutStatus: null\n}\n```\n\n我们运行这个项目，打开浏览器，利用 Vue 的调试工具来看一下 Vuex 中的状态，如下图所示：\n\n![](https://camo.githubusercontent.com/2bd2ed9ea9f74792db15c5980666275330ab64a2/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565782d746573742e706e67)\n\n可以看到，在 rootState 下，分别有 cart 和 products 2个属性，key 根据模块名称而来，value 就是在每个模块文件中定义的 state，这就把模块 state 挂载到 rootState 上了。\n\n我们了解完嵌套模块 state 是怎么一回事后，我们回过头来看一下 installModule 过程中的其它 3 个重要方法：registerMutation、registerAction 和 wrapGetters。顾名思义，这 3 个方法分别处理 mutations、actions 和 getters。我们先来看一下 registerMutation 的定义：\n\n#### registerMutation\n\n```js\nfunction registerMutation (store, type, handler, path = []) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler(getNestedState(store.state, path), payload)\n  })\n}\n```\n\nregisterMutation 是对 store 的 mutation 的初始化，它接受 4 个参数，store为当前 Store 实例，type为 mutation 的 key，handler 为 mutation 执行的回调函数，path 为当前模块的路径。mutation 的作用就是同步修改当前模块的 state ，函数首先通过 type 拿到对应的 mutation 对象数组， 然后把一个 mutation 的包装函数 push 到这个数组中，这个函数接收一个参数 payload，这个就是我们在定义 mutation 的时候接收的额外参数。这个函数执行的时候会调用 mutation 的回调函数，并通过 getNestedState(store.state, path) 方法得到当前模块的 state，和 playload 一起作为回调函数的参数。举个例子：\n\n```js\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n```\n\n这里我们定义了一个 mutation，通过刚才的 registerMutation 方法，我们注册了这个 mutation，这里的 state 对应的就是当前模块的 state，n 就是额外参数 payload，接下来我们会从源码分析的角度来介绍这个 mutation 的回调是何时被调用的，参数是如何传递的。\n\n我们有必要知道 mutation 的回调函数的调用时机，在 Vuex 中，mutation 的调用是通过 store 实例的 API 接口 commit 来调用的，来看一下 commit 函数的定义：\n\n```js\ncommit (type, payload, options) {\n  // check object-style commit\n  if (isObject(type) && type.type) {\n    options = payload\n    payload = type\n    type = type.type\n  }\n  const mutation = { type, payload }\n  const entry = this._mutations[type]\n  if (!entry) {\n    console.error(`[vuex] unknown mutation type: ${type}`)\n    return\n  }\n  this._withCommit(() => {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n  if (!options || !options.silent) {\n    this._subscribers.forEach(sub => sub(mutation, this.state))\n  }\n}\n```\n\ncommit 支持 3 个参数，type 表示 mutation 的类型，payload 表示额外的参数，options 表示一些配置，比如 silent 等，稍后会用到。commit 函数首先对 type 的类型做了判断，处理了 type 为 object 的情况，接着根据 type 去查找对应的 mutation，如果找不到，则输出一条错误信息，否则遍历这个 type 对应的 mutation 对象数组，执行 handler(payload) 方法，这个方法就是之前定义的 wrappedMutationHandler(handler)，执行它就相当于执行了 registerMutation 注册的回调函数，并把当前模块的 state 和 额外参数 payload 作为参数传入。注意这里我们依然使用了 this._withCommit 的方法提交 mutation。commit 函数的最后，判断如果不是静默模式，则遍历 this._subscribers，调用回调函数，并把 mutation 和当前的根 state 作为参数传入。那么这个 this._subscribers 是什么呢？原来 Vuex 的 Store 实例提供了 subscribe API 接口，它的作用是订阅（注册监听） store 的 mutation。先来看一下它的实现：\n\n```js\nsubscribe (fn) {\n  const subs = this._subscribers\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn)\n  }\n  return () => {\n    const i = subs.indexOf(fn)\n    if (i > -1) {\n      subs.splice(i, 1)\n    }\n  }\n}\n```\n\nsubscribe 方法很简单，他接受的参数是一个回调函数，会把这个回调函数保存到 this._subscribers 上，并返回一个函数，当我们调用这个返回的函数，就可以解除当前函数对 store 的 mutation 的监听。其实，Vuex 的内置 logger 插件就是基于 subscribe 接口实现对 store 的 muation的监听，稍后我们会详细介绍这个插件。\n\n#### registerAction\n\n在了解完 registerMutation，我们再来看一下 registerAction 的定义：\n\n```js\nfunction registerAction (store, type, handler, path = []) {\nconst entry = store._actions[type] || (store._actions[type] = [])\n  const { dispatch, commit } = store\n  entry.push(function wrappedActionHandler (payload, cb) {\n    let res = handler({\n      dispatch,\n      commit,\n      getters: store.getters,\n      state: getNestedState(store.state, path),\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n```\n\nregisterAction 是对 store 的 action 的初始化，它和 registerMutation 的参数一致，和 mutation 不同一点，mutation 是同步修改当前模块的 state，而 action 是可以异步去修改 state，这里不要误会，在 action 的回调中并不会直接修改 state ，仍然是通过提交一个 mutation 去修改 state（在 Vuex 中，mutation 是修改 state 的唯一途径）。那我们就来看看 action 是如何做到这一点的。\n\n函数首先也是通过 type 拿到对应 action 的对象数组，然后把一个 action 的包装函数 push 到这个数组中，这个函数接收 2 个参数，payload 表示额外参数 ，cb 表示回调函数（实际上我们并没有使用它）。这个函数执行的时候会调用 action 的回调函数，传入一个 context 对象，这个对象包括了 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState 等等。接着对这个函数的返回值做判断，如果不是一个 Promise 对象，则调用 Promise.resolve（res） 给res 包装成了一个 Promise 对象。这里也就解释了为何 Vuex 的源码依赖 Promise，这里对 Promise 的判断也和简单，参考代码 src/util.js，对 isPromise 的判断如下：\n\n```js\nexport function isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n```\n\n其实就是简单的检查对象的 then 方法，如果包含说明就是一个 Promise 对象。\n\n接着判断 store._devtoolHook，这个只有当用到 Vuex devtools 开启的时候，我们才能捕获 promise 的过程中的 。 action 的包装函数最后返回 res ，它就是一个地地道道的 Promise 对象。来看个例子：\n\n```js\nactions: {\n  checkout ({ commit, state }, payload) {\n    // 把当前购物车的商品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发送结帐请求，并愉快地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接收一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n\n这里我们定义了一个 action，通过刚才的 registerAction 方法，我们注册了这个 action，这里的 commit 就是 store 的 API 接口，可以通过它在 action 里提交一个 mutation。state 对应的就是当前模块的 state，我们在这个 action 里即可以同步提交 mutation，也可以异步提交。接下来我们会从源码分析的角度来介绍这个 action 的回调是何时被调用的，参数是如何传递的。\n\n我们有必要知道 action 的回调函数的调用时机，在 Vuex 中，action 的调用是通过 store 实例的 API 接口 dispatch 来调用的，来看一下 dispatch 函数的定义：\n\n```js\ndispatch (type, payload) {\n// check object-style dispatch\n  if (isObject(type) && type.type) {\n    payload = type\n    type = type.type\n  }\n  const entry = this._actions[type]\n  if (!entry) {\n    console.error(`[vuex] unknown action type: ${type}`)\n    return\n  }\n  return entry.length > 1\n    ? Promise.all(entry.map(handler => handler(payload)))\n    : entry[0](payload)\n}\n```\n\ndispatch 支持2个参数，type 表示 action 的类型，payload 表示额外的参数。前面几行代码和 commit 接口非常类似，都是找到对应 type 下的 action 对象数组，唯一和 commit 不同的地方是最后部分，它对 action 的对象数组长度做判断，如果长度为 1 则直接调用`entry[0](payload)`， 这个方法就是之前定义的 wrappedActionHandler(payload, cb)，执行它就相当于执行了 registerAction 注册的回调函数，并把当前模块的 context 和 额外参数 payload 作为参数传入。所以我们在 action 的回调函数里，可以拿到当前模块的上下文包括 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState，可见 action 是非常灵活的。\n\n#### wrapGetters\n\n了解完 registerAction 后，我们来看看 wrapGetters的定义：\n\n```js\nfunction wrapGetters (store, moduleGetters, modulePath) {\n  Object.keys(moduleGetters).forEach(getterKey => {\n    const rawGetter = moduleGetters[getterKey]\n    if (store._wrappedGetters[getterKey]) {\n      console.error(`[vuex] duplicate getter key: ${getterKey}`)\n      return\n    }\n    store._wrappedGetters[getterKey] = function wrappedGetter (store) {\n      return rawGetter(\n        getNestedState(store.state, modulePath), // local state\n        store.getters, // getters\n        store.state // root state\n      )\n    }\n  })\n}\n```\n\nwrapGetters 是对 store 的 getters 初始化，它接受 3个 参数， store 表示当前 Store 实例，moduleGetters 表示当前模块下的所有 getters, modulePath 对应模块的路径。细心的同学会发现，和刚才的 registerMutation 以及 registerAction 不同，这里对 getters 的循环遍历是放在了函数体内，并且 getters 和它们的一个区别是不允许 getter 的 key 有重复。\n\n这个函数做的事情就是遍历 moduleGetters，把每一个 getter 包装成一个方法，添加到 store._wrappedGetters 对象中，注意 getter 的 key 是不允许重复的。在这个包装的方法里，会执行 getter 的回调函数，并把当前模块的 state，store 的 getters 和 store 的 rootState 作为它参数。来看一个例子：\n\n```js\nexport const cartProducts = state => {\n  return state.cart.added.map(({ id, quantity }) => {\n    const product = state.products.all.find(p => p.id === id)\n    return {\n      title: product.title,\n      price: product.price,\n      quantity\n    }\n  })\n}\n```\n\n这里我们定义了一个 getter，通过刚才的 wrapGetters 方法，我们把这个 getter 添加到 store._wrappedGetters 对象里，这和回调函数的参数 state 对应的就是当前模块的 state，接下来我们从源码的角度分析这个函数是如何被调用，参数是如何传递的。\n\n我们有必要知道 getter 的回调函数的调用时机，在 Vuex 中，我们知道当我们在组件中通过 `this.$store.getters.xxxgetters` 可以访问到对应的 getter 的回调函数，那么我们需要把对应 getter 的包装函数的执行结果绑定到 `this.$store` 上。这部分的逻辑就在 resetStoreVM 函数里。我们在 Store 的构造函数中，在执行完 installModule 方法后，就会执行 resetStoreVM 方法。来看一下它的定义：\n\n#### resetStoreVM\n\n```js\nfunction resetStoreVM (store, state) {\n  const oldVm = store._vm\n\n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  Object.keys(wrappedGetters).forEach(key => {\n    const fn = wrappedGetters[key]\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key]\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: { state },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(() => {\n      oldVm.state = null\n    })\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n```\n\n这个方法主要是重置一个私有的 _vm 对象，它是一个 Vue 的实例。这个 _vm 对象会保留我们的 state 树，以及用计算属性的方式存储了 store 的 getters。来具体看看它的实现过程。我们把这个函数拆成几个部分来分析：\n\n```js\nconst oldVm = store._vm\n\n// bind store public getters\nstore.getters = {}\nconst wrappedGetters = store._wrappedGetters\nconst computed = {}\nObject.keys(wrappedGetters).forEach(key => {\n  const fn = wrappedGetters[key]\n  // use computed to leverage its lazy-caching mechanism\n  computed[key] = () => fn(store)\n  Object.defineProperty(store.getters, key, {\n    get: () => store._vm[key]\n  })\n})\n```\n\n这部分留了现有的 store._vm 对象，接着遍历 store._wrappedGetters 对象，在遍历过程中，依次拿到每个 getter 的包装函数，并把这个包装函数执行的结果用 computed 临时变量保存。接着用 es5 的 Object.defineProperty 方法为 store.getters 定义了 get 方法，也就是当我们在组件中调用`this.$store.getters.xxxgetters`这个方法的时候，会访问 store._vm[xxxgetters]。我们接着往下看：\n\n```js\n// use a Vue instance to store the state tree\n// suppress warnings just in case the user has added\n// some funky global mixins\nconst silent = Vue.config.silent\nVue.config.silent = true\nstore._vm = new Vue({\n  data: { state },\n  computed\n})\nVue.config.silent = silent\n\n// enable strict mode for new vm\nif (store.strict) {\n  enableStrictMode(store)\n}\n```\n\n这部分的代码首先先拿全局 Vue.config.silent 的配置，然后临时把这个配置设成 true，接着实例化一个 Vue 的实例，把 store 的状态树 state 作为 data 传入，把我们刚才的临时变量 computed 作为计算属性传入。然后再把之前的 silent 配置重置。设置 silent 为 true 的目的是为了取消这个 _vm 的所有日志和警告。把 computed 对象作为 _vm 的 computed 属性，这样就完成了 getters 的注册。因为当我们在组件中访问 this.$store.getters.xxxgetters 的时候，就相当于访问 store._vm[xxxgetters]，也就是在访问 computed[xxxgetters]，这样就访问到了 xxxgetters 对应的回调函数了。这段代码最后判断 strict 属性决定是否开启严格模式，我们来看看严格模式都干了什么：\n\n```js\nfunction enableStrictMode (store) {\n  store._vm.$watch('state', () => {\n    assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n  }, { deep: true, sync: true })\n}\n```\n\n严格模式做的事情很简单，监测 store._vm.state 的变化，看看 state 的变化是否通过执行 mutation 的回调函数改变，如果是外部直接修改 state，那么 store._committing 的值为 false，这样就抛出一条错误。再次强调一下，Vuex 中对 state 的修改只能在 mutation 的回调函数里。\n\n回到 resetStoreVM 函数，我们来看一下最后一部分：\n\n```js\nif (oldVm) {\n  // dispatch changes in all subscribed watchers\n  // to force getter re-evaluation.\n  store._withCommit(() => {\n    oldVm.state = null\n  })\n  Vue.nextTick(() => oldVm.$destroy())\n}\n```\n\n这里的逻辑很简单，由于这个函数每次都会创建新的 Vue 实例并赋值到 store._vm 上，那么旧的 _vm 对象的状态设置为 null，并调用 $destroy 方法销毁这个旧的 _vm 对象。\n\n那么到这里，Vuex 的初始化基本告一段落了，初始化核心就是 installModule 和 resetStoreVM 函数。通过对 mutations 、actions 和 getters 的注册，我们了解到 state 的是按模块划分的，按模块的嵌套形成一颗状态树。而 actions、mutations 和 getters 的全局的，其中 actions 和 mutations 的 key 允许重复，但 getters 的 key 是不允许重复的。官方推荐我们给这些全局的对象在定义的时候加一个名称空间来避免命名冲突。\n从源码的角度介绍完 Vuex 的初始化的玩法，我们再从 Vuex 提供的 API 方向来分析其中的源码，看看这些 API 是如何实现的。\n\n### Vuex API 分析\n\nVuex 常见的 API 如 dispatch、commit 、subscribe 我们前面已经介绍过了，这里就不再赘述了，下面介绍的一些 Store 的 API，虽然不常用，但是了解一下也不错。\n\n#### watch(getter, cb, options)\n\nwatch 作用是响应式的监测一个 getter 方法的返回值，当值改变时调用回调。getter 接收 store 的 state 作为唯一参数。来看一下它的实现：\n\n```js\nwatch (getter, cb, options) {\n  assert(typeof getter === 'function', `store.watch only accepts a function.`)\n  return this._watcherVM.$watch(() => getter(this.state), cb, options)\n}\n```\n\n函数首先断言 watch 的 getter 必须是一个方法，接着利用了内部一个 Vue 的实例对象 `this._watcherVM` 的 $watch 方法，观测 getter 方法返回值的变化，如果有变化则调用 cb 函数，回调函数的参数为新值和旧值。watch 方法返回的是一个方法，调用它则取消观测。\n\n#### registerModule(path, module)\n\nregisterModule 的作用是注册一个动态模块，有的时候当我们异步加载一些业务的时候，可以通过这个 API 接口去动态注册模块，来看一下它的实现：\n\n```js\nregisterModule (path, module) {\n  if (typeof path === 'string') path = [path]\n  assert(Array.isArray(path), `module path must be a string or an Array.`)\n  this._runtimeModules[path.join('.')] = module\n  installModule(this, this.state, path, module)\n  // reset store to update getters...\n  resetStoreVM(this, this.state)\n}\n```\n\n函数首先对 path 判断，如果 path 是一个 string 则把 path 转换成一个 Array。接着把 module 对象缓存到 this._runtimeModules 这个对象里，path 用点连接作为该对象的 key。接着和初始化 Store 的逻辑一样，调用 installModule 和 resetStoreVm 方法安装一遍动态注入的 module。\n\n#### unregisterModule(path)\n\n和 registerModule 方法相对的就是 unregisterModule 方法，它的作用是注销一个动态模块，来看一下它的实现：\n\n```js\nunregisterModule (path) {\n  if (typeof path === 'string') path = [path]\n  assert(Array.isArray(path), `module path must be a string or an Array.`)\n  delete this._runtimeModules[path.join('.')]\n  this._withCommit(() => {\n    const parentState = getNestedState(this.state, path.slice(0, -1))\n    Vue.delete(parentState, path[path.length - 1])\n  })\n  resetStore(this)\n}\n```\n\n函数首先还是对 path 的类型做了判断，这部分逻辑和注册是一样的。接着从 this._runtimeModules 里删掉以 path 点连接的 key 对应的模块。接着通过 this._withCommit 方法把当前模块的 state 对象从父 state 上删除。最后调用 resetStore(this) 方法，来看一下这个方法的定义：\n\n```js\nfunction resetStore (store) {\n  store._actions = Object.create(null)\n  store._mutations = Object.create(null)\n  store._wrappedGetters = Object.create(null)\n  const state = store.state\n  // init root module\n  installModule(store, state, [], store._options, true)\n  // init all runtime modules\n  Object.keys(store._runtimeModules).forEach(key => {\n    installModule(store, state, key.split('.'), store._runtimeModules[key], true)\n  })\n  // reset vm\n  resetStoreVM(store, state)\n}\n```\n\n这个方法作用就是重置 store 对象，重置 store 的 _actions、_mutations、_wrappedGetters 等等属性。然后再次调用 installModules 去重新安装一遍 Module 对应的这些属性，注意这里我们的最后一个参数 hot 为true，表示它是一次热更新。这样在 installModule 这个方法体类，如下这段逻辑就不会执行\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  ... \n  // set state\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, state || {})\n    })\n  }\n  ...\n}\n```\n\n由于 hot 始终为 true，这里我们就不会重新对状态树做设置，我们的 state 保持不变。因为我们已经明确的删除了对应 path 下的 state 了，要做的事情只不过就是重新注册一遍 muations、actions 以及 getters。\n\n回调 resetStore 方法，接下来遍历 this._runtimeModules 模块，重新安装所有剩余的 runtime Moudles。最后还是调用 resetStoreVM 方法去重置 Store 的 _vm 对象。\n\n#### hotUpdate(newOptions)\n\nhotUpdate 的作用是热加载新的 action 和 mutation。 来看一下它的实现：\n\n```js\nhotUpdate (newOptions) {\n  updateModule(this._options, newOptions)\n  resetStore(this)\n}\n```\n\n函数首先调用 updateModule 方法去更新状态，其中当前 Store 的 opition 配置和要更新的 newOptions 会作为参数。来看一下这个函数的实现：\n\n```js\nfunction updateModule (targetModule, newModule) {\n  if (newModule.actions) {\n    targetModule.actions = newModule.actions\n  }\n  if (newModule.mutations) {\n    targetModule.mutations = newModule.mutations\n  }\n  if (newModule.getters) {\n    targetModule.getters = newModule.getters\n  }\n  if (newModule.modules) {\n    for (const key in newModule.modules) {\n      if (!(targetModule.modules && targetModule.modules[key])) {\n        console.warn(\n          `[vuex] trying to add a new module '${key}' on hot reloading, ` +\n          'manual reload is needed'\n        )\n        return\n      }\n      updateModule(targetModule.modules[key], newModule.modules[key])\n    }\n  }\n}\n```\n\n首先我们对 newOptions 对象的 actions、mutations 以及 getters 做了判断，如果有这些属性的话则替换 targetModule（当前 Store 的 options）对应的属性。最后判断如果 newOptions 包含 modules 这个 key，则遍历这个 modules 对象，如果 modules 对应的 key 不在之前的 modules 中，则报一条警告，因为这是添加一个新的 module ，需要手动重新加载。如果 key 在之前的 modules，则递归调用 updateModule，热更新子模块。\n\n调用完 updateModule 后，回到 hotUpdate 函数，接着调用 resetStore 方法重新设置 store，刚刚我们已经介绍过了。\n\n#### replaceState\n\nreplaceState的作用是替换整个 rootState，一般在用于调试，来看一下它的实现：\n\n```js\nreplaceState (state) {\n  this._withCommit(() => {\n    this._vm.state = state\n  })\n}\n```\n\n函数非常简单，就是调用 this._withCommit 方法修改 Store 的 rootState，之所以提供这个 API 是由于在我们是不能在 muations 的回调函数外部去改变 state。\n\n到此为止，API 部分介绍完了，其实整个 Vuex 源码下的 src/index.js 文件里的代码基本都过了一遍。\n\n### 辅助函数\n\nVuex 除了提供我们 Store 对象外，还对外提供了一系列的辅助函数，方便我们在代码中使用 Vuex，提供了操作 store 的各种属性的一系列语法糖，下面我们来一起看一下：\n\n#### mapState\n\nmapState 工具函数会将 store 中的 state 映射到局部计算属性中。为了更好理解它的实现，先来看一下它的使用示例：\n\n```js\n// vuex 提供了独立的构建工具函数 Vuex.mapState\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可以让代码非常简洁\n    count: state => state.count,\n    // 传入字符串 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n    // 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n当计算属性名称和状态子树名称对应相同时，我们可以向 mapState 工具函数传入一个字符串数组。\n\n```js\ncomputed: mapState([\n  // 映射 this.count 到 this.$store.state.count\n  'count'\n])\n```\n\n通过例子我们可以直观的看到，mapState 函数可以接受一个对象，也可以接收一个数组，那它底层到底干了什么事呢，我们一起来看一下源码这个函数的定义：\n\n```js\nexport function mapState (states) {\n  const res = {}\n  normalizeMap(states).forEach(({ key, val }) => {\n    res[key] = function mappedState () {\n      return typeof val === 'function'\n        ? val.call(this, this.$store.state, this.$store.getters)\n        : this.$store.state[val]\n    }\n  })\n  return res\n}\n```\n\n函数首先对传入的参数调用 normalizeMap 方法，我们来看一下这个函数的定义：\n\n```js\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(key => ({ key, val: key }))\n    : Object.keys(map).map(key => ({ key, val: map[key] }))\n}\n```\n\n这个方法判断参数 map 是否为数组，如果是数组，则调用数组的 map 方法，把数组的每个元素转换成一个 {key, val: key}的对象；否则传入的 map 就是一个对象（从 mapState 的使用场景来看，传入的参数不是数组就是对象），我们调用 Object.keys 方法遍历这个 map 对象的 key，把数组的每个 key 都转换成一个 {key, val: map[key]}的对象。最后我们把这个对象数组作为 normalizeMap 的返回值。\n\n回到 mapState 函数，在调用了 normalizeMap 函数后，把传入的 states 转换成由 {key, val} 对象构成的数组，接着调用 forEach 方法遍历这个数组，构造一个新的对象，这个新对象每个元素都返回一个新的函数 mappedState，函数对 val 的类型判断，如果 val 是一个函数，则直接调用这个 val 函数，把当前 store 上的 state 和 getters 作为参数，返回值作为 mappedState 的返回值；否则直接把 this.$store.state[val] 作为 mappedState 的返回值。\n\n那么为何 mapState 函数的返回值是这样一个对象呢，因为 mapState 的作用是把全局的 state 和 getters 映射到当前组件的 computed 计算属性中，我们知道在 Vue 中 每个计算属性都是一个函数。\n\n为了更加直观地说明，回到刚才的例子：\n\n```js\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可以让代码非常简洁\n    count: state => state.count,\n    // 传入字符串 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n    // 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n经过 mapState 函数调用后的结果，如下所示：\n\n```js\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: {\n    count() {\n\t  return this.$store.state.count\n    },\n    countAlias() {\n\t  return this.$store.state['count']\n    },\n    countPlusLocalState() {\n      return this.$store.state.count + this.localCount\n    }\n  }\n}\n```\n\n我们再看一下 mapState 参数为数组的例子：\n\n```js\ncomputed: mapState([\n  // 映射 this.count 到 this.$store.state.count\n  'count'\n])\n```\n\n经过 mapState 函数调用后的结果，如下所示：\n\n```js\ncomputed: {\n  count() {\n    return this.$store.state['count']\n  }\n}\n```\n\n#### mapGetters\n\nmapGetters 工具函数会将 store 中的 getter 映射到局部计算属性中。它的功能和 mapState 非常类似，我们来直接看它的实现：\n\n```js\nexport function mapGetters (getters) {\n  const res = {}\n  normalizeMap(getters).forEach(({ key, val }) => {\n    res[key] = function mappedGetter () {\n      if (!(val in this.$store.getters)) {\n        console.error(`[vuex] unknown getter: ${val}`)\n      }\n      return this.$store.getters[val]\n    }\n  })\n  return res\n}\n```\n\nmapGetters 的实现也和 mapState 很类似，不同的是它的 val 不能是函数，只能是一个字符串，而且会检查 val in this.$store.getters 的值，如果为 false 会输出一条错误日志。为了更直观地理解，我们来看一个简单的例子：\n\n```js\nimport { mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: {\n    // 使用对象扩展操作符把 getter 混入到 computed 中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n\n经过 mapGetters 函数调用后的结果，如下所示：\n\n```js\nimport { mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: {\n    doneTodosCount() {\n      return this.$store.getters['doneTodosCount']\n    },\n    anotherGetter() {\n      return this.$store.getters['anotherGetter']\n    }\n  }\n}\n```\n\n再看一个参数 mapGetters 参数是对象的例子：\n\n```js\ncomputed: mapGetters({\n  // 映射 this.doneCount 到 store.getters.doneTodosCount\n  doneCount: 'doneTodosCount'\n})\n```\n\n经过 mapGetters 函数调用后的结果，如下所示：\n\n```js\ncomputed: {\n  doneCount() {\n    return this.$store.getters['doneTodosCount']\n  }\n}\n```\n\n#### mapActions\n\nmapActions 工具函数会将 store 中的 dispatch 方法映射到组件的 methods 中。和 mapState、mapGetters 也类似，只不过它映射的地方不是计算属性，而是组件的 methods 对象上。我们来直接看它的实现：\n\n```js\nexport function mapActions (actions) {\n  const res = {}\n  normalizeMap(actions).forEach(({ key, val }) => {\n    res[key] = function mappedAction (...args) {\n      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n}\n```\n\n可以看到，函数的实现套路和 mapState、mapGetters 差不多，甚至更简单一些， 实际上就是做了一层函数包装。为了更直观地理解，我们来看一个简单的例子：\n\n```js\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment' // 映射 this.increment() 到 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n      add: 'increment' // 映射 this.add() to this.$store.dispatch('increment')\n    })\n  }\n}\n```\n\n经过 mapActions 函数调用后的结果，如下所示：\n\n```js\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    increment(...args) {\n      return this.$store.dispatch.apply(this.$store, ['increment'].concat(args))\n\t}\n    add(...args) {\n      return this.$store.dispatch.apply(this.$store, ['increment'].concat(args))\n\t}\n  }\n}\n```\n\n#### mapMutations\n\nmapMutations 工具函数会将 store 中的 commit 方法映射到组件的 methods 中。和 mapActions 的功能几乎一样，我们来直接看它的实现：\n\n```js\nexport function mapMutations (mutations) {\n  const res = {}\n  normalizeMap(mutations).forEach(({ key, val }) => {\n    res[key] = function mappedMutation (...args) {\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n}\n```\n\n函数的实现几乎也和 mapActions 一样，唯一差别就是映射的是 store 的 commit 方法。为了更直观地理解，我们来看一个简单的例子：\n\n```js\nimport { mapMutations } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment' // 映射 this.increment() 到 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n      add: 'increment' // 映射 this.add() 到 this.$store.commit('increment')\n    })\n  }\n}\n```\n\n经过 mapMutations 函数调用后的结果，如下所示：\n\n```js\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    increment(...args) {\n      return this.$store.commit.apply(this.$store, ['increment'].concat(args))\n\t}\n    add(...args) {\n      return this.$store.commit.apply(this.$store, ['increment'].concat(args))\n\t}\n  }\n}\n```\n\n### 插件\n\nVuex 的 store 接收 plugins 选项，一个 Vuex 的插件就是一个简单的方法，接收 store 作为唯一参数。插件作用通常是用来监听每次 mutation 的变化，来做一些事情。\n\n在 store 的构造函数的最后，我们通过如下代码调用插件：\n\n```js\nimport devtoolPlugin from './plugins/devtool'\n\n// apply plugins\nplugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n```\n\n我们通常实例化 store 的时候，还会调用 logger 插件，代码如下：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport createLogger from 'vuex/dist/logger'\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== 'production'\n\nexport default new Vuex.Store({\n  ...\n  plugins: debug ? [createLogger()] : []\n})\n```\n\n在上述 2 个例子中，我们分别调用了 devtoolPlugin 和 createLogger() 2 个插件，它们是 Vuex 内置插件，我们接下来分别看一下他们的实现。\n\n#### devtoolPlugin\n\ndevtoolPlugin 主要功能是利用 Vue 的开发者工具和 Vuex 做配合，通过开发者工具的面板展示 Vuex 的状态。它的源码在 src/plugins/devtool.js 中，来看一下这个插件到底做了哪些事情。\n\n```js\nconst devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\nexport default function devtoolPlugin (store) {\n  if (!devtoolHook) return\n\n  store._devtoolHook = devtoolHook\n\n  devtoolHook.emit('vuex:init', store)\n\n  devtoolHook.on('vuex:travel-to-state', targetState => {\n    store.replaceState(targetState)\n  })\n\n  store.subscribe((mutation, state) => {\n    devtoolHook.emit('vuex:mutation', mutation, state)\n  })\n}\n```\n\n我们直接从对外暴露的 devtoolPlugin 函数看起，函数首先判断了devtoolHook 的值，如果我们浏览器装了 Vue 开发者工具，那么在 window 上就会有一个 `__VUE_DEVTOOLS_GLOBAL_HOOK__` 的引用， 那么这个 devtoolHook 就指向这个引用。\n\n接下来通过 devtoolHook.emit('vuex:init', store) 派发一个 Vuex 初始化的事件，这样开发者工具就能拿到当前这个 store 实例。\n\n接下来通过 devtoolHook.on('vuex:travel-to-state', targetState => { store.replaceState(targetState) })监听 Vuex 的 traval-to-state 的事件，把当前的状态树替换成目标状态树，这个功能也是利用 Vue 开发者工具替换 Vuex 的状态。\n\n最后通过 store.subscribe((mutation, state) => { devtoolHook.emit('vuex:mutation', mutation, state) }) 方法订阅 store 的 state 的变化，当 store 的 mutation 提交了 state 的变化， 会触发回调函数——通过 devtoolHook 派发一个 Vuex mutation 的事件，mutation 和 rootState 作为参数，这样开发者工具就可以观测到 Vuex state 的实时变化，在面板上展示最新的状态树。\n\n#### loggerPlugin\n\n通常在开发环境中，我们希望实时把 mutation 的动作以及 store 的 state 的变化实时输出，那么我们可以用 loggerPlugin 帮我们做这个事情。它的源码在 src/plugins/logger.js 中，来看一下这个插件到底做了哪些事情。\n\n```js\n// Credits: borrowed code from fcomb/redux-logger\n\nimport { deepCopy } from '../util'\n\nexport default function createLogger ({\n  collapsed = true,\n  transformer = state => state,\n  mutationTransformer = mut => mut\n} = {}) {\n  return store => {\n    let prevState = deepCopy(store.state)\n\n    store.subscribe((mutation, state) => {\n      if (typeof console === 'undefined') {\n        return\n      }\n      const nextState = deepCopy(state)\n      const time = new Date()\n      const formattedTime = ` @ ${pad(time.getHours(), 2)}:${pad(time.getMinutes(), 2)}:${pad(time.getSeconds(), 2)}.${pad(time.getMilliseconds(), 3)}`\n      const formattedMutation = mutationTransformer(mutation)\n      const message = `mutation ${mutation.type}${formattedTime}`\n      const startMessage = collapsed\n        ? console.groupCollapsed\n        : console.group\n\n      // render\n      try {\n        startMessage.call(console, message)\n      } catch (e) {\n        console.log(message)\n      }\n\n      console.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState))\n      console.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation)\n      console.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState))\n\n      try {\n        console.groupEnd()\n      } catch (e) {\n        console.log('—— log end ——')\n      }\n\n      prevState = nextState\n    })\n  }\n}\n\nfunction repeat (str, times) {\n  return (new Array(times + 1)).join(str)\n}\n\nfunction pad (num, maxLength) {\n  return repeat('0', maxLength - num.toString().length) + num\n}\n```\n\n插件对外暴露的是 createLogger 方法，它实际上接受 3 个参数，它们都有默认值，通常我们用默认值就可以。createLogger 的返回的是一个函数，当我执行 logger 插件的时候，实际上执行的是这个函数，下面来看一下这个函数做了哪些事情。\n\n函数首先执行了 let prevState = deepCopy(store.state) 深拷贝当前 store 的 rootState。这里为什么要深拷贝，因为如果是单纯的引用，那么 store.state 的任何变化都会影响这个引用，这样就无法记录上一个状态了。我们来了解一下 deepCopy 的实现，在 src/util.js 里定义：\n\n```js\nfunction find (list, f) {\n  return list.filter(f)[0]\n}\n\nexport function deepCopy (obj, cache = []) {\n  // just return if obj is immutable value\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  // if obj is hit, it is in circular structure\n  const hit = find(cache, c => c.original === obj)\n  if (hit) {\n    return hit.copy\n  }\n\n  const copy = Array.isArray(obj) ? [] : {}\n  // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n  cache.push({\n    original: obj,\n    copy\n  })\n\n  Object.keys(obj).forEach(key => {\n    copy[key] = deepCopy(obj[key], cache)\n  })\n\n  return copy\n}\n```\n\ndeepCopy 并不陌生，很多开源库如 loadash、jQuery 都有类似的实现，原理也不难理解，主要是构造一个新的对象，遍历原对象或者数组，递归调用 deepCopy。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过`find(cache, c => c.original === obj)`发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。\n\n回到 loggerPlugin 函数，通过 deepCopy 拷贝了当前 state 的副本并用 prevState 变量保存，接下来调用 store.subscribe 方法订阅 store 的 state 的变。 在回调函数中，也是先通过 deepCopy 方法拿到当前的 state 的副本，并用 nextState 变量保存。接下来获取当前格式化时间已经格式化的 mutation 变化的字符串，然后利用 console.group 以及 console.log 分组输出 prevState、mutation以及 nextState，这里可以通过我们 createLogger 的参数 collapsed、transformer 以及 mutationTransformer 来控制我们最终 log 的显示效果。在函数的最后，我们把 nextState 赋值给 prevState，便于下一次 mutation。","source":"_posts/2018-07-26-Vuex源码分析.markdown","raw":"---\nlayout:     post\ntitle:      \"[转]Vuex 2.0 源码分析\"\ndate:       2018-07-26\nauthor:     \"Vincent\"\ncatalog:    true\ntags:\n    - 前端开发\n    - vue\n---\n\n> 原文：[Vuex 2.0 源码分析](https://github.com/DDFE/DDFE-blog/issues/8)\n\n## 目录结构\n\nVuex 的源码托管在 github，我们首先通过 git 把代码 clone 到本地，选一款适合自己的 IDE 打开源码，展开 src 目录，如下图所示：\n\n![](https://camo.githubusercontent.com/4c0c82eb95a6d128f80355522e266fe5220ca863/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565785f7372632e706e67)\n\nsrc 目录下的文件并不多，包含几个 js 文件和 plugins 目录， plugins 目录里面包含 2 个 Vuex 的内置插件，整个源码加起来不过 500-600 行，可谓非常轻巧的一个库。\n\n麻雀虽小，五脏俱全，我们先直观的感受一下源码的结构，接下来看一下其中的实现细节。\n\n## 源码分析\n\n本文的源码分析过程不会是自上而下的给代码加注释，我更倾向于是从 Vuex 提供的 API 和我们的使用方法等维度去分析。Vuex 的源码是基于 es6 的语法编写的，对于不了解 es6 的同学，建议还是先学习一下 es6。\n\n### 从入口开始\n\n看源码一般是从入口开始，Vuex 源码的入口是 src/index.js，先来打开这个文件。\n\n我们首先看这个库的 export ，在 index.js 代码最后。\n\n```js\nexport default {\n  Store,\n  install,\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions\n}\n```\n\n这里可以一目了然地看到 Vuex 对外暴露的 API。其中, Store 是 Vuex 提供的状态存储类，通常我们使用 Vuex 就是通过创建 Store 的实例，稍后我们会详细介绍。接着是 install 方法，这个方法通常是我们编写第三方 Vue 插件的“套路”，先来看一下“套路”代码：\n\n```js\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n```\n\n我们实现了一个 install 方法，这个方法当我们全局引用 Vue ，也就是 window 上有 Vue 对象的时候，会手动调用 install 方法，并传入 Vue 的引用；当 Vue 通过 npm 安装到项目中的时候，我们在代码中引入第三方 Vue 插件通常会编写如下代码：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n...\nVue.use(Vuex)\n```\n\n当我们执行 Vue.use(Vuex) 这句代码的时候，实际上就是调用了 install 的方法并传入 Vue 的引用。install 方法顾名思义，现在让我们来看看它的实现。它接受了一个参数 _Vue，函数体首先判断 Vue ，这个变量的定义在 index.js 文件的开头部分：\n\n```js\nlet Vue // bind on install\n```\n\n对 Vue 的判断主要是保证 install 方法只执行一次，这里把 install 方法的参数 _Vue 对象赋值给 Vue 变量，这样我们就可以在 index.js 文件的其它地方使用 Vue 这个变量了。install 方法的最后调用了 applyMixin 方法，我们顺便来看一下这个方法的实现，在 src/mixin.js 文件里定义：\n\n```js\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n```\n\n这段代码的作用就是在 Vue 的生命周期中的初始化（1.0 版本是 init，2.0 版本是 beforeCreated）钩子前插入一段 Vuex 初始化代码。这里做的事情很简单——给 Vue 的实例注入一个 `$store` 的属性，这也就是为什么我们在 Vue 的组件中可以通过 `this.$store.xxx` 访问到 Vuex 的各种数据和状态。\n\n### 认识 Store 构造函数\n\n我们在使用 Vuex 的时候，通常会实例化 Store 类，然后传入一个对象，包括我们定义好的 actions、getters、mutations、state等，甚至当我们有多个子模块的时候，我们可以添加一个 modules 对象。那么实例化的时候，到底做了哪些事情呢？带着这个疑问，让我们回到 index.js 文件，重点看一下 Store 类的定义。Store 类定义的代码略长，我不会一下就贴上所有代码，我们来拆解分析它，首先看一下构造函数的实现：\n\n```js\nclass Store {\n  constructor (options = {}) {\n    assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n    assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n\n    const {\n      state = {},\n      plugins = [],\n      strict = false\n    } = options\n\n    // store internal state\n    this._options = options\n    this._committing = false\n    this._actions = Object.create(null)\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    this._runtimeModules = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // bind commit and dispatch to self\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // strict mode\n    this.strict = strict\n\n    // init root module.\n    // this also recursively registers all sub-modules\n    // and collects all module getters inside this._wrappedGetters\n    installModule(this, state, [], options)\n\n    // initialize the store vm, which is responsible for the reactivity\n    // (also registers _wrappedGetters as computed properties)\n    resetStoreVM(this, state)\n\n    // apply plugins\n    plugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n  }\n  ...\n}\n```\n\n构造函数的一开始就用了“断言函数”，来判断是否满足一些条件。\n\n```js\nassert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n```\n\n这行代码的目的是确保 Vue 的存在，也就是在我们实例化 Store 之前，必须要保证之前的 install 方法已经执行了。\n\n```js\nassert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n```\n\n这行代码的目的是为了确保 Promsie 可以使用的，因为 Vuex 的源码是依赖 Promise 的。Promise 是 es6 提供新的 API，由于现在的浏览器并不是都支持 es6 语法的，所以通常我们会用 babel 编译我们的代码，如果想使用 Promise 这个 特性，我们需要在 package.json 中添加对 babel-polyfill 的依赖并在代码的入口加上 import 'babel-polyfill' 这段代码。\n\n再来看看 assert 这个函数，它并不是浏览器原生支持的，它的实现在 src/util.js 里，代码如下：\n\n```js\nexport function assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n```\n\n非常简单，对 condition 判断，如果不不为真，则抛出异常。这个函数虽然简单，但这种编程方式值得我们学习。\n\n再来看构造函数接下来的代码：\n\n```js\nconst {\n  state = {},\n  plugins = [],\n  strict = false\n} = options\n```\n\n这里就是利用 es6 的解构赋值拿到 options 里的 state，plugins 和 strict。state 表示 rootState，plugins 表示应用的插件、strict 表示是否开启严格模式。\n\n接着往下看：\n\n```js\n// store internal state\nthis._options = options\nthis._committing = false\nthis._actions = Object.create(null)\nthis._mutations = Object.create(null)\nthis._wrappedGetters = Object.create(null)\nthis._runtimeModules = Object.create(null)\nthis._subscribers = []\nthis._watcherVM = new Vue()\n```\n\n这里主要是创建一些内部的属性：\nthis._options 存储参数 options。\nthis._committing 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state。\nthis._actions 用来存储用户定义的所有的 actions。\nthis._mutations 用来存储用户定义所有的 mutatins。\nthis._wrappedGetters 用来存储用户定义的所有 getters 。\nthis._runtimeModules 用来存储所有的运行时的 modules。\nthis._subscribers 用来存储所有对 mutation 变化的订阅者。\nthis._watcherVM 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化的。\n\n继续往下看：\n\n```js\n// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}\n\n// strict mode\nthis.strict = strict\n```\n\n这里的代码也不难理解，把 Store 类的 dispatch 和 commit 的方法的 this 指针指向当前 store 的实例上，dispatch 和 commit 的实现我们稍后会分析。this.strict 表示是否开启严格模式，在严格模式下会观测所有的 state 的变化，建议在开发环境时开启严格模式，线上环境要关闭严格模式，否则会有一定的性能开销。\n\n### Vuex 的初始化核心\n\n#### installModule\n\n我们接着往下看：\n\n```js\n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], options)\n\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)\n\n// apply plugins\nplugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n```\n\n这段代码是 Vuex 的初始化的核心，其中，installModule 方法是把我们通过 options 传入的各种属性模块注册和安装；resetStoreVM 方法是初始化 store._vm，观测 state 和 getters 的变化；最后是应用传入的插件。\n\n下面，我们先来看一下 installModule 的实现：\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const {\n    state,\n    actions,\n    mutations,\n    getters,\n    modules\n  } = module\n\n  // set state\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, state || {})\n    })\n  }\n\n  if (mutations) {\n    Object.keys(mutations).forEach(key => {\n      registerMutation(store, key, mutations[key], path)\n    })\n  }\n\n  if (actions) {\n    Object.keys(actions).forEach(key => {\n      registerAction(store, key, actions[key], path)\n    })\n  }\n\n  if (getters) {\n    wrapGetters(store, getters, path)\n  }\n\n  if (modules) {\n    Object.keys(modules).forEach(key => {\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n    })\n  }\n}\n```\n\ninstallModule 函数可接收5个参数，store、rootState、path、module、hot，store 表示当前 Store 实例，rootState 表示根 state，path 表示当前嵌套模块的路径数组，module 表示当前安装的模块，hot 当动态改变 modules 或者热更新的时候为 true。\n\n先来看这部分代码：\n\n```js\nconst isRoot = !path.length\nconst {\n  state,\n  actions,\n  mutations,\n  getters,\n  modules\n} = module\n```\n\n代码首先通过 path 数组的长度判断是否为根。我们在构造函数调用的时候是 installModule(this, state, [], options)，所以这里 isRoot 为 true。module 为传入的 options，我们拿到了 module 下的 state、actions、mutations、getters 以及嵌套的 modules。\n\n接着看下面的代码：\n\n```js\n// set state\nif (!isRoot && !hot) {\n  const parentState = getNestedState(rootState, path.slice(0, -1))\n  const moduleName = path[path.length - 1]\n  store._withCommit(() => {\n    Vue.set(parentState, moduleName, state || {})\n  })\n}\n```\n\n这里判断当不为根且非热更新的情况，然后设置级联状态，这里乍一看不好理解，我们先放一放，稍后来回顾。\n\n再往下看代码：\n\n```js\nif (mutations) {\n  Object.keys(mutations).forEach(key => {\n    registerMutation(store, key, mutations[key], path)\n  })\n}\n\nif (actions) {\n  Object.keys(actions).forEach(key => {\n    registerAction(store, key, actions[key], path)\n  })\n}\n\nif (getters) {\n  wrapGetters(store, getters, path)\n}\n```\n\n这里分别是对 mutations、actions、getters 进行注册，如果我们实例化 Store 的时候通过 options 传入这些对象，那么会分别进行注册，我稍后再去介绍注册的具体实现。那么到这，如果 Vuex 没有 module ，这个 installModule 方法可以说已经做完了。但是 Vuex 巧妙了设计了 module 这个概念，因为 Vuex 本身是单一状态树，应用的所有状态都包含在一个大对象内，随着我们应用规模的不断增长，这个 Store 变得非常臃肿。为了解决这个问题，Vuex 允许我们把 store 分 module（模块）。每一个模块包含各自的 state、mutations、actions 和 getters，甚至是嵌套模块。所以，接下来还有一行代码：\n\n```js\nif (modules) {\n  Object.keys(modules).forEach(key => {\n    installModule(store, rootState, path.concat(key), modules[key], hot)\n  })\n}\n```\n\n这里通过遍历 modules，递归调用 installModule 去安装子模块。这里传入了 store、rootState、path.concat(key)、和 modules[key]，和刚才不同的是，path 不为空，module 对应为子模块，那么我们回到刚才那段代码：\n\n```js\n// set state\nif (!isRoot && !hot) {\n  const parentState = getNestedState(rootState, path.slice(0, -1))\n  const moduleName = path[path.length - 1]\n  store._withCommit(() => {\n    Vue.set(parentState, moduleName, state || {})\n  })\n}\n```\n\n当递归初始化子模块的时候，isRoot 为 false，注意这里有个方法getNestedState(rootState, path)，来看一下 getNestedState 函数的定义：\n\n```js\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) => state[key], state)\n    : state\n}\n```\n\n这个方法很简单，就是根据 path 查找 state 上的嵌套 state。在这里就是传入 rootState 和 path，计算出当前模块的父模块的 state，由于模块的 path 是根据模块的名称 concat 连接的，所以 path 的最后一个元素就是当前模块的模块名，最后调用\n\n```js\nstore._withCommit(() => {\n  Vue.set(parentState, moduleName, state || {})\n})\n```\n\n把当前模块的 state 添加到 parentState 中。\n这里注意一下我们用了 store._withCommit 方法，来看一下这个方法的定义：\n\n```js\n_withCommit (fn) {\n  const committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n}\n```\n\n由于我们是在修改 state，Vuex 中所有对 state 的修改都会用 _withCommit函数包装，保证在同步修改 state 的过程中 this._committing 的值始终为true。这样当我们观测 state 的变化时，如果 this._committing 的值不为 true，则能检查到这个状态修改是有问题的。\n\n看到这里，有些同学可能会有点困惑，举个例子来直观感受一下，以 Vuex 源码中的 example/shopping-cart 为例，打开 store/index.js，有这么一段代码：\n\n```js\nexport default new Vuex.Store({\n  actions,\n  getters,\n  modules: {\n    cart,\n    products\n  },\n  strict: debug,\n  plugins: debug ? [createLogger()] : []\n})\n```\n\n这里有两个子 module，cart 和 products，我们打开 store/modules/cart.js，看一下 cart 模块中的 state 定义，代码如下：\n\n```js\nconst state = {\n  added: [],\n  checkoutStatus: null\n}\n```\n\n我们运行这个项目，打开浏览器，利用 Vue 的调试工具来看一下 Vuex 中的状态，如下图所示：\n\n![](https://camo.githubusercontent.com/2bd2ed9ea9f74792db15c5980666275330ab64a2/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565782d746573742e706e67)\n\n可以看到，在 rootState 下，分别有 cart 和 products 2个属性，key 根据模块名称而来，value 就是在每个模块文件中定义的 state，这就把模块 state 挂载到 rootState 上了。\n\n我们了解完嵌套模块 state 是怎么一回事后，我们回过头来看一下 installModule 过程中的其它 3 个重要方法：registerMutation、registerAction 和 wrapGetters。顾名思义，这 3 个方法分别处理 mutations、actions 和 getters。我们先来看一下 registerMutation 的定义：\n\n#### registerMutation\n\n```js\nfunction registerMutation (store, type, handler, path = []) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler(getNestedState(store.state, path), payload)\n  })\n}\n```\n\nregisterMutation 是对 store 的 mutation 的初始化，它接受 4 个参数，store为当前 Store 实例，type为 mutation 的 key，handler 为 mutation 执行的回调函数，path 为当前模块的路径。mutation 的作用就是同步修改当前模块的 state ，函数首先通过 type 拿到对应的 mutation 对象数组， 然后把一个 mutation 的包装函数 push 到这个数组中，这个函数接收一个参数 payload，这个就是我们在定义 mutation 的时候接收的额外参数。这个函数执行的时候会调用 mutation 的回调函数，并通过 getNestedState(store.state, path) 方法得到当前模块的 state，和 playload 一起作为回调函数的参数。举个例子：\n\n```js\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n```\n\n这里我们定义了一个 mutation，通过刚才的 registerMutation 方法，我们注册了这个 mutation，这里的 state 对应的就是当前模块的 state，n 就是额外参数 payload，接下来我们会从源码分析的角度来介绍这个 mutation 的回调是何时被调用的，参数是如何传递的。\n\n我们有必要知道 mutation 的回调函数的调用时机，在 Vuex 中，mutation 的调用是通过 store 实例的 API 接口 commit 来调用的，来看一下 commit 函数的定义：\n\n```js\ncommit (type, payload, options) {\n  // check object-style commit\n  if (isObject(type) && type.type) {\n    options = payload\n    payload = type\n    type = type.type\n  }\n  const mutation = { type, payload }\n  const entry = this._mutations[type]\n  if (!entry) {\n    console.error(`[vuex] unknown mutation type: ${type}`)\n    return\n  }\n  this._withCommit(() => {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n  if (!options || !options.silent) {\n    this._subscribers.forEach(sub => sub(mutation, this.state))\n  }\n}\n```\n\ncommit 支持 3 个参数，type 表示 mutation 的类型，payload 表示额外的参数，options 表示一些配置，比如 silent 等，稍后会用到。commit 函数首先对 type 的类型做了判断，处理了 type 为 object 的情况，接着根据 type 去查找对应的 mutation，如果找不到，则输出一条错误信息，否则遍历这个 type 对应的 mutation 对象数组，执行 handler(payload) 方法，这个方法就是之前定义的 wrappedMutationHandler(handler)，执行它就相当于执行了 registerMutation 注册的回调函数，并把当前模块的 state 和 额外参数 payload 作为参数传入。注意这里我们依然使用了 this._withCommit 的方法提交 mutation。commit 函数的最后，判断如果不是静默模式，则遍历 this._subscribers，调用回调函数，并把 mutation 和当前的根 state 作为参数传入。那么这个 this._subscribers 是什么呢？原来 Vuex 的 Store 实例提供了 subscribe API 接口，它的作用是订阅（注册监听） store 的 mutation。先来看一下它的实现：\n\n```js\nsubscribe (fn) {\n  const subs = this._subscribers\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn)\n  }\n  return () => {\n    const i = subs.indexOf(fn)\n    if (i > -1) {\n      subs.splice(i, 1)\n    }\n  }\n}\n```\n\nsubscribe 方法很简单，他接受的参数是一个回调函数，会把这个回调函数保存到 this._subscribers 上，并返回一个函数，当我们调用这个返回的函数，就可以解除当前函数对 store 的 mutation 的监听。其实，Vuex 的内置 logger 插件就是基于 subscribe 接口实现对 store 的 muation的监听，稍后我们会详细介绍这个插件。\n\n#### registerAction\n\n在了解完 registerMutation，我们再来看一下 registerAction 的定义：\n\n```js\nfunction registerAction (store, type, handler, path = []) {\nconst entry = store._actions[type] || (store._actions[type] = [])\n  const { dispatch, commit } = store\n  entry.push(function wrappedActionHandler (payload, cb) {\n    let res = handler({\n      dispatch,\n      commit,\n      getters: store.getters,\n      state: getNestedState(store.state, path),\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n```\n\nregisterAction 是对 store 的 action 的初始化，它和 registerMutation 的参数一致，和 mutation 不同一点，mutation 是同步修改当前模块的 state，而 action 是可以异步去修改 state，这里不要误会，在 action 的回调中并不会直接修改 state ，仍然是通过提交一个 mutation 去修改 state（在 Vuex 中，mutation 是修改 state 的唯一途径）。那我们就来看看 action 是如何做到这一点的。\n\n函数首先也是通过 type 拿到对应 action 的对象数组，然后把一个 action 的包装函数 push 到这个数组中，这个函数接收 2 个参数，payload 表示额外参数 ，cb 表示回调函数（实际上我们并没有使用它）。这个函数执行的时候会调用 action 的回调函数，传入一个 context 对象，这个对象包括了 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState 等等。接着对这个函数的返回值做判断，如果不是一个 Promise 对象，则调用 Promise.resolve（res） 给res 包装成了一个 Promise 对象。这里也就解释了为何 Vuex 的源码依赖 Promise，这里对 Promise 的判断也和简单，参考代码 src/util.js，对 isPromise 的判断如下：\n\n```js\nexport function isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n```\n\n其实就是简单的检查对象的 then 方法，如果包含说明就是一个 Promise 对象。\n\n接着判断 store._devtoolHook，这个只有当用到 Vuex devtools 开启的时候，我们才能捕获 promise 的过程中的 。 action 的包装函数最后返回 res ，它就是一个地地道道的 Promise 对象。来看个例子：\n\n```js\nactions: {\n  checkout ({ commit, state }, payload) {\n    // 把当前购物车的商品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发送结帐请求，并愉快地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接收一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n\n这里我们定义了一个 action，通过刚才的 registerAction 方法，我们注册了这个 action，这里的 commit 就是 store 的 API 接口，可以通过它在 action 里提交一个 mutation。state 对应的就是当前模块的 state，我们在这个 action 里即可以同步提交 mutation，也可以异步提交。接下来我们会从源码分析的角度来介绍这个 action 的回调是何时被调用的，参数是如何传递的。\n\n我们有必要知道 action 的回调函数的调用时机，在 Vuex 中，action 的调用是通过 store 实例的 API 接口 dispatch 来调用的，来看一下 dispatch 函数的定义：\n\n```js\ndispatch (type, payload) {\n// check object-style dispatch\n  if (isObject(type) && type.type) {\n    payload = type\n    type = type.type\n  }\n  const entry = this._actions[type]\n  if (!entry) {\n    console.error(`[vuex] unknown action type: ${type}`)\n    return\n  }\n  return entry.length > 1\n    ? Promise.all(entry.map(handler => handler(payload)))\n    : entry[0](payload)\n}\n```\n\ndispatch 支持2个参数，type 表示 action 的类型，payload 表示额外的参数。前面几行代码和 commit 接口非常类似，都是找到对应 type 下的 action 对象数组，唯一和 commit 不同的地方是最后部分，它对 action 的对象数组长度做判断，如果长度为 1 则直接调用`entry[0](payload)`， 这个方法就是之前定义的 wrappedActionHandler(payload, cb)，执行它就相当于执行了 registerAction 注册的回调函数，并把当前模块的 context 和 额外参数 payload 作为参数传入。所以我们在 action 的回调函数里，可以拿到当前模块的上下文包括 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState，可见 action 是非常灵活的。\n\n#### wrapGetters\n\n了解完 registerAction 后，我们来看看 wrapGetters的定义：\n\n```js\nfunction wrapGetters (store, moduleGetters, modulePath) {\n  Object.keys(moduleGetters).forEach(getterKey => {\n    const rawGetter = moduleGetters[getterKey]\n    if (store._wrappedGetters[getterKey]) {\n      console.error(`[vuex] duplicate getter key: ${getterKey}`)\n      return\n    }\n    store._wrappedGetters[getterKey] = function wrappedGetter (store) {\n      return rawGetter(\n        getNestedState(store.state, modulePath), // local state\n        store.getters, // getters\n        store.state // root state\n      )\n    }\n  })\n}\n```\n\nwrapGetters 是对 store 的 getters 初始化，它接受 3个 参数， store 表示当前 Store 实例，moduleGetters 表示当前模块下的所有 getters, modulePath 对应模块的路径。细心的同学会发现，和刚才的 registerMutation 以及 registerAction 不同，这里对 getters 的循环遍历是放在了函数体内，并且 getters 和它们的一个区别是不允许 getter 的 key 有重复。\n\n这个函数做的事情就是遍历 moduleGetters，把每一个 getter 包装成一个方法，添加到 store._wrappedGetters 对象中，注意 getter 的 key 是不允许重复的。在这个包装的方法里，会执行 getter 的回调函数，并把当前模块的 state，store 的 getters 和 store 的 rootState 作为它参数。来看一个例子：\n\n```js\nexport const cartProducts = state => {\n  return state.cart.added.map(({ id, quantity }) => {\n    const product = state.products.all.find(p => p.id === id)\n    return {\n      title: product.title,\n      price: product.price,\n      quantity\n    }\n  })\n}\n```\n\n这里我们定义了一个 getter，通过刚才的 wrapGetters 方法，我们把这个 getter 添加到 store._wrappedGetters 对象里，这和回调函数的参数 state 对应的就是当前模块的 state，接下来我们从源码的角度分析这个函数是如何被调用，参数是如何传递的。\n\n我们有必要知道 getter 的回调函数的调用时机，在 Vuex 中，我们知道当我们在组件中通过 `this.$store.getters.xxxgetters` 可以访问到对应的 getter 的回调函数，那么我们需要把对应 getter 的包装函数的执行结果绑定到 `this.$store` 上。这部分的逻辑就在 resetStoreVM 函数里。我们在 Store 的构造函数中，在执行完 installModule 方法后，就会执行 resetStoreVM 方法。来看一下它的定义：\n\n#### resetStoreVM\n\n```js\nfunction resetStoreVM (store, state) {\n  const oldVm = store._vm\n\n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  Object.keys(wrappedGetters).forEach(key => {\n    const fn = wrappedGetters[key]\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key]\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: { state },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(() => {\n      oldVm.state = null\n    })\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n```\n\n这个方法主要是重置一个私有的 _vm 对象，它是一个 Vue 的实例。这个 _vm 对象会保留我们的 state 树，以及用计算属性的方式存储了 store 的 getters。来具体看看它的实现过程。我们把这个函数拆成几个部分来分析：\n\n```js\nconst oldVm = store._vm\n\n// bind store public getters\nstore.getters = {}\nconst wrappedGetters = store._wrappedGetters\nconst computed = {}\nObject.keys(wrappedGetters).forEach(key => {\n  const fn = wrappedGetters[key]\n  // use computed to leverage its lazy-caching mechanism\n  computed[key] = () => fn(store)\n  Object.defineProperty(store.getters, key, {\n    get: () => store._vm[key]\n  })\n})\n```\n\n这部分留了现有的 store._vm 对象，接着遍历 store._wrappedGetters 对象，在遍历过程中，依次拿到每个 getter 的包装函数，并把这个包装函数执行的结果用 computed 临时变量保存。接着用 es5 的 Object.defineProperty 方法为 store.getters 定义了 get 方法，也就是当我们在组件中调用`this.$store.getters.xxxgetters`这个方法的时候，会访问 store._vm[xxxgetters]。我们接着往下看：\n\n```js\n// use a Vue instance to store the state tree\n// suppress warnings just in case the user has added\n// some funky global mixins\nconst silent = Vue.config.silent\nVue.config.silent = true\nstore._vm = new Vue({\n  data: { state },\n  computed\n})\nVue.config.silent = silent\n\n// enable strict mode for new vm\nif (store.strict) {\n  enableStrictMode(store)\n}\n```\n\n这部分的代码首先先拿全局 Vue.config.silent 的配置，然后临时把这个配置设成 true，接着实例化一个 Vue 的实例，把 store 的状态树 state 作为 data 传入，把我们刚才的临时变量 computed 作为计算属性传入。然后再把之前的 silent 配置重置。设置 silent 为 true 的目的是为了取消这个 _vm 的所有日志和警告。把 computed 对象作为 _vm 的 computed 属性，这样就完成了 getters 的注册。因为当我们在组件中访问 this.$store.getters.xxxgetters 的时候，就相当于访问 store._vm[xxxgetters]，也就是在访问 computed[xxxgetters]，这样就访问到了 xxxgetters 对应的回调函数了。这段代码最后判断 strict 属性决定是否开启严格模式，我们来看看严格模式都干了什么：\n\n```js\nfunction enableStrictMode (store) {\n  store._vm.$watch('state', () => {\n    assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n  }, { deep: true, sync: true })\n}\n```\n\n严格模式做的事情很简单，监测 store._vm.state 的变化，看看 state 的变化是否通过执行 mutation 的回调函数改变，如果是外部直接修改 state，那么 store._committing 的值为 false，这样就抛出一条错误。再次强调一下，Vuex 中对 state 的修改只能在 mutation 的回调函数里。\n\n回到 resetStoreVM 函数，我们来看一下最后一部分：\n\n```js\nif (oldVm) {\n  // dispatch changes in all subscribed watchers\n  // to force getter re-evaluation.\n  store._withCommit(() => {\n    oldVm.state = null\n  })\n  Vue.nextTick(() => oldVm.$destroy())\n}\n```\n\n这里的逻辑很简单，由于这个函数每次都会创建新的 Vue 实例并赋值到 store._vm 上，那么旧的 _vm 对象的状态设置为 null，并调用 $destroy 方法销毁这个旧的 _vm 对象。\n\n那么到这里，Vuex 的初始化基本告一段落了，初始化核心就是 installModule 和 resetStoreVM 函数。通过对 mutations 、actions 和 getters 的注册，我们了解到 state 的是按模块划分的，按模块的嵌套形成一颗状态树。而 actions、mutations 和 getters 的全局的，其中 actions 和 mutations 的 key 允许重复，但 getters 的 key 是不允许重复的。官方推荐我们给这些全局的对象在定义的时候加一个名称空间来避免命名冲突。\n从源码的角度介绍完 Vuex 的初始化的玩法，我们再从 Vuex 提供的 API 方向来分析其中的源码，看看这些 API 是如何实现的。\n\n### Vuex API 分析\n\nVuex 常见的 API 如 dispatch、commit 、subscribe 我们前面已经介绍过了，这里就不再赘述了，下面介绍的一些 Store 的 API，虽然不常用，但是了解一下也不错。\n\n#### watch(getter, cb, options)\n\nwatch 作用是响应式的监测一个 getter 方法的返回值，当值改变时调用回调。getter 接收 store 的 state 作为唯一参数。来看一下它的实现：\n\n```js\nwatch (getter, cb, options) {\n  assert(typeof getter === 'function', `store.watch only accepts a function.`)\n  return this._watcherVM.$watch(() => getter(this.state), cb, options)\n}\n```\n\n函数首先断言 watch 的 getter 必须是一个方法，接着利用了内部一个 Vue 的实例对象 `this._watcherVM` 的 $watch 方法，观测 getter 方法返回值的变化，如果有变化则调用 cb 函数，回调函数的参数为新值和旧值。watch 方法返回的是一个方法，调用它则取消观测。\n\n#### registerModule(path, module)\n\nregisterModule 的作用是注册一个动态模块，有的时候当我们异步加载一些业务的时候，可以通过这个 API 接口去动态注册模块，来看一下它的实现：\n\n```js\nregisterModule (path, module) {\n  if (typeof path === 'string') path = [path]\n  assert(Array.isArray(path), `module path must be a string or an Array.`)\n  this._runtimeModules[path.join('.')] = module\n  installModule(this, this.state, path, module)\n  // reset store to update getters...\n  resetStoreVM(this, this.state)\n}\n```\n\n函数首先对 path 判断，如果 path 是一个 string 则把 path 转换成一个 Array。接着把 module 对象缓存到 this._runtimeModules 这个对象里，path 用点连接作为该对象的 key。接着和初始化 Store 的逻辑一样，调用 installModule 和 resetStoreVm 方法安装一遍动态注入的 module。\n\n#### unregisterModule(path)\n\n和 registerModule 方法相对的就是 unregisterModule 方法，它的作用是注销一个动态模块，来看一下它的实现：\n\n```js\nunregisterModule (path) {\n  if (typeof path === 'string') path = [path]\n  assert(Array.isArray(path), `module path must be a string or an Array.`)\n  delete this._runtimeModules[path.join('.')]\n  this._withCommit(() => {\n    const parentState = getNestedState(this.state, path.slice(0, -1))\n    Vue.delete(parentState, path[path.length - 1])\n  })\n  resetStore(this)\n}\n```\n\n函数首先还是对 path 的类型做了判断，这部分逻辑和注册是一样的。接着从 this._runtimeModules 里删掉以 path 点连接的 key 对应的模块。接着通过 this._withCommit 方法把当前模块的 state 对象从父 state 上删除。最后调用 resetStore(this) 方法，来看一下这个方法的定义：\n\n```js\nfunction resetStore (store) {\n  store._actions = Object.create(null)\n  store._mutations = Object.create(null)\n  store._wrappedGetters = Object.create(null)\n  const state = store.state\n  // init root module\n  installModule(store, state, [], store._options, true)\n  // init all runtime modules\n  Object.keys(store._runtimeModules).forEach(key => {\n    installModule(store, state, key.split('.'), store._runtimeModules[key], true)\n  })\n  // reset vm\n  resetStoreVM(store, state)\n}\n```\n\n这个方法作用就是重置 store 对象，重置 store 的 _actions、_mutations、_wrappedGetters 等等属性。然后再次调用 installModules 去重新安装一遍 Module 对应的这些属性，注意这里我们的最后一个参数 hot 为true，表示它是一次热更新。这样在 installModule 这个方法体类，如下这段逻辑就不会执行\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  ... \n  // set state\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, state || {})\n    })\n  }\n  ...\n}\n```\n\n由于 hot 始终为 true，这里我们就不会重新对状态树做设置，我们的 state 保持不变。因为我们已经明确的删除了对应 path 下的 state 了，要做的事情只不过就是重新注册一遍 muations、actions 以及 getters。\n\n回调 resetStore 方法，接下来遍历 this._runtimeModules 模块，重新安装所有剩余的 runtime Moudles。最后还是调用 resetStoreVM 方法去重置 Store 的 _vm 对象。\n\n#### hotUpdate(newOptions)\n\nhotUpdate 的作用是热加载新的 action 和 mutation。 来看一下它的实现：\n\n```js\nhotUpdate (newOptions) {\n  updateModule(this._options, newOptions)\n  resetStore(this)\n}\n```\n\n函数首先调用 updateModule 方法去更新状态，其中当前 Store 的 opition 配置和要更新的 newOptions 会作为参数。来看一下这个函数的实现：\n\n```js\nfunction updateModule (targetModule, newModule) {\n  if (newModule.actions) {\n    targetModule.actions = newModule.actions\n  }\n  if (newModule.mutations) {\n    targetModule.mutations = newModule.mutations\n  }\n  if (newModule.getters) {\n    targetModule.getters = newModule.getters\n  }\n  if (newModule.modules) {\n    for (const key in newModule.modules) {\n      if (!(targetModule.modules && targetModule.modules[key])) {\n        console.warn(\n          `[vuex] trying to add a new module '${key}' on hot reloading, ` +\n          'manual reload is needed'\n        )\n        return\n      }\n      updateModule(targetModule.modules[key], newModule.modules[key])\n    }\n  }\n}\n```\n\n首先我们对 newOptions 对象的 actions、mutations 以及 getters 做了判断，如果有这些属性的话则替换 targetModule（当前 Store 的 options）对应的属性。最后判断如果 newOptions 包含 modules 这个 key，则遍历这个 modules 对象，如果 modules 对应的 key 不在之前的 modules 中，则报一条警告，因为这是添加一个新的 module ，需要手动重新加载。如果 key 在之前的 modules，则递归调用 updateModule，热更新子模块。\n\n调用完 updateModule 后，回到 hotUpdate 函数，接着调用 resetStore 方法重新设置 store，刚刚我们已经介绍过了。\n\n#### replaceState\n\nreplaceState的作用是替换整个 rootState，一般在用于调试，来看一下它的实现：\n\n```js\nreplaceState (state) {\n  this._withCommit(() => {\n    this._vm.state = state\n  })\n}\n```\n\n函数非常简单，就是调用 this._withCommit 方法修改 Store 的 rootState，之所以提供这个 API 是由于在我们是不能在 muations 的回调函数外部去改变 state。\n\n到此为止，API 部分介绍完了，其实整个 Vuex 源码下的 src/index.js 文件里的代码基本都过了一遍。\n\n### 辅助函数\n\nVuex 除了提供我们 Store 对象外，还对外提供了一系列的辅助函数，方便我们在代码中使用 Vuex，提供了操作 store 的各种属性的一系列语法糖，下面我们来一起看一下：\n\n#### mapState\n\nmapState 工具函数会将 store 中的 state 映射到局部计算属性中。为了更好理解它的实现，先来看一下它的使用示例：\n\n```js\n// vuex 提供了独立的构建工具函数 Vuex.mapState\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可以让代码非常简洁\n    count: state => state.count,\n    // 传入字符串 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n    // 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n当计算属性名称和状态子树名称对应相同时，我们可以向 mapState 工具函数传入一个字符串数组。\n\n```js\ncomputed: mapState([\n  // 映射 this.count 到 this.$store.state.count\n  'count'\n])\n```\n\n通过例子我们可以直观的看到，mapState 函数可以接受一个对象，也可以接收一个数组，那它底层到底干了什么事呢，我们一起来看一下源码这个函数的定义：\n\n```js\nexport function mapState (states) {\n  const res = {}\n  normalizeMap(states).forEach(({ key, val }) => {\n    res[key] = function mappedState () {\n      return typeof val === 'function'\n        ? val.call(this, this.$store.state, this.$store.getters)\n        : this.$store.state[val]\n    }\n  })\n  return res\n}\n```\n\n函数首先对传入的参数调用 normalizeMap 方法，我们来看一下这个函数的定义：\n\n```js\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(key => ({ key, val: key }))\n    : Object.keys(map).map(key => ({ key, val: map[key] }))\n}\n```\n\n这个方法判断参数 map 是否为数组，如果是数组，则调用数组的 map 方法，把数组的每个元素转换成一个 {key, val: key}的对象；否则传入的 map 就是一个对象（从 mapState 的使用场景来看，传入的参数不是数组就是对象），我们调用 Object.keys 方法遍历这个 map 对象的 key，把数组的每个 key 都转换成一个 {key, val: map[key]}的对象。最后我们把这个对象数组作为 normalizeMap 的返回值。\n\n回到 mapState 函数，在调用了 normalizeMap 函数后，把传入的 states 转换成由 {key, val} 对象构成的数组，接着调用 forEach 方法遍历这个数组，构造一个新的对象，这个新对象每个元素都返回一个新的函数 mappedState，函数对 val 的类型判断，如果 val 是一个函数，则直接调用这个 val 函数，把当前 store 上的 state 和 getters 作为参数，返回值作为 mappedState 的返回值；否则直接把 this.$store.state[val] 作为 mappedState 的返回值。\n\n那么为何 mapState 函数的返回值是这样一个对象呢，因为 mapState 的作用是把全局的 state 和 getters 映射到当前组件的 computed 计算属性中，我们知道在 Vue 中 每个计算属性都是一个函数。\n\n为了更加直观地说明，回到刚才的例子：\n\n```js\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可以让代码非常简洁\n    count: state => state.count,\n    // 传入字符串 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n    // 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n经过 mapState 函数调用后的结果，如下所示：\n\n```js\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: {\n    count() {\n\t  return this.$store.state.count\n    },\n    countAlias() {\n\t  return this.$store.state['count']\n    },\n    countPlusLocalState() {\n      return this.$store.state.count + this.localCount\n    }\n  }\n}\n```\n\n我们再看一下 mapState 参数为数组的例子：\n\n```js\ncomputed: mapState([\n  // 映射 this.count 到 this.$store.state.count\n  'count'\n])\n```\n\n经过 mapState 函数调用后的结果，如下所示：\n\n```js\ncomputed: {\n  count() {\n    return this.$store.state['count']\n  }\n}\n```\n\n#### mapGetters\n\nmapGetters 工具函数会将 store 中的 getter 映射到局部计算属性中。它的功能和 mapState 非常类似，我们来直接看它的实现：\n\n```js\nexport function mapGetters (getters) {\n  const res = {}\n  normalizeMap(getters).forEach(({ key, val }) => {\n    res[key] = function mappedGetter () {\n      if (!(val in this.$store.getters)) {\n        console.error(`[vuex] unknown getter: ${val}`)\n      }\n      return this.$store.getters[val]\n    }\n  })\n  return res\n}\n```\n\nmapGetters 的实现也和 mapState 很类似，不同的是它的 val 不能是函数，只能是一个字符串，而且会检查 val in this.$store.getters 的值，如果为 false 会输出一条错误日志。为了更直观地理解，我们来看一个简单的例子：\n\n```js\nimport { mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: {\n    // 使用对象扩展操作符把 getter 混入到 computed 中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n\n经过 mapGetters 函数调用后的结果，如下所示：\n\n```js\nimport { mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: {\n    doneTodosCount() {\n      return this.$store.getters['doneTodosCount']\n    },\n    anotherGetter() {\n      return this.$store.getters['anotherGetter']\n    }\n  }\n}\n```\n\n再看一个参数 mapGetters 参数是对象的例子：\n\n```js\ncomputed: mapGetters({\n  // 映射 this.doneCount 到 store.getters.doneTodosCount\n  doneCount: 'doneTodosCount'\n})\n```\n\n经过 mapGetters 函数调用后的结果，如下所示：\n\n```js\ncomputed: {\n  doneCount() {\n    return this.$store.getters['doneTodosCount']\n  }\n}\n```\n\n#### mapActions\n\nmapActions 工具函数会将 store 中的 dispatch 方法映射到组件的 methods 中。和 mapState、mapGetters 也类似，只不过它映射的地方不是计算属性，而是组件的 methods 对象上。我们来直接看它的实现：\n\n```js\nexport function mapActions (actions) {\n  const res = {}\n  normalizeMap(actions).forEach(({ key, val }) => {\n    res[key] = function mappedAction (...args) {\n      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n}\n```\n\n可以看到，函数的实现套路和 mapState、mapGetters 差不多，甚至更简单一些， 实际上就是做了一层函数包装。为了更直观地理解，我们来看一个简单的例子：\n\n```js\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment' // 映射 this.increment() 到 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n      add: 'increment' // 映射 this.add() to this.$store.dispatch('increment')\n    })\n  }\n}\n```\n\n经过 mapActions 函数调用后的结果，如下所示：\n\n```js\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    increment(...args) {\n      return this.$store.dispatch.apply(this.$store, ['increment'].concat(args))\n\t}\n    add(...args) {\n      return this.$store.dispatch.apply(this.$store, ['increment'].concat(args))\n\t}\n  }\n}\n```\n\n#### mapMutations\n\nmapMutations 工具函数会将 store 中的 commit 方法映射到组件的 methods 中。和 mapActions 的功能几乎一样，我们来直接看它的实现：\n\n```js\nexport function mapMutations (mutations) {\n  const res = {}\n  normalizeMap(mutations).forEach(({ key, val }) => {\n    res[key] = function mappedMutation (...args) {\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n}\n```\n\n函数的实现几乎也和 mapActions 一样，唯一差别就是映射的是 store 的 commit 方法。为了更直观地理解，我们来看一个简单的例子：\n\n```js\nimport { mapMutations } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment' // 映射 this.increment() 到 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n      add: 'increment' // 映射 this.add() 到 this.$store.commit('increment')\n    })\n  }\n}\n```\n\n经过 mapMutations 函数调用后的结果，如下所示：\n\n```js\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    increment(...args) {\n      return this.$store.commit.apply(this.$store, ['increment'].concat(args))\n\t}\n    add(...args) {\n      return this.$store.commit.apply(this.$store, ['increment'].concat(args))\n\t}\n  }\n}\n```\n\n### 插件\n\nVuex 的 store 接收 plugins 选项，一个 Vuex 的插件就是一个简单的方法，接收 store 作为唯一参数。插件作用通常是用来监听每次 mutation 的变化，来做一些事情。\n\n在 store 的构造函数的最后，我们通过如下代码调用插件：\n\n```js\nimport devtoolPlugin from './plugins/devtool'\n\n// apply plugins\nplugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n```\n\n我们通常实例化 store 的时候，还会调用 logger 插件，代码如下：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport createLogger from 'vuex/dist/logger'\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== 'production'\n\nexport default new Vuex.Store({\n  ...\n  plugins: debug ? [createLogger()] : []\n})\n```\n\n在上述 2 个例子中，我们分别调用了 devtoolPlugin 和 createLogger() 2 个插件，它们是 Vuex 内置插件，我们接下来分别看一下他们的实现。\n\n#### devtoolPlugin\n\ndevtoolPlugin 主要功能是利用 Vue 的开发者工具和 Vuex 做配合，通过开发者工具的面板展示 Vuex 的状态。它的源码在 src/plugins/devtool.js 中，来看一下这个插件到底做了哪些事情。\n\n```js\nconst devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\nexport default function devtoolPlugin (store) {\n  if (!devtoolHook) return\n\n  store._devtoolHook = devtoolHook\n\n  devtoolHook.emit('vuex:init', store)\n\n  devtoolHook.on('vuex:travel-to-state', targetState => {\n    store.replaceState(targetState)\n  })\n\n  store.subscribe((mutation, state) => {\n    devtoolHook.emit('vuex:mutation', mutation, state)\n  })\n}\n```\n\n我们直接从对外暴露的 devtoolPlugin 函数看起，函数首先判断了devtoolHook 的值，如果我们浏览器装了 Vue 开发者工具，那么在 window 上就会有一个 `__VUE_DEVTOOLS_GLOBAL_HOOK__` 的引用， 那么这个 devtoolHook 就指向这个引用。\n\n接下来通过 devtoolHook.emit('vuex:init', store) 派发一个 Vuex 初始化的事件，这样开发者工具就能拿到当前这个 store 实例。\n\n接下来通过 devtoolHook.on('vuex:travel-to-state', targetState => { store.replaceState(targetState) })监听 Vuex 的 traval-to-state 的事件，把当前的状态树替换成目标状态树，这个功能也是利用 Vue 开发者工具替换 Vuex 的状态。\n\n最后通过 store.subscribe((mutation, state) => { devtoolHook.emit('vuex:mutation', mutation, state) }) 方法订阅 store 的 state 的变化，当 store 的 mutation 提交了 state 的变化， 会触发回调函数——通过 devtoolHook 派发一个 Vuex mutation 的事件，mutation 和 rootState 作为参数，这样开发者工具就可以观测到 Vuex state 的实时变化，在面板上展示最新的状态树。\n\n#### loggerPlugin\n\n通常在开发环境中，我们希望实时把 mutation 的动作以及 store 的 state 的变化实时输出，那么我们可以用 loggerPlugin 帮我们做这个事情。它的源码在 src/plugins/logger.js 中，来看一下这个插件到底做了哪些事情。\n\n```js\n// Credits: borrowed code from fcomb/redux-logger\n\nimport { deepCopy } from '../util'\n\nexport default function createLogger ({\n  collapsed = true,\n  transformer = state => state,\n  mutationTransformer = mut => mut\n} = {}) {\n  return store => {\n    let prevState = deepCopy(store.state)\n\n    store.subscribe((mutation, state) => {\n      if (typeof console === 'undefined') {\n        return\n      }\n      const nextState = deepCopy(state)\n      const time = new Date()\n      const formattedTime = ` @ ${pad(time.getHours(), 2)}:${pad(time.getMinutes(), 2)}:${pad(time.getSeconds(), 2)}.${pad(time.getMilliseconds(), 3)}`\n      const formattedMutation = mutationTransformer(mutation)\n      const message = `mutation ${mutation.type}${formattedTime}`\n      const startMessage = collapsed\n        ? console.groupCollapsed\n        : console.group\n\n      // render\n      try {\n        startMessage.call(console, message)\n      } catch (e) {\n        console.log(message)\n      }\n\n      console.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState))\n      console.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation)\n      console.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState))\n\n      try {\n        console.groupEnd()\n      } catch (e) {\n        console.log('—— log end ——')\n      }\n\n      prevState = nextState\n    })\n  }\n}\n\nfunction repeat (str, times) {\n  return (new Array(times + 1)).join(str)\n}\n\nfunction pad (num, maxLength) {\n  return repeat('0', maxLength - num.toString().length) + num\n}\n```\n\n插件对外暴露的是 createLogger 方法，它实际上接受 3 个参数，它们都有默认值，通常我们用默认值就可以。createLogger 的返回的是一个函数，当我执行 logger 插件的时候，实际上执行的是这个函数，下面来看一下这个函数做了哪些事情。\n\n函数首先执行了 let prevState = deepCopy(store.state) 深拷贝当前 store 的 rootState。这里为什么要深拷贝，因为如果是单纯的引用，那么 store.state 的任何变化都会影响这个引用，这样就无法记录上一个状态了。我们来了解一下 deepCopy 的实现，在 src/util.js 里定义：\n\n```js\nfunction find (list, f) {\n  return list.filter(f)[0]\n}\n\nexport function deepCopy (obj, cache = []) {\n  // just return if obj is immutable value\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  // if obj is hit, it is in circular structure\n  const hit = find(cache, c => c.original === obj)\n  if (hit) {\n    return hit.copy\n  }\n\n  const copy = Array.isArray(obj) ? [] : {}\n  // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n  cache.push({\n    original: obj,\n    copy\n  })\n\n  Object.keys(obj).forEach(key => {\n    copy[key] = deepCopy(obj[key], cache)\n  })\n\n  return copy\n}\n```\n\ndeepCopy 并不陌生，很多开源库如 loadash、jQuery 都有类似的实现，原理也不难理解，主要是构造一个新的对象，遍历原对象或者数组，递归调用 deepCopy。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过`find(cache, c => c.original === obj)`发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。\n\n回到 loggerPlugin 函数，通过 deepCopy 拷贝了当前 state 的副本并用 prevState 变量保存，接下来调用 store.subscribe 方法订阅 store 的 state 的变。 在回调函数中，也是先通过 deepCopy 方法拿到当前的 state 的副本，并用 nextState 变量保存。接下来获取当前格式化时间已经格式化的 mutation 变化的字符串，然后利用 console.group 以及 console.log 分组输出 prevState、mutation以及 nextState，这里可以通过我们 createLogger 的参数 collapsed、transformer 以及 mutationTransformer 来控制我们最终 log 的显示效果。在函数的最后，我们把 nextState 赋值给 prevState，便于下一次 mutation。","slug":"2018-07-26-Vuex源码分析","published":1,"updated":"2019-01-02T08:49:00.262Z","comments":0,"photos":[],"link":"post/2018-07-26-Vuex源码分析","_id":"cjz2epjg10023n3w574iff9lm","content":"<blockquote>\n<p>原文：<a href=\"https://github.com/DDFE/DDFE-blog/issues/8\" target=\"_blank\" rel=\"noopener\">Vuex 2.0 源码分析</a></p>\n</blockquote>\n<h2 id=\"目录结构\">目录结构<a href=\"post/2018-07-26-Vuex源码分析#目录结构\"></a></h2><p>Vuex 的源码托管在 github，我们首先通过 git 把代码 clone 到本地，选一款适合自己的 IDE 打开源码，展开 src 目录，如下图所示：</p>\n<p><img src=\"https://camo.githubusercontent.com/4c0c82eb95a6d128f80355522e266fe5220ca863/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565785f7372632e706e67\" alt=\"\" class=\"article-img\"></p>\n<p>src 目录下的文件并不多，包含几个 js 文件和 plugins 目录， plugins 目录里面包含 2 个 Vuex 的内置插件，整个源码加起来不过 500-600 行，可谓非常轻巧的一个库。</p>\n<p>麻雀虽小，五脏俱全，我们先直观的感受一下源码的结构，接下来看一下其中的实现细节。</p>\n<h2 id=\"源码分析\">源码分析<a href=\"post/2018-07-26-Vuex源码分析#源码分析\"></a></h2><p>本文的源码分析过程不会是自上而下的给代码加注释，我更倾向于是从 Vuex 提供的 API 和我们的使用方法等维度去分析。Vuex 的源码是基于 es6 的语法编写的，对于不了解 es6 的同学，建议还是先学习一下 es6。</p>\n<h3 id=\"从入口开始\">从入口开始<a href=\"post/2018-07-26-Vuex源码分析#从入口开始\"></a></h3><p>看源码一般是从入口开始，Vuex 源码的入口是 src/index.js，先来打开这个文件。</p>\n<p>我们首先看这个库的 export ，在 index.js 代码最后。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  Store,</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  mapState,</span><br><span class=\"line\">  mapMutations,</span><br><span class=\"line\">  mapGetters,</span><br><span class=\"line\">  mapActions</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里可以一目了然地看到 Vuex 对外暴露的 API。其中, Store 是 Vuex 提供的状态存储类，通常我们使用 Vuex 就是通过创建 Store 的实例，稍后我们会详细介绍。接着是 install 方法，这个方法通常是我们编写第三方 Vue 插件的“套路”，先来看一下“套路”代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">      <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// auto install in dist mode</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">window</span>.Vue) &#123;</span><br><span class=\"line\">  install(<span class=\"built_in\">window</span>.Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>我们实现了一个 install 方法，这个方法当我们全局引用 Vue ，也就是 window 上有 Vue 对象的时候，会手动调用 install 方法，并传入 Vue 的引用；当 Vue 通过 npm 安装到项目中的时候，我们在代码中引入第三方 Vue 插件通常会编写如下代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></div></figure>\n<p>当我们执行 Vue.use(Vuex) 这句代码的时候，实际上就是调用了 install 的方法并传入 Vue 的引用。install 方法顾名思义，现在让我们来看看它的实现。它接受了一个参数 _Vue，函数体首先判断 Vue ，这个变量的定义在 index.js 文件的开头部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Vue <span class=\"comment\">// bind on install</span></span><br></pre></td></tr></table></div></figure>\n<p>对 Vue 的判断主要是保证 install 方法只执行一次，这里把 install 方法的参数 _Vue 对象赋值给 Vue 变量，这样我们就可以在 index.js 文件的其它地方使用 Vue 这个变量了。install 方法的最后调用了 applyMixin 方法，我们顺便来看一下这个方法的实现，在 src/mixin.js 文件里定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">    <span class=\"comment\">// store injection</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这段代码的作用就是在 Vue 的生命周期中的初始化（1.0 版本是 init，2.0 版本是 beforeCreated）钩子前插入一段 Vuex 初始化代码。这里做的事情很简单——给 Vue 的实例注入一个 <code>$store</code> 的属性，这也就是为什么我们在 Vue 的组件中可以通过 <code>this.$store.xxx</code> 访问到 Vuex 的各种数据和状态。</p>\n<h3 id=\"认识-Store-构造函数\">认识 Store 构造函数<a href=\"post/2018-07-26-Vuex源码分析#认识-Store-构造函数\"></a></h3><p>我们在使用 Vuex 的时候，通常会实例化 Store 类，然后传入一个对象，包括我们定义好的 actions、getters、mutations、state等，甚至当我们有多个子模块的时候，我们可以添加一个 modules 对象。那么实例化的时候，到底做了哪些事情呢？带着这个疑问，让我们回到 index.js 文件，重点看一下 Store 类的定义。Store 类定义的代码略长，我不会一下就贴上所有代码，我们来拆解分析它，首先看一下构造函数的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Store</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    assert(Vue, <span class=\"string\">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class=\"line\">    assert(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span>, <span class=\"string\">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      state = &#123;&#125;,</span><br><span class=\"line\">      plugins = [],</span><br><span class=\"line\">      strict = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125; = options</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// store internal state</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._options = options</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._committing = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._runtimeModules = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._subscribers = []</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._watcherVM = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// bind commit and dispatch to self</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dispatch = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundDispatch</span> (<span class=\"params\">type, payload</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dispatch.call(store, type, payload)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.commit = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundCommit</span> (<span class=\"params\">type, payload, options</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> commit.call(store, type, payload, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// strict mode</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strict = strict</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// init root module.</span></span><br><span class=\"line\">    <span class=\"comment\">// this also recursively registers all sub-modules</span></span><br><span class=\"line\">    <span class=\"comment\">// and collects all module getters inside this._wrappedGetters</span></span><br><span class=\"line\">    installModule(<span class=\"keyword\">this</span>, state, [], options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class=\"line\">    <span class=\"comment\">// (also registers _wrappedGetters as computed properties)</span></span><br><span class=\"line\">    resetStoreVM(<span class=\"keyword\">this</span>, state)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// apply plugins</span></span><br><span class=\"line\">    plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>构造函数的一开始就用了“断言函数”，来判断是否满足一些条件。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert(Vue, <span class=\"string\">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br></pre></td></tr></table></div></figure>\n<p>这行代码的目的是确保 Vue 的存在，也就是在我们实例化 Store 之前，必须要保证之前的 install 方法已经执行了。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span>, <span class=\"string\">`vuex requires a Promise polyfill in this browser.`</span>)</span><br></pre></td></tr></table></div></figure>\n<p>这行代码的目的是为了确保 Promsie 可以使用的，因为 Vuex 的源码是依赖 Promise 的。Promise 是 es6 提供新的 API，由于现在的浏览器并不是都支持 es6 语法的，所以通常我们会用 babel 编译我们的代码，如果想使用 Promise 这个 特性，我们需要在 package.json 中添加对 babel-polyfill 的依赖并在代码的入口加上 import ‘babel-polyfill’ 这段代码。</p>\n<p>再来看看 assert 这个函数，它并不是浏览器原生支持的，它的实现在 src/util.js 里，代码如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>非常简单，对 condition 判断，如果不不为真，则抛出异常。这个函数虽然简单，但这种编程方式值得我们学习。</p>\n<p>再来看构造函数接下来的代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  state = &#123;&#125;,</span><br><span class=\"line\">  plugins = [],</span><br><span class=\"line\">  strict = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125; = options</span><br></pre></td></tr></table></div></figure>\n<p>这里就是利用 es6 的解构赋值拿到 options 里的 state，plugins 和 strict。state 表示 rootState，plugins 表示应用的插件、strict 表示是否开启严格模式。</p>\n<p>接着往下看：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store internal state</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._options = options</span><br><span class=\"line\"><span class=\"keyword\">this</span>._committing = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._runtimeModules = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._subscribers = []</span><br><span class=\"line\"><span class=\"keyword\">this</span>._watcherVM = <span class=\"keyword\">new</span> Vue()</span><br></pre></td></tr></table></div></figure>\n<p>这里主要是创建一些内部的属性：<br>this._options 存储参数 options。<br>this._committing 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state。<br>this._actions 用来存储用户定义的所有的 actions。<br>this._mutations 用来存储用户定义所有的 mutatins。<br>this._wrappedGetters 用来存储用户定义的所有 getters 。<br>this._runtimeModules 用来存储所有的运行时的 modules。<br>this._subscribers 用来存储所有对 mutation 变化的订阅者。<br>this._watcherVM 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化的。</p>\n<p>继续往下看：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind commit and dispatch to self</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.dispatch = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundDispatch</span> (<span class=\"params\">type, payload</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch.call(store, type, payload)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.commit = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundCommit</span> (<span class=\"params\">type, payload, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> commit.call(store, type, payload, options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// strict mode</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.strict = strict</span><br></pre></td></tr></table></div></figure>\n<p>这里的代码也不难理解，把 Store 类的 dispatch 和 commit 的方法的 this 指针指向当前 store 的实例上，dispatch 和 commit 的实现我们稍后会分析。this.strict 表示是否开启严格模式，在严格模式下会观测所有的 state 的变化，建议在开发环境时开启严格模式，线上环境要关闭严格模式，否则会有一定的性能开销。</p>\n<h3 id=\"Vuex-的初始化核心\">Vuex 的初始化核心<a href=\"post/2018-07-26-Vuex源码分析#Vuex-的初始化核心\"></a></h3><h4 id=\"installModule\">installModule<a href=\"post/2018-07-26-Vuex源码分析#installModule\"></a></h4><p>我们接着往下看：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init root module.</span></span><br><span class=\"line\"><span class=\"comment\">// this also recursively registers all sub-modules</span></span><br><span class=\"line\"><span class=\"comment\">// and collects all module getters inside this._wrappedGetters</span></span><br><span class=\"line\">installModule(<span class=\"keyword\">this</span>, state, [], options)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class=\"line\"><span class=\"comment\">// (also registers _wrappedGetters as computed properties)</span></span><br><span class=\"line\">resetStoreVM(<span class=\"keyword\">this</span>, state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apply plugins</span></span><br><span class=\"line\">plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></div></figure>\n<p>这段代码是 Vuex 的初始化的核心，其中，installModule 方法是把我们通过 options 传入的各种属性模块注册和安装；resetStoreVM 方法是初始化 store._vm，观测 state 和 getters 的变化；最后是应用传入的插件。</p>\n<p>下面，我们先来看一下 installModule 的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">installModule</span> (<span class=\"params\">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isRoot = !path.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    state,</span><br><span class=\"line\">    actions,</span><br><span class=\"line\">    mutations,</span><br><span class=\"line\">    getters,</span><br><span class=\"line\">    modules</span><br><span class=\"line\">  &#125; = <span class=\"built_in\">module</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set state</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mutations) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(mutations).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">      registerMutation(store, key, mutations[key], path)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (actions) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(actions).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">      registerAction(store, key, actions[key], path)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (getters) &#123;</span><br><span class=\"line\">    wrapGetters(store, getters, path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (modules) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(modules).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">      installModule(store, rootState, path.concat(key), modules[key], hot)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>installModule 函数可接收5个参数，store、rootState、path、module、hot，store 表示当前 Store 实例，rootState 表示根 state，path 表示当前嵌套模块的路径数组，module 表示当前安装的模块，hot 当动态改变 modules 或者热更新的时候为 true。</p>\n<p>先来看这部分代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isRoot = !path.length</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  state,</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  mutations,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  modules</span><br><span class=\"line\">&#125; = <span class=\"built_in\">module</span></span><br></pre></td></tr></table></div></figure>\n<p>代码首先通过 path 数组的长度判断是否为根。我们在构造函数调用的时候是 installModule(this, state, [], options)，所以这里 isRoot 为 true。module 为传入的 options，我们拿到了 module 下的 state、actions、mutations、getters 以及嵌套的 modules。</p>\n<p>接着看下面的代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set state</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">  store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里判断当不为根且非热更新的情况，然后设置级联状态，这里乍一看不好理解，我们先放一放，稍后来回顾。</p>\n<p>再往下看代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mutations) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(mutations).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    registerMutation(store, key, mutations[key], path)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actions) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(actions).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    registerAction(store, key, actions[key], path)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (getters) &#123;</span><br><span class=\"line\">  wrapGetters(store, getters, path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里分别是对 mutations、actions、getters 进行注册，如果我们实例化 Store 的时候通过 options 传入这些对象，那么会分别进行注册，我稍后再去介绍注册的具体实现。那么到这，如果 Vuex 没有 module ，这个 installModule 方法可以说已经做完了。但是 Vuex 巧妙了设计了 module 这个概念，因为 Vuex 本身是单一状态树，应用的所有状态都包含在一个大对象内，随着我们应用规模的不断增长，这个 Store 变得非常臃肿。为了解决这个问题，Vuex 允许我们把 store 分 module（模块）。每一个模块包含各自的 state、mutations、actions 和 getters，甚至是嵌套模块。所以，接下来还有一行代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (modules) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(modules).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    installModule(store, rootState, path.concat(key), modules[key], hot)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里通过遍历 modules，递归调用 installModule 去安装子模块。这里传入了 store、rootState、path.concat(key)、和 modules[key]，和刚才不同的是，path 不为空，module 对应为子模块，那么我们回到刚才那段代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set state</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">  store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>当递归初始化子模块的时候，isRoot 为 false，注意这里有个方法getNestedState(rootState, path)，来看一下 getNestedState 函数的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNestedState</span> (<span class=\"params\">state, path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> path.length</span><br><span class=\"line\">    ? path.reduce(<span class=\"function\">(<span class=\"params\">state, key</span>) =&gt;</span> state[key], state)</span><br><span class=\"line\">    : state</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个方法很简单，就是根据 path 查找 state 上的嵌套 state。在这里就是传入 rootState 和 path，计算出当前模块的父模块的 state，由于模块的 path 是根据模块的名称 concat 连接的，所以 path 的最后一个元素就是当前模块的模块名，最后调用</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>把当前模块的 state 添加到 parentState 中。<br>这里注意一下我们用了 store._withCommit 方法，来看一下这个方法的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>由于我们是在修改 state，Vuex 中所有对 state 的修改都会用 _withCommit函数包装，保证在同步修改 state 的过程中 this._committing 的值始终为true。这样当我们观测 state 的变化时，如果 this._committing 的值不为 true，则能检查到这个状态修改是有问题的。</p>\n<p>看到这里，有些同学可能会有点困惑，举个例子来直观感受一下，以 Vuex 源码中的 example/shopping-cart 为例，打开 store/index.js，有这么一段代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    cart,</span><br><span class=\"line\">    products</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  strict: debug,</span><br><span class=\"line\">  plugins: debug ? [createLogger()] : []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>这里有两个子 module，cart 和 products，我们打开 store/modules/cart.js，看一下 cart 模块中的 state 定义，代码如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  added: [],</span><br><span class=\"line\">  checkoutStatus: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>我们运行这个项目，打开浏览器，利用 Vue 的调试工具来看一下 Vuex 中的状态，如下图所示：</p>\n<p><img src=\"https://camo.githubusercontent.com/2bd2ed9ea9f74792db15c5980666275330ab64a2/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565782d746573742e706e67\" alt=\"\" class=\"article-img\"></p>\n<p>可以看到，在 rootState 下，分别有 cart 和 products 2个属性，key 根据模块名称而来，value 就是在每个模块文件中定义的 state，这就把模块 state 挂载到 rootState 上了。</p>\n<p>我们了解完嵌套模块 state 是怎么一回事后，我们回过头来看一下 installModule 过程中的其它 3 个重要方法：registerMutation、registerAction 和 wrapGetters。顾名思义，这 3 个方法分别处理 mutations、actions 和 getters。我们先来看一下 registerMutation 的定义：</p>\n<h4 id=\"registerMutation\">registerMutation<a href=\"post/2018-07-26-Vuex源码分析#registerMutation\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerMutation</span> (<span class=\"params\">store, type, handler, path = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedMutationHandler</span> (<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">    handler(getNestedState(store.state, path), payload)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>registerMutation 是对 store 的 mutation 的初始化，它接受 4 个参数，store为当前 Store 实例，type为 mutation 的 key，handler 为 mutation 执行的回调函数，path 为当前模块的路径。mutation 的作用就是同步修改当前模块的 state ，函数首先通过 type 拿到对应的 mutation 对象数组， 然后把一个 mutation 的包装函数 push 到这个数组中，这个函数接收一个参数 payload，这个就是我们在定义 mutation 的时候接收的额外参数。这个函数执行的时候会调用 mutation 的回调函数，并通过 getNestedState(store.state, path) 方法得到当前模块的 state，和 playload 一起作为回调函数的参数。举个例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, n) &#123;</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里我们定义了一个 mutation，通过刚才的 registerMutation 方法，我们注册了这个 mutation，这里的 state 对应的就是当前模块的 state，n 就是额外参数 payload，接下来我们会从源码分析的角度来介绍这个 mutation 的回调是何时被调用的，参数是如何传递的。</p>\n<p>我们有必要知道 mutation 的回调函数的调用时机，在 Vuex 中，mutation 的调用是通过 store 实例的 API 接口 commit 来调用的，来看一下 commit 函数的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit (type, payload, options) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style commit</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class=\"line\">    options = payload</span><br><span class=\"line\">    payload = type</span><br><span class=\"line\">    type = type.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mutation = &#123; type, payload &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._mutations[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown mutation type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    entry.forEach(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitIterator</span> (<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">      handler(payload)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options || !options.silent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._subscribers.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> sub(mutation, <span class=\"keyword\">this</span>.state))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>commit 支持 3 个参数，type 表示 mutation 的类型，payload 表示额外的参数，options 表示一些配置，比如 silent 等，稍后会用到。commit 函数首先对 type 的类型做了判断，处理了 type 为 object 的情况，接着根据 type 去查找对应的 mutation，如果找不到，则输出一条错误信息，否则遍历这个 type 对应的 mutation 对象数组，执行 handler(payload) 方法，这个方法就是之前定义的 wrappedMutationHandler(handler)，执行它就相当于执行了 registerMutation 注册的回调函数，并把当前模块的 state 和 额外参数 payload 作为参数传入。注意这里我们依然使用了 this._withCommit 的方法提交 mutation。commit 函数的最后，判断如果不是静默模式，则遍历 this._subscribers，调用回调函数，并把 mutation 和当前的根 state 作为参数传入。那么这个 this._subscribers 是什么呢？原来 Vuex 的 Store 实例提供了 subscribe API 接口，它的作用是订阅（注册监听） store 的 mutation。先来看一下它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscribe (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>._subscribers</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (subs.indexOf(fn) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    subs.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> i = subs.indexOf(fn)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      subs.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>subscribe 方法很简单，他接受的参数是一个回调函数，会把这个回调函数保存到 this._subscribers 上，并返回一个函数，当我们调用这个返回的函数，就可以解除当前函数对 store 的 mutation 的监听。其实，Vuex 的内置 logger 插件就是基于 subscribe 接口实现对 store 的 muation的监听，稍后我们会详细介绍这个插件。</p>\n<h4 id=\"registerAction\">registerAction<a href=\"post/2018-07-26-Vuex源码分析#registerAction\"></a></h4><p>在了解完 registerMutation，我们再来看一下 registerAction 的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerAction</span> (<span class=\"params\">store, type, handler, path = []</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = store</span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">      dispatch,</span><br><span class=\"line\">      commit,</span><br><span class=\"line\">      getters: store.getters,</span><br><span class=\"line\">      state: getNestedState(store.state, path),</span><br><span class=\"line\">      rootState: store.state</span><br><span class=\"line\">    &#125;, payload, cb)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">      res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>registerAction 是对 store 的 action 的初始化，它和 registerMutation 的参数一致，和 mutation 不同一点，mutation 是同步修改当前模块的 state，而 action 是可以异步去修改 state，这里不要误会，在 action 的回调中并不会直接修改 state ，仍然是通过提交一个 mutation 去修改 state（在 Vuex 中，mutation 是修改 state 的唯一途径）。那我们就来看看 action 是如何做到这一点的。</p>\n<p>函数首先也是通过 type 拿到对应 action 的对象数组，然后把一个 action 的包装函数 push 到这个数组中，这个函数接收 2 个参数，payload 表示额外参数 ，cb 表示回调函数（实际上我们并没有使用它）。这个函数执行的时候会调用 action 的回调函数，传入一个 context 对象，这个对象包括了 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState 等等。接着对这个函数的返回值做判断，如果不是一个 Promise 对象，则调用 Promise.resolve（res） 给res 包装成了一个 Promise 对象。这里也就解释了为何 Vuex 的源码依赖 Promise，这里对 Promise 的判断也和简单，参考代码 src/util.js，对 isPromise 的判断如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPromise</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val &amp;&amp; <span class=\"keyword\">typeof</span> val.then === <span class=\"string\">'function'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>其实就是简单的检查对象的 then 方法，如果包含说明就是一个 Promise 对象。</p>\n<p>接着判断 store._devtoolHook，这个只有当用到 Vuex devtools 开启的时候，我们才能捕获 promise 的过程中的 。 action 的包装函数最后返回 res ，它就是一个地地道道的 Promise 对象。来看个例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  checkout (&#123; commit, state &#125;, payload) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把当前购物车的商品备份起来</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> savedCartItems = [...state.cart.added]</span><br><span class=\"line\">    <span class=\"comment\">// 发送结帐请求，并愉快地清空购物车</span></span><br><span class=\"line\">    commit(types.CHECKOUT_REQUEST)</span><br><span class=\"line\">    <span class=\"comment\">// 购物 API 接收一个成功回调和一个失败回调</span></span><br><span class=\"line\">    shop.buyProducts(</span><br><span class=\"line\">      products,</span><br><span class=\"line\">      <span class=\"comment\">// 成功操作</span></span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class=\"line\">      <span class=\"comment\">// 失败操作</span></span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里我们定义了一个 action，通过刚才的 registerAction 方法，我们注册了这个 action，这里的 commit 就是 store 的 API 接口，可以通过它在 action 里提交一个 mutation。state 对应的就是当前模块的 state，我们在这个 action 里即可以同步提交 mutation，也可以异步提交。接下来我们会从源码分析的角度来介绍这个 action 的回调是何时被调用的，参数是如何传递的。</p>\n<p>我们有必要知道 action 的回调函数的调用时机，在 Vuex 中，action 的调用是通过 store 实例的 API 接口 dispatch 来调用的，来看一下 dispatch 函数的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch (type, payload) &#123;</span><br><span class=\"line\"><span class=\"comment\">// check object-style dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class=\"line\">    payload = type</span><br><span class=\"line\">    type = type.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._actions[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown action type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> entry.length &gt; <span class=\"number\">1</span></span><br><span class=\"line\">    ? <span class=\"built_in\">Promise</span>.all(entry.map(<span class=\"function\"><span class=\"params\">handler</span> =&gt;</span> handler(payload)))</span><br><span class=\"line\">    : entry[<span class=\"number\">0</span>](payload)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>dispatch 支持2个参数，type 表示 action 的类型，payload 表示额外的参数。前面几行代码和 commit 接口非常类似，都是找到对应 type 下的 action 对象数组，唯一和 commit 不同的地方是最后部分，它对 action 的对象数组长度做判断，如果长度为 1 则直接调用<code>entry[0](payload)</code>， 这个方法就是之前定义的 wrappedActionHandler(payload, cb)，执行它就相当于执行了 registerAction 注册的回调函数，并把当前模块的 context 和 额外参数 payload 作为参数传入。所以我们在 action 的回调函数里，可以拿到当前模块的上下文包括 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState，可见 action 是非常灵活的。</p>\n<h4 id=\"wrapGetters\">wrapGetters<a href=\"post/2018-07-26-Vuex源码分析#wrapGetters\"></a></h4><p>了解完 registerAction 后，我们来看看 wrapGetters的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapGetters</span> (<span class=\"params\">store, moduleGetters, modulePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(moduleGetters).forEach(<span class=\"function\"><span class=\"params\">getterKey</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rawGetter = moduleGetters[getterKey]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (store._wrappedGetters[getterKey]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] duplicate getter key: <span class=\"subst\">$&#123;getterKey&#125;</span>`</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    store._wrappedGetters[getterKey] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedGetter</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> rawGetter(</span><br><span class=\"line\">        getNestedState(store.state, modulePath), <span class=\"comment\">// local state</span></span><br><span class=\"line\">        store.getters, <span class=\"comment\">// getters</span></span><br><span class=\"line\">        store.state <span class=\"comment\">// root state</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>wrapGetters 是对 store 的 getters 初始化，它接受 3个 参数， store 表示当前 Store 实例，moduleGetters 表示当前模块下的所有 getters, modulePath 对应模块的路径。细心的同学会发现，和刚才的 registerMutation 以及 registerAction 不同，这里对 getters 的循环遍历是放在了函数体内，并且 getters 和它们的一个区别是不允许 getter 的 key 有重复。</p>\n<p>这个函数做的事情就是遍历 moduleGetters，把每一个 getter 包装成一个方法，添加到 store._wrappedGetters 对象中，注意 getter 的 key 是不允许重复的。在这个包装的方法里，会执行 getter 的回调函数，并把当前模块的 state，store 的 getters 和 store 的 rootState 作为它参数。来看一个例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> cartProducts = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> state.cart.added.map(<span class=\"function\">(<span class=\"params\">&#123; id, quantity &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> product = state.products.all.find(<span class=\"function\"><span class=\"params\">p</span> =&gt;</span> p.id === id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      title: product.title,</span><br><span class=\"line\">      price: product.price,</span><br><span class=\"line\">      quantity</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里我们定义了一个 getter，通过刚才的 wrapGetters 方法，我们把这个 getter 添加到 store._wrappedGetters 对象里，这和回调函数的参数 state 对应的就是当前模块的 state，接下来我们从源码的角度分析这个函数是如何被调用，参数是如何传递的。</p>\n<p>我们有必要知道 getter 的回调函数的调用时机，在 Vuex 中，我们知道当我们在组件中通过 <code>this.$store.getters.xxxgetters</code> 可以访问到对应的 getter 的回调函数，那么我们需要把对应 getter 的包装函数的执行结果绑定到 <code>this.$store</code> 上。这部分的逻辑就在 resetStoreVM 函数里。我们在 Store 的构造函数中，在执行完 installModule 方法后，就会执行 resetStoreVM 方法。来看一下它的定义：</p>\n<h4 id=\"resetStoreVM\">resetStoreVM<a href=\"post/2018-07-26-Vuex源码分析#resetStoreVM\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetStoreVM</span> (<span class=\"params\">store, state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldVm = store._vm</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// bind store public getters</span></span><br><span class=\"line\">  store.getters = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrappedGetters = store._wrappedGetters</span><br><span class=\"line\">  <span class=\"keyword\">const</span> computed = &#123;&#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(wrappedGetters).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = wrappedGetters[key]</span><br><span class=\"line\">    <span class=\"comment\">// use computed to leverage its lazy-caching mechanism</span></span><br><span class=\"line\">    computed[key] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn(store)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">      get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store._vm[key]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// use a Vue instance to store the state tree</span></span><br><span class=\"line\">  <span class=\"comment\">// suppress warnings just in case the user has added</span></span><br><span class=\"line\">  <span class=\"comment\">// some funky global mixins</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> silent = Vue.config.silent</span><br><span class=\"line\">  Vue.config.silent = <span class=\"literal\">true</span></span><br><span class=\"line\">  store._vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    data: &#123; state &#125;,</span><br><span class=\"line\">    computed</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  Vue.config.silent = silent</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// enable strict mode for new vm</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store.strict) &#123;</span><br><span class=\"line\">    enableStrictMode(store)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldVm) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// dispatch changes in all subscribed watchers</span></span><br><span class=\"line\">    <span class=\"comment\">// to force getter re-evaluation.</span></span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      oldVm.state = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个方法主要是重置一个私有的 _vm 对象，它是一个 Vue 的实例。这个 _vm 对象会保留我们的 state 树，以及用计算属性的方式存储了 store 的 getters。来具体看看它的实现过程。我们把这个函数拆成几个部分来分析：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oldVm = store._vm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bind store public getters</span></span><br><span class=\"line\">store.getters = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> wrappedGetters = store._wrappedGetters</span><br><span class=\"line\"><span class=\"keyword\">const</span> computed = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(wrappedGetters).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = wrappedGetters[key]</span><br><span class=\"line\">  <span class=\"comment\">// use computed to leverage its lazy-caching mechanism</span></span><br><span class=\"line\">  computed[key] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn(store)</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store._vm[key]</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>这部分留了现有的 store._vm 对象，接着遍历 store._wrappedGetters 对象，在遍历过程中，依次拿到每个 getter 的包装函数，并把这个包装函数执行的结果用 computed 临时变量保存。接着用 es5 的 Object.defineProperty 方法为 store.getters 定义了 get 方法，也就是当我们在组件中调用<code>this.$store.getters.xxxgetters</code>这个方法的时候，会访问 store._vm[xxxgetters]。我们接着往下看：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// use a Vue instance to store the state tree</span></span><br><span class=\"line\"><span class=\"comment\">// suppress warnings just in case the user has added</span></span><br><span class=\"line\"><span class=\"comment\">// some funky global mixins</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> silent = Vue.config.silent</span><br><span class=\"line\">Vue.config.silent = <span class=\"literal\">true</span></span><br><span class=\"line\">store._vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; state &#125;,</span><br><span class=\"line\">  computed</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Vue.config.silent = silent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// enable strict mode for new vm</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (store.strict) &#123;</span><br><span class=\"line\">  enableStrictMode(store)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这部分的代码首先先拿全局 Vue.config.silent 的配置，然后临时把这个配置设成 true，接着实例化一个 Vue 的实例，把 store 的状态树 state 作为 data 传入，把我们刚才的临时变量 computed 作为计算属性传入。然后再把之前的 silent 配置重置。设置 silent 为 true 的目的是为了取消这个 _vm 的所有日志和警告。把 computed 对象作为 _vm 的 computed 属性，这样就完成了 getters 的注册。因为当我们在组件中访问 this.$store.getters.xxxgetters 的时候，就相当于访问 store._vm[xxxgetters]，也就是在访问 computed[xxxgetters]，这样就访问到了 xxxgetters 对应的回调函数了。这段代码最后判断 strict 属性决定是否开启严格模式，我们来看看严格模式都干了什么：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"string\">'state'</span>, () =&gt; &#123;</span><br><span class=\"line\">    assert(store._committing, <span class=\"string\">`Do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>严格模式做的事情很简单，监测 store._vm.state 的变化，看看 state 的变化是否通过执行 mutation 的回调函数改变，如果是外部直接修改 state，那么 store._committing 的值为 false，这样就抛出一条错误。再次强调一下，Vuex 中对 state 的修改只能在 mutation 的回调函数里。</p>\n<p>回到 resetStoreVM 函数，我们来看一下最后一部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldVm) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// dispatch changes in all subscribed watchers</span></span><br><span class=\"line\">  <span class=\"comment\">// to force getter re-evaluation.</span></span><br><span class=\"line\">  store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    oldVm.state = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里的逻辑很简单，由于这个函数每次都会创建新的 Vue 实例并赋值到 store._vm 上，那么旧的 _vm 对象的状态设置为 null，并调用 $destroy 方法销毁这个旧的 _vm 对象。</p>\n<p>那么到这里，Vuex 的初始化基本告一段落了，初始化核心就是 installModule 和 resetStoreVM 函数。通过对 mutations 、actions 和 getters 的注册，我们了解到 state 的是按模块划分的，按模块的嵌套形成一颗状态树。而 actions、mutations 和 getters 的全局的，其中 actions 和 mutations 的 key 允许重复，但 getters 的 key 是不允许重复的。官方推荐我们给这些全局的对象在定义的时候加一个名称空间来避免命名冲突。<br>从源码的角度介绍完 Vuex 的初始化的玩法，我们再从 Vuex 提供的 API 方向来分析其中的源码，看看这些 API 是如何实现的。</p>\n<h3 id=\"Vuex-API-分析\">Vuex API 分析<a href=\"post/2018-07-26-Vuex源码分析#Vuex-API-分析\"></a></h3><p>Vuex 常见的 API 如 dispatch、commit 、subscribe 我们前面已经介绍过了，这里就不再赘述了，下面介绍的一些 Store 的 API，虽然不常用，但是了解一下也不错。</p>\n<h4 id=\"watch-getter-cb-options\">watch(getter, cb, options)<a href=\"post/2018-07-26-Vuex源码分析#watch-getter-cb-options\"></a></h4><p>watch 作用是响应式的监测一个 getter 方法的返回值，当值改变时调用回调。getter 接收 store 的 state 作为唯一参数。来看一下它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch (getter, cb, options) &#123;</span><br><span class=\"line\">  assert(<span class=\"keyword\">typeof</span> getter === <span class=\"string\">'function'</span>, <span class=\"string\">`store.watch only accepts a function.`</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._watcherVM.$watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> getter(<span class=\"keyword\">this</span>.state), cb, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>函数首先断言 watch 的 getter 必须是一个方法，接着利用了内部一个 Vue 的实例对象 <code>this._watcherVM</code> 的 $watch 方法，观测 getter 方法返回值的变化，如果有变化则调用 cb 函数，回调函数的参数为新值和旧值。watch 方法返回的是一个方法，调用它则取消观测。</p>\n<h4 id=\"registerModule-path-module\">registerModule(path, module)<a href=\"post/2018-07-26-Vuex源码分析#registerModule-path-module\"></a></h4><p>registerModule 的作用是注册一个动态模块，有的时候当我们异步加载一些业务的时候，可以通过这个 API 接口去动态注册模块，来看一下它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerModule (path, <span class=\"built_in\">module</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> path === <span class=\"string\">'string'</span>) path = [path]</span><br><span class=\"line\">  assert(<span class=\"built_in\">Array</span>.isArray(path), <span class=\"string\">`module path must be a string or an Array.`</span>)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._runtimeModules[path.join(<span class=\"string\">'.'</span>)] = <span class=\"built_in\">module</span></span><br><span class=\"line\">  installModule(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.state, path, <span class=\"built_in\">module</span>)</span><br><span class=\"line\">  <span class=\"comment\">// reset store to update getters...</span></span><br><span class=\"line\">  resetStoreVM(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.state)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>函数首先对 path 判断，如果 path 是一个 string 则把 path 转换成一个 Array。接着把 module 对象缓存到 this._runtimeModules 这个对象里，path 用点连接作为该对象的 key。接着和初始化 Store 的逻辑一样，调用 installModule 和 resetStoreVm 方法安装一遍动态注入的 module。</p>\n<h4 id=\"unregisterModule-path\">unregisterModule(path)<a href=\"post/2018-07-26-Vuex源码分析#unregisterModule-path\"></a></h4><p>和 registerModule 方法相对的就是 unregisterModule 方法，它的作用是注销一个动态模块，来看一下它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unregisterModule (path) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> path === <span class=\"string\">'string'</span>) path = [path]</span><br><span class=\"line\">  assert(<span class=\"built_in\">Array</span>.isArray(path), <span class=\"string\">`module path must be a string or an Array.`</span>)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>._runtimeModules[path.join(<span class=\"string\">'.'</span>)]</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(<span class=\"keyword\">this</span>.state, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    Vue.delete(parentState, path[path.length - <span class=\"number\">1</span>])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  resetStore(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>函数首先还是对 path 的类型做了判断，这部分逻辑和注册是一样的。接着从 this._runtimeModules 里删掉以 path 点连接的 key 对应的模块。接着通过 this._withCommit 方法把当前模块的 state 对象从父 state 上删除。最后调用 resetStore(this) 方法，来看一下这个方法的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetStore</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  store._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  store._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = store.state</span><br><span class=\"line\">  <span class=\"comment\">// init root module</span></span><br><span class=\"line\">  installModule(store, state, [], store._options, <span class=\"literal\">true</span>)</span><br><span class=\"line\">  <span class=\"comment\">// init all runtime modules</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(store._runtimeModules).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    installModule(store, state, key.split(<span class=\"string\">'.'</span>), store._runtimeModules[key], <span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// reset vm</span></span><br><span class=\"line\">  resetStoreVM(store, state)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个方法作用就是重置 store 对象，重置 store 的 _actions、_mutations、_wrappedGetters 等等属性。然后再次调用 installModules 去重新安装一遍 Module 对应的这些属性，注意这里我们的最后一个参数 hot 为true，表示它是一次热更新。这样在 installModule 这个方法体类，如下这段逻辑就不会执行</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">installModule</span> (<span class=\"params\">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class=\"line\">  ... </span><br><span class=\"line\">  <span class=\"comment\">// set state</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>由于 hot 始终为 true，这里我们就不会重新对状态树做设置，我们的 state 保持不变。因为我们已经明确的删除了对应 path 下的 state 了，要做的事情只不过就是重新注册一遍 muations、actions 以及 getters。</p>\n<p>回调 resetStore 方法，接下来遍历 this._runtimeModules 模块，重新安装所有剩余的 runtime Moudles。最后还是调用 resetStoreVM 方法去重置 Store 的 _vm 对象。</p>\n<h4 id=\"hotUpdate-newOptions\">hotUpdate(newOptions)<a href=\"post/2018-07-26-Vuex源码分析#hotUpdate-newOptions\"></a></h4><p>hotUpdate 的作用是热加载新的 action 和 mutation。 来看一下它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hotUpdate (newOptions) &#123;</span><br><span class=\"line\">  updateModule(<span class=\"keyword\">this</span>._options, newOptions)</span><br><span class=\"line\">  resetStore(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>函数首先调用 updateModule 方法去更新状态，其中当前 Store 的 opition 配置和要更新的 newOptions 会作为参数。来看一下这个函数的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateModule</span> (<span class=\"params\">targetModule, newModule</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.actions) &#123;</span><br><span class=\"line\">    targetModule.actions = newModule.actions</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.mutations) &#123;</span><br><span class=\"line\">    targetModule.mutations = newModule.mutations</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.getters) &#123;</span><br><span class=\"line\">    targetModule.getters = newModule.getters</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.modules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> newModule.modules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(targetModule.modules &amp;&amp; targetModule.modules[key])) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.warn(</span><br><span class=\"line\">          <span class=\"string\">`[vuex] trying to add a new module '<span class=\"subst\">$&#123;key&#125;</span>' on hot reloading, `</span> +</span><br><span class=\"line\">          <span class=\"string\">'manual reload is needed'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      updateModule(targetModule.modules[key], newModule.modules[key])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>首先我们对 newOptions 对象的 actions、mutations 以及 getters 做了判断，如果有这些属性的话则替换 targetModule（当前 Store 的 options）对应的属性。最后判断如果 newOptions 包含 modules 这个 key，则遍历这个 modules 对象，如果 modules 对应的 key 不在之前的 modules 中，则报一条警告，因为这是添加一个新的 module ，需要手动重新加载。如果 key 在之前的 modules，则递归调用 updateModule，热更新子模块。</p>\n<p>调用完 updateModule 后，回到 hotUpdate 函数，接着调用 resetStore 方法重新设置 store，刚刚我们已经介绍过了。</p>\n<h4 id=\"replaceState\">replaceState<a href=\"post/2018-07-26-Vuex源码分析#replaceState\"></a></h4><p>replaceState的作用是替换整个 rootState，一般在用于调试，来看一下它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">replaceState (state) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._vm.state = state</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>函数非常简单，就是调用 this._withCommit 方法修改 Store 的 rootState，之所以提供这个 API 是由于在我们是不能在 muations 的回调函数外部去改变 state。</p>\n<p>到此为止，API 部分介绍完了，其实整个 Vuex 源码下的 src/index.js 文件里的代码基本都过了一遍。</p>\n<h3 id=\"辅助函数\">辅助函数<a href=\"post/2018-07-26-Vuex源码分析#辅助函数\"></a></h3><p>Vuex 除了提供我们 Store 对象外，还对外提供了一系列的辅助函数，方便我们在代码中使用 Vuex，提供了操作 store 的各种属性的一系列语法糖，下面我们来一起看一下：</p>\n<h4 id=\"mapState\">mapState<a href=\"post/2018-07-26-Vuex源码分析#mapState\"></a></h4><p>mapState 工具函数会将 store 中的 state 映射到局部计算属性中。为了更好理解它的实现，先来看一下它的使用示例：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vuex 提供了独立的构建工具函数 Vuex.mapState</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可以让代码非常简洁</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传入字符串 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">    countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态</span></span><br><span class=\"line\">    countPlusLocalState (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>当计算属性名称和状态子树名称对应相同时，我们可以向 mapState 工具函数传入一个字符串数组。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.count 到 this.$store.state.count</span></span><br><span class=\"line\">  <span class=\"string\">'count'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></div></figure>\n<p>通过例子我们可以直观的看到，mapState 函数可以接受一个对象，也可以接收一个数组，那它底层到底干了什么事呢，我们一起来看一下源码这个函数的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapState</span> (<span class=\"params\">states</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(states).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedState</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val === <span class=\"string\">'function'</span></span><br><span class=\"line\">        ? val.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.$store.state, <span class=\"keyword\">this</span>.$store.getters)</span><br><span class=\"line\">        : <span class=\"keyword\">this</span>.$store.state[val]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>函数首先对传入的参数调用 normalizeMap 方法，我们来看一下这个函数的定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalizeMap</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(map)</span><br><span class=\"line\">    ? map.map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> (&#123; key, <span class=\"attr\">val</span>: key &#125;))</span><br><span class=\"line\">    : <span class=\"built_in\">Object</span>.keys(map).map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> (&#123; key, <span class=\"attr\">val</span>: map[key] &#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个方法判断参数 map 是否为数组，如果是数组，则调用数组的 map 方法，把数组的每个元素转换成一个 {key, val: key}的对象；否则传入的 map 就是一个对象（从 mapState 的使用场景来看，传入的参数不是数组就是对象），我们调用 Object.keys 方法遍历这个 map 对象的 key，把数组的每个 key 都转换成一个 {key, val: map[key]}的对象。最后我们把这个对象数组作为 normalizeMap 的返回值。</p>\n<p>回到 mapState 函数，在调用了 normalizeMap 函数后，把传入的 states 转换成由 {key, val} 对象构成的数组，接着调用 forEach 方法遍历这个数组，构造一个新的对象，这个新对象每个元素都返回一个新的函数 mappedState，函数对 val 的类型判断，如果 val 是一个函数，则直接调用这个 val 函数，把当前 store 上的 state 和 getters 作为参数，返回值作为 mappedState 的返回值；否则直接把 this.$store.state[val] 作为 mappedState 的返回值。</p>\n<p>那么为何 mapState 函数的返回值是这样一个对象呢，因为 mapState 的作用是把全局的 state 和 getters 映射到当前组件的 computed 计算属性中，我们知道在 Vue 中 每个计算属性都是一个函数。</p>\n<p>为了更加直观地说明，回到刚才的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可以让代码非常简洁</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传入字符串 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">    countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态</span></span><br><span class=\"line\">    countPlusLocalState (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>经过 mapState 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count() &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    countAlias() &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state[<span class=\"string\">'count'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    countPlusLocalState() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>我们再看一下 mapState 参数为数组的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.count 到 this.$store.state.count</span></span><br><span class=\"line\">  <span class=\"string\">'count'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></div></figure>\n<p>经过 mapState 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  count() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state[<span class=\"string\">'count'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"mapGetters\">mapGetters<a href=\"post/2018-07-26-Vuex源码分析#mapGetters\"></a></h4><p>mapGetters 工具函数会将 store 中的 getter 映射到局部计算属性中。它的功能和 mapState 非常类似，我们来直接看它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapGetters</span> (<span class=\"params\">getters</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(getters).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedGetter</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(val <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.$store.getters)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown getter: <span class=\"subst\">$&#123;val&#125;</span>`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[val]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>mapGetters 的实现也和 mapState 很类似，不同的是它的 val 不能是函数，只能是一个字符串，而且会检查 val in this.$store.getters 的值，如果为 false 会输出一条错误日志。为了更直观地理解，我们来看一个简单的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用对象扩展操作符把 getter 混入到 computed 中</span></span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\">      <span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>经过 mapGetters 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    doneTodosCount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[<span class=\"string\">'doneTodosCount'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    anotherGetter() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[<span class=\"string\">'anotherGetter'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>再看一个参数 mapGetters 参数是对象的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapGetters(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.doneCount 到 store.getters.doneTodosCount</span></span><br><span class=\"line\">  doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>经过 mapGetters 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  doneCount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[<span class=\"string\">'doneTodosCount'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"mapActions\">mapActions<a href=\"post/2018-07-26-Vuex源码分析#mapActions\"></a></h4><p>mapActions 工具函数会将 store 中的 dispatch 方法映射到组件的 methods 中。和 mapState、mapGetters 也类似，只不过它映射的地方不是计算属性，而是组件的 methods 对象上。我们来直接看它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapActions</span> (<span class=\"params\">actions</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(actions).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedAction</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.dispatch.apply(<span class=\"keyword\">this</span>.$store, [val].concat(args))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>可以看到，函数的实现套路和 mapState、mapGetters 差不多，甚至更简单一些， 实际上就是做了一层函数包装。为了更直观地理解，我们来看一个简单的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 到 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() to this.$store.dispatch('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>经过 mapActions 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.dispatch.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    add(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.dispatch.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"mapMutations\">mapMutations<a href=\"post/2018-07-26-Vuex源码分析#mapMutations\"></a></h4><p>mapMutations 工具函数会将 store 中的 commit 方法映射到组件的 methods 中。和 mapActions 的功能几乎一样，我们来直接看它的实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapMutations</span> (<span class=\"params\">mutations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(mutations).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedMutation</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.commit.apply(<span class=\"keyword\">this</span>.$store, [val].concat(args))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>函数的实现几乎也和 mapActions 一样，唯一差别就是映射的是 store 的 commit 方法。为了更直观地理解，我们来看一个简单的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 到 this.$store.commit('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 到 this.$store.commit('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>经过 mapMutations 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.commit.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    add(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.commit.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"插件\">插件<a href=\"post/2018-07-26-Vuex源码分析#插件\"></a></h3><p>Vuex 的 store 接收 plugins 选项，一个 Vuex 的插件就是一个简单的方法，接收 store 作为唯一参数。插件作用通常是用来监听每次 mutation 的变化，来做一些事情。</p>\n<p>在 store 的构造函数的最后，我们通过如下代码调用插件：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> devtoolPlugin <span class=\"keyword\">from</span> <span class=\"string\">'./plugins/devtool'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apply plugins</span></span><br><span class=\"line\">plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></div></figure>\n<p>我们通常实例化 store 的时候，还会调用 logger 插件，代码如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createLogger <span class=\"keyword\">from</span> <span class=\"string\">'vuex/dist/logger'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> debug = process.env.NODE_ENV !== <span class=\"string\">'production'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  plugins: debug ? [createLogger()] : []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>在上述 2 个例子中，我们分别调用了 devtoolPlugin 和 createLogger() 2 个插件，它们是 Vuex 内置插件，我们接下来分别看一下他们的实现。</p>\n<h4 id=\"devtoolPlugin\">devtoolPlugin<a href=\"post/2018-07-26-Vuex源码分析#devtoolPlugin\"></a></h4><p>devtoolPlugin 主要功能是利用 Vue 的开发者工具和 Vuex 做配合，通过开发者工具的面板展示 Vuex 的状态。它的源码在 src/plugins/devtool.js 中，来看一下这个插件到底做了哪些事情。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> devtoolHook =</span><br><span class=\"line\">  <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> &amp;&amp;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.__VUE_DEVTOOLS_GLOBAL_HOOK__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">devtoolPlugin</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!devtoolHook) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  store._devtoolHook = devtoolHook</span><br><span class=\"line\"></span><br><span class=\"line\">  devtoolHook.emit(<span class=\"string\">'vuex:init'</span>, store)</span><br><span class=\"line\"></span><br><span class=\"line\">  devtoolHook.on(<span class=\"string\">'vuex:travel-to-state'</span>, targetState =&gt; &#123;</span><br><span class=\"line\">    store.replaceState(targetState)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  store.subscribe(<span class=\"function\">(<span class=\"params\">mutation, state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    devtoolHook.emit(<span class=\"string\">'vuex:mutation'</span>, mutation, state)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>我们直接从对外暴露的 devtoolPlugin 函数看起，函数首先判断了devtoolHook 的值，如果我们浏览器装了 Vue 开发者工具，那么在 window 上就会有一个 <code>__VUE_DEVTOOLS_GLOBAL_HOOK__</code> 的引用， 那么这个 devtoolHook 就指向这个引用。</p>\n<p>接下来通过 devtoolHook.emit(‘vuex:init’, store) 派发一个 Vuex 初始化的事件，这样开发者工具就能拿到当前这个 store 实例。</p>\n<p>接下来通过 devtoolHook.on(‘vuex:travel-to-state’, targetState =&gt; { store.replaceState(targetState) })监听 Vuex 的 traval-to-state 的事件，把当前的状态树替换成目标状态树，这个功能也是利用 Vue 开发者工具替换 Vuex 的状态。</p>\n<p>最后通过 store.subscribe((mutation, state) =&gt; { devtoolHook.emit(‘vuex:mutation’, mutation, state) }) 方法订阅 store 的 state 的变化，当 store 的 mutation 提交了 state 的变化， 会触发回调函数——通过 devtoolHook 派发一个 Vuex mutation 的事件，mutation 和 rootState 作为参数，这样开发者工具就可以观测到 Vuex state 的实时变化，在面板上展示最新的状态树。</p>\n<h4 id=\"loggerPlugin\">loggerPlugin<a href=\"post/2018-07-26-Vuex源码分析#loggerPlugin\"></a></h4><p>通常在开发环境中，我们希望实时把 mutation 的动作以及 store 的 state 的变化实时输出，那么我们可以用 loggerPlugin 帮我们做这个事情。它的源码在 src/plugins/logger.js 中，来看一下这个插件到底做了哪些事情。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Credits: borrowed code from fcomb/redux-logger</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; deepCopy &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../util'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createLogger</span> (<span class=\"params\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  collapsed = true,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  transformer = state =&gt; state,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mutationTransformer = mut =&gt; mut</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> prevState = deepCopy(store.state)</span><br><span class=\"line\"></span><br><span class=\"line\">    store.subscribe(<span class=\"function\">(<span class=\"params\">mutation, state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span> === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextState = deepCopy(state)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">      <span class=\"keyword\">const</span> formattedTime = <span class=\"string\">` @ <span class=\"subst\">$&#123;pad(time.getHours(), <span class=\"number\">2</span>)&#125;</span>:<span class=\"subst\">$&#123;pad(time.getMinutes(), <span class=\"number\">2</span>)&#125;</span>:<span class=\"subst\">$&#123;pad(time.getSeconds(), <span class=\"number\">2</span>)&#125;</span>.<span class=\"subst\">$&#123;pad(time.getMilliseconds(), <span class=\"number\">3</span>)&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> formattedMutation = mutationTransformer(mutation)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> message = <span class=\"string\">`mutation <span class=\"subst\">$&#123;mutation.type&#125;</span><span class=\"subst\">$&#123;formattedTime&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> startMessage = collapsed</span><br><span class=\"line\">        ? <span class=\"built_in\">console</span>.groupCollapsed</span><br><span class=\"line\">        : <span class=\"built_in\">console</span>.group</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// render</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        startMessage.call(<span class=\"built_in\">console</span>, message)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'%c prev state'</span>, <span class=\"string\">'color: #9E9E9E; font-weight: bold'</span>, transformer(prevState))</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'%c mutation'</span>, <span class=\"string\">'color: #03A9F4; font-weight: bold'</span>, formattedMutation)</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'%c next state'</span>, <span class=\"string\">'color: #4CAF50; font-weight: bold'</span>, transformer(nextState))</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.groupEnd()</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'—— log end ——'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      prevState = nextState</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span> (<span class=\"params\">str, times</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(times + <span class=\"number\">1</span>)).join(str)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pad</span> (<span class=\"params\">num, maxLength</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> repeat(<span class=\"string\">'0'</span>, maxLength - num.toString().length) + num</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>插件对外暴露的是 createLogger 方法，它实际上接受 3 个参数，它们都有默认值，通常我们用默认值就可以。createLogger 的返回的是一个函数，当我执行 logger 插件的时候，实际上执行的是这个函数，下面来看一下这个函数做了哪些事情。</p>\n<p>函数首先执行了 let prevState = deepCopy(store.state) 深拷贝当前 store 的 rootState。这里为什么要深拷贝，因为如果是单纯的引用，那么 store.state 的任何变化都会影响这个引用，这样就无法记录上一个状态了。我们来了解一下 deepCopy 的实现，在 src/util.js 里定义：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span> (<span class=\"params\">list, f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list.filter(f)[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span> (<span class=\"params\">obj, cache = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// just return if obj is immutable value</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// if obj is hit, it is in circular structure</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hit = find(cache, c =&gt; c.original === obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hit.copy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// put the copy into cache at first</span></span><br><span class=\"line\">  <span class=\"comment\">// because we want to refer it in recursive deepCopy</span></span><br><span class=\"line\">  cache.push(&#123;</span><br><span class=\"line\">    original: obj,</span><br><span class=\"line\">    copy</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    copy[key] = deepCopy(obj[key], cache)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>deepCopy 并不陌生，很多开源库如 loadash、jQuery 都有类似的实现，原理也不难理解，主要是构造一个新的对象，遍历原对象或者数组，递归调用 deepCopy。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过<code>find(cache, c =&gt; c.original === obj)</code>发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。</p>\n<p>回到 loggerPlugin 函数，通过 deepCopy 拷贝了当前 state 的副本并用 prevState 变量保存，接下来调用 store.subscribe 方法订阅 store 的 state 的变。 在回调函数中，也是先通过 deepCopy 方法拿到当前的 state 的副本，并用 nextState 变量保存。接下来获取当前格式化时间已经格式化的 mutation 变化的字符串，然后利用 console.group 以及 console.log 分组输出 prevState、mutation以及 nextState，这里可以通过我们 createLogger 的参数 collapsed、transformer 以及 mutationTransformer 来控制我们最终 log 的显示效果。在函数的最后，我们把 nextState 赋值给 prevState，便于下一次 mutation。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://github.com/DDFE/DDFE-blog/issues/8\" target=\"_blank\" rel=\"noopener\">Vuex 2.0 源码分析</a></p>\n</blockquote>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>Vuex 的源码托管在 github，我们首先通过 git 把代码 clone 到本地，选一款适合自己的 IDE 打开源码，展开 src 目录，如下图所示：</p>\n<p><img src=\"https://camo.githubusercontent.com/4c0c82eb95a6d128f80355522e266fe5220ca863/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565785f7372632e706e67\" alt=\"\"></p>\n<p>src 目录下的文件并不多，包含几个 js 文件和 plugins 目录， plugins 目录里面包含 2 个 Vuex 的内置插件，整个源码加起来不过 500-600 行，可谓非常轻巧的一个库。</p>\n<p>麻雀虽小，五脏俱全，我们先直观的感受一下源码的结构，接下来看一下其中的实现细节。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>本文的源码分析过程不会是自上而下的给代码加注释，我更倾向于是从 Vuex 提供的 API 和我们的使用方法等维度去分析。Vuex 的源码是基于 es6 的语法编写的，对于不了解 es6 的同学，建议还是先学习一下 es6。</p>\n<h3 id=\"从入口开始\"><a href=\"#从入口开始\" class=\"headerlink\" title=\"从入口开始\"></a>从入口开始</h3><p>看源码一般是从入口开始，Vuex 源码的入口是 src/index.js，先来打开这个文件。</p>\n<p>我们首先看这个库的 export ，在 index.js 代码最后。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  Store,</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  mapState,</span><br><span class=\"line\">  mapMutations,</span><br><span class=\"line\">  mapGetters,</span><br><span class=\"line\">  mapActions</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里可以一目了然地看到 Vuex 对外暴露的 API。其中, Store 是 Vuex 提供的状态存储类，通常我们使用 Vuex 就是通过创建 Store 的实例，稍后我们会详细介绍。接着是 install 方法，这个方法通常是我们编写第三方 Vue 插件的“套路”，先来看一下“套路”代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">      <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// auto install in dist mode</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">window</span>.Vue) &#123;</span><br><span class=\"line\">  install(<span class=\"built_in\">window</span>.Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们实现了一个 install 方法，这个方法当我们全局引用 Vue ，也就是 window 上有 Vue 对象的时候，会手动调用 install 方法，并传入 Vue 的引用；当 Vue 通过 npm 安装到项目中的时候，我们在代码中引入第三方 Vue 插件通常会编写如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<p>当我们执行 Vue.use(Vuex) 这句代码的时候，实际上就是调用了 install 的方法并传入 Vue 的引用。install 方法顾名思义，现在让我们来看看它的实现。它接受了一个参数 _Vue，函数体首先判断 Vue ，这个变量的定义在 index.js 文件的开头部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Vue <span class=\"comment\">// bind on install</span></span><br></pre></td></tr></table></figure>\n<p>对 Vue 的判断主要是保证 install 方法只执行一次，这里把 install 方法的参数 _Vue 对象赋值给 Vue 变量，这样我们就可以在 index.js 文件的其它地方使用 Vue 这个变量了。install 方法的最后调用了 applyMixin 方法，我们顺便来看一下这个方法的实现，在 src/mixin.js 文件里定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">    <span class=\"comment\">// store injection</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的作用就是在 Vue 的生命周期中的初始化（1.0 版本是 init，2.0 版本是 beforeCreated）钩子前插入一段 Vuex 初始化代码。这里做的事情很简单——给 Vue 的实例注入一个 <code>$store</code> 的属性，这也就是为什么我们在 Vue 的组件中可以通过 <code>this.$store.xxx</code> 访问到 Vuex 的各种数据和状态。</p>\n<h3 id=\"认识-Store-构造函数\"><a href=\"#认识-Store-构造函数\" class=\"headerlink\" title=\"认识 Store 构造函数\"></a>认识 Store 构造函数</h3><p>我们在使用 Vuex 的时候，通常会实例化 Store 类，然后传入一个对象，包括我们定义好的 actions、getters、mutations、state等，甚至当我们有多个子模块的时候，我们可以添加一个 modules 对象。那么实例化的时候，到底做了哪些事情呢？带着这个疑问，让我们回到 index.js 文件，重点看一下 Store 类的定义。Store 类定义的代码略长，我不会一下就贴上所有代码，我们来拆解分析它，首先看一下构造函数的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Store</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    assert(Vue, <span class=\"string\">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class=\"line\">    assert(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span>, <span class=\"string\">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      state = &#123;&#125;,</span><br><span class=\"line\">      plugins = [],</span><br><span class=\"line\">      strict = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125; = options</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// store internal state</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._options = options</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._committing = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._runtimeModules = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._subscribers = []</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._watcherVM = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// bind commit and dispatch to self</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dispatch = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundDispatch</span> (<span class=\"params\">type, payload</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dispatch.call(store, type, payload)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.commit = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundCommit</span> (<span class=\"params\">type, payload, options</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> commit.call(store, type, payload, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// strict mode</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strict = strict</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// init root module.</span></span><br><span class=\"line\">    <span class=\"comment\">// this also recursively registers all sub-modules</span></span><br><span class=\"line\">    <span class=\"comment\">// and collects all module getters inside this._wrappedGetters</span></span><br><span class=\"line\">    installModule(<span class=\"keyword\">this</span>, state, [], options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class=\"line\">    <span class=\"comment\">// (also registers _wrappedGetters as computed properties)</span></span><br><span class=\"line\">    resetStoreVM(<span class=\"keyword\">this</span>, state)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// apply plugins</span></span><br><span class=\"line\">    plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造函数的一开始就用了“断言函数”，来判断是否满足一些条件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert(Vue, <span class=\"string\">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br></pre></td></tr></table></figure>\n<p>这行代码的目的是确保 Vue 的存在，也就是在我们实例化 Store 之前，必须要保证之前的 install 方法已经执行了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span>, <span class=\"string\">`vuex requires a Promise polyfill in this browser.`</span>)</span><br></pre></td></tr></table></figure>\n<p>这行代码的目的是为了确保 Promsie 可以使用的，因为 Vuex 的源码是依赖 Promise 的。Promise 是 es6 提供新的 API，由于现在的浏览器并不是都支持 es6 语法的，所以通常我们会用 babel 编译我们的代码，如果想使用 Promise 这个 特性，我们需要在 package.json 中添加对 babel-polyfill 的依赖并在代码的入口加上 import ‘babel-polyfill’ 这段代码。</p>\n<p>再来看看 assert 这个函数，它并不是浏览器原生支持的，它的实现在 src/util.js 里，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常简单，对 condition 判断，如果不不为真，则抛出异常。这个函数虽然简单，但这种编程方式值得我们学习。</p>\n<p>再来看构造函数接下来的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  state = &#123;&#125;,</span><br><span class=\"line\">  plugins = [],</span><br><span class=\"line\">  strict = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125; = options</span><br></pre></td></tr></table></figure>\n<p>这里就是利用 es6 的解构赋值拿到 options 里的 state，plugins 和 strict。state 表示 rootState，plugins 表示应用的插件、strict 表示是否开启严格模式。</p>\n<p>接着往下看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// store internal state</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._options = options</span><br><span class=\"line\"><span class=\"keyword\">this</span>._committing = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._runtimeModules = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>._subscribers = []</span><br><span class=\"line\"><span class=\"keyword\">this</span>._watcherVM = <span class=\"keyword\">new</span> Vue()</span><br></pre></td></tr></table></figure>\n<p>这里主要是创建一些内部的属性：<br>this._options 存储参数 options。<br>this._committing 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state。<br>this._actions 用来存储用户定义的所有的 actions。<br>this._mutations 用来存储用户定义所有的 mutatins。<br>this._wrappedGetters 用来存储用户定义的所有 getters 。<br>this._runtimeModules 用来存储所有的运行时的 modules。<br>this._subscribers 用来存储所有对 mutation 变化的订阅者。<br>this._watcherVM 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化的。</p>\n<p>继续往下看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind commit and dispatch to self</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.dispatch = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundDispatch</span> (<span class=\"params\">type, payload</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch.call(store, type, payload)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.commit = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundCommit</span> (<span class=\"params\">type, payload, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> commit.call(store, type, payload, options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// strict mode</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.strict = strict</span><br></pre></td></tr></table></figure>\n<p>这里的代码也不难理解，把 Store 类的 dispatch 和 commit 的方法的 this 指针指向当前 store 的实例上，dispatch 和 commit 的实现我们稍后会分析。this.strict 表示是否开启严格模式，在严格模式下会观测所有的 state 的变化，建议在开发环境时开启严格模式，线上环境要关闭严格模式，否则会有一定的性能开销。</p>\n<h3 id=\"Vuex-的初始化核心\"><a href=\"#Vuex-的初始化核心\" class=\"headerlink\" title=\"Vuex 的初始化核心\"></a>Vuex 的初始化核心</h3><h4 id=\"installModule\"><a href=\"#installModule\" class=\"headerlink\" title=\"installModule\"></a>installModule</h4><p>我们接着往下看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// init root module.</span></span><br><span class=\"line\"><span class=\"comment\">// this also recursively registers all sub-modules</span></span><br><span class=\"line\"><span class=\"comment\">// and collects all module getters inside this._wrappedGetters</span></span><br><span class=\"line\">installModule(<span class=\"keyword\">this</span>, state, [], options)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class=\"line\"><span class=\"comment\">// (also registers _wrappedGetters as computed properties)</span></span><br><span class=\"line\">resetStoreVM(<span class=\"keyword\">this</span>, state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apply plugins</span></span><br><span class=\"line\">plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></figure>\n<p>这段代码是 Vuex 的初始化的核心，其中，installModule 方法是把我们通过 options 传入的各种属性模块注册和安装；resetStoreVM 方法是初始化 store._vm，观测 state 和 getters 的变化；最后是应用传入的插件。</p>\n<p>下面，我们先来看一下 installModule 的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">installModule</span> (<span class=\"params\">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isRoot = !path.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    state,</span><br><span class=\"line\">    actions,</span><br><span class=\"line\">    mutations,</span><br><span class=\"line\">    getters,</span><br><span class=\"line\">    modules</span><br><span class=\"line\">  &#125; = <span class=\"built_in\">module</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set state</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mutations) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(mutations).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">      registerMutation(store, key, mutations[key], path)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (actions) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(actions).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">      registerAction(store, key, actions[key], path)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (getters) &#123;</span><br><span class=\"line\">    wrapGetters(store, getters, path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (modules) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(modules).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">      installModule(store, rootState, path.concat(key), modules[key], hot)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>installModule 函数可接收5个参数，store、rootState、path、module、hot，store 表示当前 Store 实例，rootState 表示根 state，path 表示当前嵌套模块的路径数组，module 表示当前安装的模块，hot 当动态改变 modules 或者热更新的时候为 true。</p>\n<p>先来看这部分代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isRoot = !path.length</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  state,</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  mutations,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  modules</span><br><span class=\"line\">&#125; = <span class=\"built_in\">module</span></span><br></pre></td></tr></table></figure>\n<p>代码首先通过 path 数组的长度判断是否为根。我们在构造函数调用的时候是 installModule(this, state, [], options)，所以这里 isRoot 为 true。module 为传入的 options，我们拿到了 module 下的 state、actions、mutations、getters 以及嵌套的 modules。</p>\n<p>接着看下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set state</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">  store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里判断当不为根且非热更新的情况，然后设置级联状态，这里乍一看不好理解，我们先放一放，稍后来回顾。</p>\n<p>再往下看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mutations) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(mutations).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    registerMutation(store, key, mutations[key], path)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actions) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(actions).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    registerAction(store, key, actions[key], path)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (getters) &#123;</span><br><span class=\"line\">  wrapGetters(store, getters, path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里分别是对 mutations、actions、getters 进行注册，如果我们实例化 Store 的时候通过 options 传入这些对象，那么会分别进行注册，我稍后再去介绍注册的具体实现。那么到这，如果 Vuex 没有 module ，这个 installModule 方法可以说已经做完了。但是 Vuex 巧妙了设计了 module 这个概念，因为 Vuex 本身是单一状态树，应用的所有状态都包含在一个大对象内，随着我们应用规模的不断增长，这个 Store 变得非常臃肿。为了解决这个问题，Vuex 允许我们把 store 分 module（模块）。每一个模块包含各自的 state、mutations、actions 和 getters，甚至是嵌套模块。所以，接下来还有一行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (modules) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(modules).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    installModule(store, rootState, path.concat(key), modules[key], hot)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里通过遍历 modules，递归调用 installModule 去安装子模块。这里传入了 store、rootState、path.concat(key)、和 modules[key]，和刚才不同的是，path 不为空，module 对应为子模块，那么我们回到刚才那段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set state</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">  store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当递归初始化子模块的时候，isRoot 为 false，注意这里有个方法getNestedState(rootState, path)，来看一下 getNestedState 函数的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNestedState</span> (<span class=\"params\">state, path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> path.length</span><br><span class=\"line\">    ? path.reduce(<span class=\"function\">(<span class=\"params\">state, key</span>) =&gt;</span> state[key], state)</span><br><span class=\"line\">    : state</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法很简单，就是根据 path 查找 state 上的嵌套 state。在这里就是传入 rootState 和 path，计算出当前模块的父模块的 state，由于模块的 path 是根据模块的名称 concat 连接的，所以 path 的最后一个元素就是当前模块的模块名，最后调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>把当前模块的 state 添加到 parentState 中。<br>这里注意一下我们用了 store._withCommit 方法，来看一下这个方法的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于我们是在修改 state，Vuex 中所有对 state 的修改都会用 _withCommit函数包装，保证在同步修改 state 的过程中 this._committing 的值始终为true。这样当我们观测 state 的变化时，如果 this._committing 的值不为 true，则能检查到这个状态修改是有问题的。</p>\n<p>看到这里，有些同学可能会有点困惑，举个例子来直观感受一下，以 Vuex 源码中的 example/shopping-cart 为例，打开 store/index.js，有这么一段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    cart,</span><br><span class=\"line\">    products</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  strict: debug,</span><br><span class=\"line\">  plugins: debug ? [createLogger()] : []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里有两个子 module，cart 和 products，我们打开 store/modules/cart.js，看一下 cart 模块中的 state 定义，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  added: [],</span><br><span class=\"line\">  checkoutStatus: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们运行这个项目，打开浏览器，利用 Vue 的调试工具来看一下 Vuex 中的状态，如下图所示：</p>\n<p><img src=\"https://camo.githubusercontent.com/2bd2ed9ea9f74792db15c5980666275330ab64a2/687474703a2f2f7374617469632e67616c696c656f2e7869616f6a756b656a692e636f6d2f7374617469632f746d732f736869656c642f767565782d746573742e706e67\" alt=\"\"></p>\n<p>可以看到，在 rootState 下，分别有 cart 和 products 2个属性，key 根据模块名称而来，value 就是在每个模块文件中定义的 state，这就把模块 state 挂载到 rootState 上了。</p>\n<p>我们了解完嵌套模块 state 是怎么一回事后，我们回过头来看一下 installModule 过程中的其它 3 个重要方法：registerMutation、registerAction 和 wrapGetters。顾名思义，这 3 个方法分别处理 mutations、actions 和 getters。我们先来看一下 registerMutation 的定义：</p>\n<h4 id=\"registerMutation\"><a href=\"#registerMutation\" class=\"headerlink\" title=\"registerMutation\"></a>registerMutation</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerMutation</span> (<span class=\"params\">store, type, handler, path = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedMutationHandler</span> (<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">    handler(getNestedState(store.state, path), payload)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>registerMutation 是对 store 的 mutation 的初始化，它接受 4 个参数，store为当前 Store 实例，type为 mutation 的 key，handler 为 mutation 执行的回调函数，path 为当前模块的路径。mutation 的作用就是同步修改当前模块的 state ，函数首先通过 type 拿到对应的 mutation 对象数组， 然后把一个 mutation 的包装函数 push 到这个数组中，这个函数接收一个参数 payload，这个就是我们在定义 mutation 的时候接收的额外参数。这个函数执行的时候会调用 mutation 的回调函数，并通过 getNestedState(store.state, path) 方法得到当前模块的 state，和 playload 一起作为回调函数的参数。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, n) &#123;</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了一个 mutation，通过刚才的 registerMutation 方法，我们注册了这个 mutation，这里的 state 对应的就是当前模块的 state，n 就是额外参数 payload，接下来我们会从源码分析的角度来介绍这个 mutation 的回调是何时被调用的，参数是如何传递的。</p>\n<p>我们有必要知道 mutation 的回调函数的调用时机，在 Vuex 中，mutation 的调用是通过 store 实例的 API 接口 commit 来调用的，来看一下 commit 函数的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit (type, payload, options) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style commit</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class=\"line\">    options = payload</span><br><span class=\"line\">    payload = type</span><br><span class=\"line\">    type = type.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mutation = &#123; type, payload &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._mutations[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown mutation type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    entry.forEach(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitIterator</span> (<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">      handler(payload)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options || !options.silent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._subscribers.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> sub(mutation, <span class=\"keyword\">this</span>.state))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>commit 支持 3 个参数，type 表示 mutation 的类型，payload 表示额外的参数，options 表示一些配置，比如 silent 等，稍后会用到。commit 函数首先对 type 的类型做了判断，处理了 type 为 object 的情况，接着根据 type 去查找对应的 mutation，如果找不到，则输出一条错误信息，否则遍历这个 type 对应的 mutation 对象数组，执行 handler(payload) 方法，这个方法就是之前定义的 wrappedMutationHandler(handler)，执行它就相当于执行了 registerMutation 注册的回调函数，并把当前模块的 state 和 额外参数 payload 作为参数传入。注意这里我们依然使用了 this._withCommit 的方法提交 mutation。commit 函数的最后，判断如果不是静默模式，则遍历 this._subscribers，调用回调函数，并把 mutation 和当前的根 state 作为参数传入。那么这个 this._subscribers 是什么呢？原来 Vuex 的 Store 实例提供了 subscribe API 接口，它的作用是订阅（注册监听） store 的 mutation。先来看一下它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscribe (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>._subscribers</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (subs.indexOf(fn) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    subs.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> i = subs.indexOf(fn)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      subs.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>subscribe 方法很简单，他接受的参数是一个回调函数，会把这个回调函数保存到 this._subscribers 上，并返回一个函数，当我们调用这个返回的函数，就可以解除当前函数对 store 的 mutation 的监听。其实，Vuex 的内置 logger 插件就是基于 subscribe 接口实现对 store 的 muation的监听，稍后我们会详细介绍这个插件。</p>\n<h4 id=\"registerAction\"><a href=\"#registerAction\" class=\"headerlink\" title=\"registerAction\"></a>registerAction</h4><p>在了解完 registerMutation，我们再来看一下 registerAction 的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerAction</span> (<span class=\"params\">store, type, handler, path = []</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = store</span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">      dispatch,</span><br><span class=\"line\">      commit,</span><br><span class=\"line\">      getters: store.getters,</span><br><span class=\"line\">      state: getNestedState(store.state, path),</span><br><span class=\"line\">      rootState: store.state</span><br><span class=\"line\">    &#125;, payload, cb)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">      res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>registerAction 是对 store 的 action 的初始化，它和 registerMutation 的参数一致，和 mutation 不同一点，mutation 是同步修改当前模块的 state，而 action 是可以异步去修改 state，这里不要误会，在 action 的回调中并不会直接修改 state ，仍然是通过提交一个 mutation 去修改 state（在 Vuex 中，mutation 是修改 state 的唯一途径）。那我们就来看看 action 是如何做到这一点的。</p>\n<p>函数首先也是通过 type 拿到对应 action 的对象数组，然后把一个 action 的包装函数 push 到这个数组中，这个函数接收 2 个参数，payload 表示额外参数 ，cb 表示回调函数（实际上我们并没有使用它）。这个函数执行的时候会调用 action 的回调函数，传入一个 context 对象，这个对象包括了 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState 等等。接着对这个函数的返回值做判断，如果不是一个 Promise 对象，则调用 Promise.resolve（res） 给res 包装成了一个 Promise 对象。这里也就解释了为何 Vuex 的源码依赖 Promise，这里对 Promise 的判断也和简单，参考代码 src/util.js，对 isPromise 的判断如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPromise</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val &amp;&amp; <span class=\"keyword\">typeof</span> val.then === <span class=\"string\">'function'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实就是简单的检查对象的 then 方法，如果包含说明就是一个 Promise 对象。</p>\n<p>接着判断 store._devtoolHook，这个只有当用到 Vuex devtools 开启的时候，我们才能捕获 promise 的过程中的 。 action 的包装函数最后返回 res ，它就是一个地地道道的 Promise 对象。来看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  checkout (&#123; commit, state &#125;, payload) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把当前购物车的商品备份起来</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> savedCartItems = [...state.cart.added]</span><br><span class=\"line\">    <span class=\"comment\">// 发送结帐请求，并愉快地清空购物车</span></span><br><span class=\"line\">    commit(types.CHECKOUT_REQUEST)</span><br><span class=\"line\">    <span class=\"comment\">// 购物 API 接收一个成功回调和一个失败回调</span></span><br><span class=\"line\">    shop.buyProducts(</span><br><span class=\"line\">      products,</span><br><span class=\"line\">      <span class=\"comment\">// 成功操作</span></span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class=\"line\">      <span class=\"comment\">// 失败操作</span></span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了一个 action，通过刚才的 registerAction 方法，我们注册了这个 action，这里的 commit 就是 store 的 API 接口，可以通过它在 action 里提交一个 mutation。state 对应的就是当前模块的 state，我们在这个 action 里即可以同步提交 mutation，也可以异步提交。接下来我们会从源码分析的角度来介绍这个 action 的回调是何时被调用的，参数是如何传递的。</p>\n<p>我们有必要知道 action 的回调函数的调用时机，在 Vuex 中，action 的调用是通过 store 实例的 API 接口 dispatch 来调用的，来看一下 dispatch 函数的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch (type, payload) &#123;</span><br><span class=\"line\"><span class=\"comment\">// check object-style dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class=\"line\">    payload = type</span><br><span class=\"line\">    type = type.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._actions[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown action type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> entry.length &gt; <span class=\"number\">1</span></span><br><span class=\"line\">    ? <span class=\"built_in\">Promise</span>.all(entry.map(<span class=\"function\"><span class=\"params\">handler</span> =&gt;</span> handler(payload)))</span><br><span class=\"line\">    : entry[<span class=\"number\">0</span>](payload)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>dispatch 支持2个参数，type 表示 action 的类型，payload 表示额外的参数。前面几行代码和 commit 接口非常类似，都是找到对应 type 下的 action 对象数组，唯一和 commit 不同的地方是最后部分，它对 action 的对象数组长度做判断，如果长度为 1 则直接调用<code>entry[0](payload)</code>， 这个方法就是之前定义的 wrappedActionHandler(payload, cb)，执行它就相当于执行了 registerAction 注册的回调函数，并把当前模块的 context 和 额外参数 payload 作为参数传入。所以我们在 action 的回调函数里，可以拿到当前模块的上下文包括 store 的 commit 和 dispatch 方法、getter、当前模块的 state 和 rootState，可见 action 是非常灵活的。</p>\n<h4 id=\"wrapGetters\"><a href=\"#wrapGetters\" class=\"headerlink\" title=\"wrapGetters\"></a>wrapGetters</h4><p>了解完 registerAction 后，我们来看看 wrapGetters的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapGetters</span> (<span class=\"params\">store, moduleGetters, modulePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(moduleGetters).forEach(<span class=\"function\"><span class=\"params\">getterKey</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rawGetter = moduleGetters[getterKey]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (store._wrappedGetters[getterKey]) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] duplicate getter key: <span class=\"subst\">$&#123;getterKey&#125;</span>`</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    store._wrappedGetters[getterKey] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedGetter</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> rawGetter(</span><br><span class=\"line\">        getNestedState(store.state, modulePath), <span class=\"comment\">// local state</span></span><br><span class=\"line\">        store.getters, <span class=\"comment\">// getters</span></span><br><span class=\"line\">        store.state <span class=\"comment\">// root state</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>wrapGetters 是对 store 的 getters 初始化，它接受 3个 参数， store 表示当前 Store 实例，moduleGetters 表示当前模块下的所有 getters, modulePath 对应模块的路径。细心的同学会发现，和刚才的 registerMutation 以及 registerAction 不同，这里对 getters 的循环遍历是放在了函数体内，并且 getters 和它们的一个区别是不允许 getter 的 key 有重复。</p>\n<p>这个函数做的事情就是遍历 moduleGetters，把每一个 getter 包装成一个方法，添加到 store._wrappedGetters 对象中，注意 getter 的 key 是不允许重复的。在这个包装的方法里，会执行 getter 的回调函数，并把当前模块的 state，store 的 getters 和 store 的 rootState 作为它参数。来看一个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> cartProducts = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> state.cart.added.map(<span class=\"function\">(<span class=\"params\">&#123; id, quantity &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> product = state.products.all.find(<span class=\"function\"><span class=\"params\">p</span> =&gt;</span> p.id === id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      title: product.title,</span><br><span class=\"line\">      price: product.price,</span><br><span class=\"line\">      quantity</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了一个 getter，通过刚才的 wrapGetters 方法，我们把这个 getter 添加到 store._wrappedGetters 对象里，这和回调函数的参数 state 对应的就是当前模块的 state，接下来我们从源码的角度分析这个函数是如何被调用，参数是如何传递的。</p>\n<p>我们有必要知道 getter 的回调函数的调用时机，在 Vuex 中，我们知道当我们在组件中通过 <code>this.$store.getters.xxxgetters</code> 可以访问到对应的 getter 的回调函数，那么我们需要把对应 getter 的包装函数的执行结果绑定到 <code>this.$store</code> 上。这部分的逻辑就在 resetStoreVM 函数里。我们在 Store 的构造函数中，在执行完 installModule 方法后，就会执行 resetStoreVM 方法。来看一下它的定义：</p>\n<h4 id=\"resetStoreVM\"><a href=\"#resetStoreVM\" class=\"headerlink\" title=\"resetStoreVM\"></a>resetStoreVM</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetStoreVM</span> (<span class=\"params\">store, state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldVm = store._vm</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// bind store public getters</span></span><br><span class=\"line\">  store.getters = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrappedGetters = store._wrappedGetters</span><br><span class=\"line\">  <span class=\"keyword\">const</span> computed = &#123;&#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(wrappedGetters).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = wrappedGetters[key]</span><br><span class=\"line\">    <span class=\"comment\">// use computed to leverage its lazy-caching mechanism</span></span><br><span class=\"line\">    computed[key] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn(store)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">      get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store._vm[key]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// use a Vue instance to store the state tree</span></span><br><span class=\"line\">  <span class=\"comment\">// suppress warnings just in case the user has added</span></span><br><span class=\"line\">  <span class=\"comment\">// some funky global mixins</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> silent = Vue.config.silent</span><br><span class=\"line\">  Vue.config.silent = <span class=\"literal\">true</span></span><br><span class=\"line\">  store._vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    data: &#123; state &#125;,</span><br><span class=\"line\">    computed</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  Vue.config.silent = silent</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// enable strict mode for new vm</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store.strict) &#123;</span><br><span class=\"line\">    enableStrictMode(store)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldVm) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// dispatch changes in all subscribed watchers</span></span><br><span class=\"line\">    <span class=\"comment\">// to force getter re-evaluation.</span></span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      oldVm.state = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法主要是重置一个私有的 _vm 对象，它是一个 Vue 的实例。这个 _vm 对象会保留我们的 state 树，以及用计算属性的方式存储了 store 的 getters。来具体看看它的实现过程。我们把这个函数拆成几个部分来分析：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oldVm = store._vm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bind store public getters</span></span><br><span class=\"line\">store.getters = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> wrappedGetters = store._wrappedGetters</span><br><span class=\"line\"><span class=\"keyword\">const</span> computed = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(wrappedGetters).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = wrappedGetters[key]</span><br><span class=\"line\">  <span class=\"comment\">// use computed to leverage its lazy-caching mechanism</span></span><br><span class=\"line\">  computed[key] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn(store)</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store._vm[key]</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这部分留了现有的 store._vm 对象，接着遍历 store._wrappedGetters 对象，在遍历过程中，依次拿到每个 getter 的包装函数，并把这个包装函数执行的结果用 computed 临时变量保存。接着用 es5 的 Object.defineProperty 方法为 store.getters 定义了 get 方法，也就是当我们在组件中调用<code>this.$store.getters.xxxgetters</code>这个方法的时候，会访问 store._vm[xxxgetters]。我们接着往下看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// use a Vue instance to store the state tree</span></span><br><span class=\"line\"><span class=\"comment\">// suppress warnings just in case the user has added</span></span><br><span class=\"line\"><span class=\"comment\">// some funky global mixins</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> silent = Vue.config.silent</span><br><span class=\"line\">Vue.config.silent = <span class=\"literal\">true</span></span><br><span class=\"line\">store._vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123; state &#125;,</span><br><span class=\"line\">  computed</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Vue.config.silent = silent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// enable strict mode for new vm</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (store.strict) &#123;</span><br><span class=\"line\">  enableStrictMode(store)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这部分的代码首先先拿全局 Vue.config.silent 的配置，然后临时把这个配置设成 true，接着实例化一个 Vue 的实例，把 store 的状态树 state 作为 data 传入，把我们刚才的临时变量 computed 作为计算属性传入。然后再把之前的 silent 配置重置。设置 silent 为 true 的目的是为了取消这个 _vm 的所有日志和警告。把 computed 对象作为 _vm 的 computed 属性，这样就完成了 getters 的注册。因为当我们在组件中访问 this.$store.getters.xxxgetters 的时候，就相当于访问 store._vm[xxxgetters]，也就是在访问 computed[xxxgetters]，这样就访问到了 xxxgetters 对应的回调函数了。这段代码最后判断 strict 属性决定是否开启严格模式，我们来看看严格模式都干了什么：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"string\">'state'</span>, () =&gt; &#123;</span><br><span class=\"line\">    assert(store._committing, <span class=\"string\">`Do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>严格模式做的事情很简单，监测 store._vm.state 的变化，看看 state 的变化是否通过执行 mutation 的回调函数改变，如果是外部直接修改 state，那么 store._committing 的值为 false，这样就抛出一条错误。再次强调一下，Vuex 中对 state 的修改只能在 mutation 的回调函数里。</p>\n<p>回到 resetStoreVM 函数，我们来看一下最后一部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldVm) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// dispatch changes in all subscribed watchers</span></span><br><span class=\"line\">  <span class=\"comment\">// to force getter re-evaluation.</span></span><br><span class=\"line\">  store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    oldVm.state = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的逻辑很简单，由于这个函数每次都会创建新的 Vue 实例并赋值到 store._vm 上，那么旧的 _vm 对象的状态设置为 null，并调用 $destroy 方法销毁这个旧的 _vm 对象。</p>\n<p>那么到这里，Vuex 的初始化基本告一段落了，初始化核心就是 installModule 和 resetStoreVM 函数。通过对 mutations 、actions 和 getters 的注册，我们了解到 state 的是按模块划分的，按模块的嵌套形成一颗状态树。而 actions、mutations 和 getters 的全局的，其中 actions 和 mutations 的 key 允许重复，但 getters 的 key 是不允许重复的。官方推荐我们给这些全局的对象在定义的时候加一个名称空间来避免命名冲突。<br>从源码的角度介绍完 Vuex 的初始化的玩法，我们再从 Vuex 提供的 API 方向来分析其中的源码，看看这些 API 是如何实现的。</p>\n<h3 id=\"Vuex-API-分析\"><a href=\"#Vuex-API-分析\" class=\"headerlink\" title=\"Vuex API 分析\"></a>Vuex API 分析</h3><p>Vuex 常见的 API 如 dispatch、commit 、subscribe 我们前面已经介绍过了，这里就不再赘述了，下面介绍的一些 Store 的 API，虽然不常用，但是了解一下也不错。</p>\n<h4 id=\"watch-getter-cb-options\"><a href=\"#watch-getter-cb-options\" class=\"headerlink\" title=\"watch(getter, cb, options)\"></a>watch(getter, cb, options)</h4><p>watch 作用是响应式的监测一个 getter 方法的返回值，当值改变时调用回调。getter 接收 store 的 state 作为唯一参数。来看一下它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch (getter, cb, options) &#123;</span><br><span class=\"line\">  assert(<span class=\"keyword\">typeof</span> getter === <span class=\"string\">'function'</span>, <span class=\"string\">`store.watch only accepts a function.`</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._watcherVM.$watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> getter(<span class=\"keyword\">this</span>.state), cb, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先断言 watch 的 getter 必须是一个方法，接着利用了内部一个 Vue 的实例对象 <code>this._watcherVM</code> 的 $watch 方法，观测 getter 方法返回值的变化，如果有变化则调用 cb 函数，回调函数的参数为新值和旧值。watch 方法返回的是一个方法，调用它则取消观测。</p>\n<h4 id=\"registerModule-path-module\"><a href=\"#registerModule-path-module\" class=\"headerlink\" title=\"registerModule(path, module)\"></a>registerModule(path, module)</h4><p>registerModule 的作用是注册一个动态模块，有的时候当我们异步加载一些业务的时候，可以通过这个 API 接口去动态注册模块，来看一下它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerModule (path, <span class=\"built_in\">module</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> path === <span class=\"string\">'string'</span>) path = [path]</span><br><span class=\"line\">  assert(<span class=\"built_in\">Array</span>.isArray(path), <span class=\"string\">`module path must be a string or an Array.`</span>)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._runtimeModules[path.join(<span class=\"string\">'.'</span>)] = <span class=\"built_in\">module</span></span><br><span class=\"line\">  installModule(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.state, path, <span class=\"built_in\">module</span>)</span><br><span class=\"line\">  <span class=\"comment\">// reset store to update getters...</span></span><br><span class=\"line\">  resetStoreVM(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.state)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先对 path 判断，如果 path 是一个 string 则把 path 转换成一个 Array。接着把 module 对象缓存到 this._runtimeModules 这个对象里，path 用点连接作为该对象的 key。接着和初始化 Store 的逻辑一样，调用 installModule 和 resetStoreVm 方法安装一遍动态注入的 module。</p>\n<h4 id=\"unregisterModule-path\"><a href=\"#unregisterModule-path\" class=\"headerlink\" title=\"unregisterModule(path)\"></a>unregisterModule(path)</h4><p>和 registerModule 方法相对的就是 unregisterModule 方法，它的作用是注销一个动态模块，来看一下它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unregisterModule (path) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> path === <span class=\"string\">'string'</span>) path = [path]</span><br><span class=\"line\">  assert(<span class=\"built_in\">Array</span>.isArray(path), <span class=\"string\">`module path must be a string or an Array.`</span>)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>._runtimeModules[path.join(<span class=\"string\">'.'</span>)]</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(<span class=\"keyword\">this</span>.state, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    Vue.delete(parentState, path[path.length - <span class=\"number\">1</span>])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  resetStore(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先还是对 path 的类型做了判断，这部分逻辑和注册是一样的。接着从 this._runtimeModules 里删掉以 path 点连接的 key 对应的模块。接着通过 this._withCommit 方法把当前模块的 state 对象从父 state 上删除。最后调用 resetStore(this) 方法，来看一下这个方法的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetStore</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  store._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  store._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = store.state</span><br><span class=\"line\">  <span class=\"comment\">// init root module</span></span><br><span class=\"line\">  installModule(store, state, [], store._options, <span class=\"literal\">true</span>)</span><br><span class=\"line\">  <span class=\"comment\">// init all runtime modules</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(store._runtimeModules).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    installModule(store, state, key.split(<span class=\"string\">'.'</span>), store._runtimeModules[key], <span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// reset vm</span></span><br><span class=\"line\">  resetStoreVM(store, state)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法作用就是重置 store 对象，重置 store 的 _actions、_mutations、_wrappedGetters 等等属性。然后再次调用 installModules 去重新安装一遍 Module 对应的这些属性，注意这里我们的最后一个参数 hot 为true，表示它是一次热更新。这样在 installModule 这个方法体类，如下这段逻辑就不会执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">installModule</span> (<span class=\"params\">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class=\"line\">  ... </span><br><span class=\"line\">  <span class=\"comment\">// set state</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      Vue.set(parentState, moduleName, state || &#123;&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 hot 始终为 true，这里我们就不会重新对状态树做设置，我们的 state 保持不变。因为我们已经明确的删除了对应 path 下的 state 了，要做的事情只不过就是重新注册一遍 muations、actions 以及 getters。</p>\n<p>回调 resetStore 方法，接下来遍历 this._runtimeModules 模块，重新安装所有剩余的 runtime Moudles。最后还是调用 resetStoreVM 方法去重置 Store 的 _vm 对象。</p>\n<h4 id=\"hotUpdate-newOptions\"><a href=\"#hotUpdate-newOptions\" class=\"headerlink\" title=\"hotUpdate(newOptions)\"></a>hotUpdate(newOptions)</h4><p>hotUpdate 的作用是热加载新的 action 和 mutation。 来看一下它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hotUpdate (newOptions) &#123;</span><br><span class=\"line\">  updateModule(<span class=\"keyword\">this</span>._options, newOptions)</span><br><span class=\"line\">  resetStore(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先调用 updateModule 方法去更新状态，其中当前 Store 的 opition 配置和要更新的 newOptions 会作为参数。来看一下这个函数的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateModule</span> (<span class=\"params\">targetModule, newModule</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.actions) &#123;</span><br><span class=\"line\">    targetModule.actions = newModule.actions</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.mutations) &#123;</span><br><span class=\"line\">    targetModule.mutations = newModule.mutations</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.getters) &#123;</span><br><span class=\"line\">    targetModule.getters = newModule.getters</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newModule.modules) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> newModule.modules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(targetModule.modules &amp;&amp; targetModule.modules[key])) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.warn(</span><br><span class=\"line\">          <span class=\"string\">`[vuex] trying to add a new module '<span class=\"subst\">$&#123;key&#125;</span>' on hot reloading, `</span> +</span><br><span class=\"line\">          <span class=\"string\">'manual reload is needed'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      updateModule(targetModule.modules[key], newModule.modules[key])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们对 newOptions 对象的 actions、mutations 以及 getters 做了判断，如果有这些属性的话则替换 targetModule（当前 Store 的 options）对应的属性。最后判断如果 newOptions 包含 modules 这个 key，则遍历这个 modules 对象，如果 modules 对应的 key 不在之前的 modules 中，则报一条警告，因为这是添加一个新的 module ，需要手动重新加载。如果 key 在之前的 modules，则递归调用 updateModule，热更新子模块。</p>\n<p>调用完 updateModule 后，回到 hotUpdate 函数，接着调用 resetStore 方法重新设置 store，刚刚我们已经介绍过了。</p>\n<h4 id=\"replaceState\"><a href=\"#replaceState\" class=\"headerlink\" title=\"replaceState\"></a>replaceState</h4><p>replaceState的作用是替换整个 rootState，一般在用于调试，来看一下它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">replaceState (state) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._vm.state = state</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数非常简单，就是调用 this._withCommit 方法修改 Store 的 rootState，之所以提供这个 API 是由于在我们是不能在 muations 的回调函数外部去改变 state。</p>\n<p>到此为止，API 部分介绍完了，其实整个 Vuex 源码下的 src/index.js 文件里的代码基本都过了一遍。</p>\n<h3 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h3><p>Vuex 除了提供我们 Store 对象外，还对外提供了一系列的辅助函数，方便我们在代码中使用 Vuex，提供了操作 store 的各种属性的一系列语法糖，下面我们来一起看一下：</p>\n<h4 id=\"mapState\"><a href=\"#mapState\" class=\"headerlink\" title=\"mapState\"></a>mapState</h4><p>mapState 工具函数会将 store 中的 state 映射到局部计算属性中。为了更好理解它的实现，先来看一下它的使用示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vuex 提供了独立的构建工具函数 Vuex.mapState</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可以让代码非常简洁</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传入字符串 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">    countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态</span></span><br><span class=\"line\">    countPlusLocalState (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当计算属性名称和状态子树名称对应相同时，我们可以向 mapState 工具函数传入一个字符串数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.count 到 this.$store.state.count</span></span><br><span class=\"line\">  <span class=\"string\">'count'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<p>通过例子我们可以直观的看到，mapState 函数可以接受一个对象，也可以接收一个数组，那它底层到底干了什么事呢，我们一起来看一下源码这个函数的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapState</span> (<span class=\"params\">states</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(states).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedState</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> val === <span class=\"string\">'function'</span></span><br><span class=\"line\">        ? val.call(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.$store.state, <span class=\"keyword\">this</span>.$store.getters)</span><br><span class=\"line\">        : <span class=\"keyword\">this</span>.$store.state[val]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数首先对传入的参数调用 normalizeMap 方法，我们来看一下这个函数的定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalizeMap</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(map)</span><br><span class=\"line\">    ? map.map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> (&#123; key, <span class=\"attr\">val</span>: key &#125;))</span><br><span class=\"line\">    : <span class=\"built_in\">Object</span>.keys(map).map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> (&#123; key, <span class=\"attr\">val</span>: map[key] &#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法判断参数 map 是否为数组，如果是数组，则调用数组的 map 方法，把数组的每个元素转换成一个 {key, val: key}的对象；否则传入的 map 就是一个对象（从 mapState 的使用场景来看，传入的参数不是数组就是对象），我们调用 Object.keys 方法遍历这个 map 对象的 key，把数组的每个 key 都转换成一个 {key, val: map[key]}的对象。最后我们把这个对象数组作为 normalizeMap 的返回值。</p>\n<p>回到 mapState 函数，在调用了 normalizeMap 函数后，把传入的 states 转换成由 {key, val} 对象构成的数组，接着调用 forEach 方法遍历这个数组，构造一个新的对象，这个新对象每个元素都返回一个新的函数 mappedState，函数对 val 的类型判断，如果 val 是一个函数，则直接调用这个 val 函数，把当前 store 上的 state 和 getters 作为参数，返回值作为 mappedState 的返回值；否则直接把 this.$store.state[val] 作为 mappedState 的返回值。</p>\n<p>那么为何 mapState 函数的返回值是这样一个对象呢，因为 mapState 的作用是把全局的 state 和 getters 映射到当前组件的 computed 计算属性中，我们知道在 Vue 中 每个计算属性都是一个函数。</p>\n<p>为了更加直观地说明，回到刚才的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可以让代码非常简洁</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传入字符串 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">    countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 想访问局部状态，就必须借助于一个普通函数，函数中使用 `this` 获取局部状态</span></span><br><span class=\"line\">    countPlusLocalState (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过 mapState 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count() &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    countAlias() &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state[<span class=\"string\">'count'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    countPlusLocalState() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再看一下 mapState 参数为数组的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.count 到 this.$store.state.count</span></span><br><span class=\"line\">  <span class=\"string\">'count'</span></span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<p>经过 mapState 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  count() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state[<span class=\"string\">'count'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mapGetters\"><a href=\"#mapGetters\" class=\"headerlink\" title=\"mapGetters\"></a>mapGetters</h4><p>mapGetters 工具函数会将 store 中的 getter 映射到局部计算属性中。它的功能和 mapState 非常类似，我们来直接看它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapGetters</span> (<span class=\"params\">getters</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(getters).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedGetter</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(val <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.$store.getters)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown getter: <span class=\"subst\">$&#123;val&#125;</span>`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[val]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>mapGetters 的实现也和 mapState 很类似，不同的是它的 val 不能是函数，只能是一个字符串，而且会检查 val in this.$store.getters 的值，如果为 false 会输出一条错误日志。为了更直观地理解，我们来看一个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用对象扩展操作符把 getter 混入到 computed 中</span></span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\">      <span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过 mapGetters 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    doneTodosCount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[<span class=\"string\">'doneTodosCount'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    anotherGetter() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[<span class=\"string\">'anotherGetter'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看一个参数 mapGetters 参数是对象的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapGetters(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 映射 this.doneCount 到 store.getters.doneTodosCount</span></span><br><span class=\"line\">  doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>经过 mapGetters 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  doneCount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.getters[<span class=\"string\">'doneTodosCount'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mapActions\"><a href=\"#mapActions\" class=\"headerlink\" title=\"mapActions\"></a>mapActions</h4><p>mapActions 工具函数会将 store 中的 dispatch 方法映射到组件的 methods 中。和 mapState、mapGetters 也类似，只不过它映射的地方不是计算属性，而是组件的 methods 对象上。我们来直接看它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapActions</span> (<span class=\"params\">actions</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(actions).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedAction</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.dispatch.apply(<span class=\"keyword\">this</span>.$store, [val].concat(args))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，函数的实现套路和 mapState、mapGetters 差不多，甚至更简单一些， 实际上就是做了一层函数包装。为了更直观地理解，我们来看一个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 到 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() to this.$store.dispatch('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过 mapActions 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.dispatch.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    add(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.dispatch.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mapMutations\"><a href=\"#mapMutations\" class=\"headerlink\" title=\"mapMutations\"></a>mapMutations</h4><p>mapMutations 工具函数会将 store 中的 commit 方法映射到组件的 methods 中。和 mapActions 的功能几乎一样，我们来直接看它的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapMutations</span> (<span class=\"params\">mutations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  normalizeMap(mutations).forEach(<span class=\"function\">(<span class=\"params\">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res[key] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mappedMutation</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.commit.apply(<span class=\"keyword\">this</span>.$store, [val].concat(args))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的实现几乎也和 mapActions 一样，唯一差别就是映射的是 store 的 commit 方法。为了更直观地理解，我们来看一个简单的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapMutations([</span><br><span class=\"line\">      <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 到 this.$store.commit('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapMutations(&#123;</span><br><span class=\"line\">      add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 到 this.$store.commit('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过 mapMutations 函数调用后的结果，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.commit.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    add(...args) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.commit.apply(<span class=\"keyword\">this</span>.$store, [<span class=\"string\">'increment'</span>].concat(args))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>Vuex 的 store 接收 plugins 选项，一个 Vuex 的插件就是一个简单的方法，接收 store 作为唯一参数。插件作用通常是用来监听每次 mutation 的变化，来做一些事情。</p>\n<p>在 store 的构造函数的最后，我们通过如下代码调用插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> devtoolPlugin <span class=\"keyword\">from</span> <span class=\"string\">'./plugins/devtool'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apply plugins</span></span><br><span class=\"line\">plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></figure>\n<p>我们通常实例化 store 的时候，还会调用 logger 插件，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createLogger <span class=\"keyword\">from</span> <span class=\"string\">'vuex/dist/logger'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> debug = process.env.NODE_ENV !== <span class=\"string\">'production'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  plugins: debug ? [createLogger()] : []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在上述 2 个例子中，我们分别调用了 devtoolPlugin 和 createLogger() 2 个插件，它们是 Vuex 内置插件，我们接下来分别看一下他们的实现。</p>\n<h4 id=\"devtoolPlugin\"><a href=\"#devtoolPlugin\" class=\"headerlink\" title=\"devtoolPlugin\"></a>devtoolPlugin</h4><p>devtoolPlugin 主要功能是利用 Vue 的开发者工具和 Vuex 做配合，通过开发者工具的面板展示 Vuex 的状态。它的源码在 src/plugins/devtool.js 中，来看一下这个插件到底做了哪些事情。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> devtoolHook =</span><br><span class=\"line\">  <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> &amp;&amp;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.__VUE_DEVTOOLS_GLOBAL_HOOK__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">devtoolPlugin</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!devtoolHook) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  store._devtoolHook = devtoolHook</span><br><span class=\"line\"></span><br><span class=\"line\">  devtoolHook.emit(<span class=\"string\">'vuex:init'</span>, store)</span><br><span class=\"line\"></span><br><span class=\"line\">  devtoolHook.on(<span class=\"string\">'vuex:travel-to-state'</span>, targetState =&gt; &#123;</span><br><span class=\"line\">    store.replaceState(targetState)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  store.subscribe(<span class=\"function\">(<span class=\"params\">mutation, state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    devtoolHook.emit(<span class=\"string\">'vuex:mutation'</span>, mutation, state)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们直接从对外暴露的 devtoolPlugin 函数看起，函数首先判断了devtoolHook 的值，如果我们浏览器装了 Vue 开发者工具，那么在 window 上就会有一个 <code>__VUE_DEVTOOLS_GLOBAL_HOOK__</code> 的引用， 那么这个 devtoolHook 就指向这个引用。</p>\n<p>接下来通过 devtoolHook.emit(‘vuex:init’, store) 派发一个 Vuex 初始化的事件，这样开发者工具就能拿到当前这个 store 实例。</p>\n<p>接下来通过 devtoolHook.on(‘vuex:travel-to-state’, targetState =&gt; { store.replaceState(targetState) })监听 Vuex 的 traval-to-state 的事件，把当前的状态树替换成目标状态树，这个功能也是利用 Vue 开发者工具替换 Vuex 的状态。</p>\n<p>最后通过 store.subscribe((mutation, state) =&gt; { devtoolHook.emit(‘vuex:mutation’, mutation, state) }) 方法订阅 store 的 state 的变化，当 store 的 mutation 提交了 state 的变化， 会触发回调函数——通过 devtoolHook 派发一个 Vuex mutation 的事件，mutation 和 rootState 作为参数，这样开发者工具就可以观测到 Vuex state 的实时变化，在面板上展示最新的状态树。</p>\n<h4 id=\"loggerPlugin\"><a href=\"#loggerPlugin\" class=\"headerlink\" title=\"loggerPlugin\"></a>loggerPlugin</h4><p>通常在开发环境中，我们希望实时把 mutation 的动作以及 store 的 state 的变化实时输出，那么我们可以用 loggerPlugin 帮我们做这个事情。它的源码在 src/plugins/logger.js 中，来看一下这个插件到底做了哪些事情。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Credits: borrowed code from fcomb/redux-logger</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; deepCopy &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../util'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createLogger</span> (<span class=\"params\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  collapsed = true,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  transformer = state =&gt; state,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mutationTransformer = mut =&gt; mut</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> prevState = deepCopy(store.state)</span><br><span class=\"line\"></span><br><span class=\"line\">    store.subscribe(<span class=\"function\">(<span class=\"params\">mutation, state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span> === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextState = deepCopy(state)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">      <span class=\"keyword\">const</span> formattedTime = <span class=\"string\">` @ <span class=\"subst\">$&#123;pad(time.getHours(), <span class=\"number\">2</span>)&#125;</span>:<span class=\"subst\">$&#123;pad(time.getMinutes(), <span class=\"number\">2</span>)&#125;</span>:<span class=\"subst\">$&#123;pad(time.getSeconds(), <span class=\"number\">2</span>)&#125;</span>.<span class=\"subst\">$&#123;pad(time.getMilliseconds(), <span class=\"number\">3</span>)&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> formattedMutation = mutationTransformer(mutation)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> message = <span class=\"string\">`mutation <span class=\"subst\">$&#123;mutation.type&#125;</span><span class=\"subst\">$&#123;formattedTime&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> startMessage = collapsed</span><br><span class=\"line\">        ? <span class=\"built_in\">console</span>.groupCollapsed</span><br><span class=\"line\">        : <span class=\"built_in\">console</span>.group</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// render</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        startMessage.call(<span class=\"built_in\">console</span>, message)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'%c prev state'</span>, <span class=\"string\">'color: #9E9E9E; font-weight: bold'</span>, transformer(prevState))</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'%c mutation'</span>, <span class=\"string\">'color: #03A9F4; font-weight: bold'</span>, formattedMutation)</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'%c next state'</span>, <span class=\"string\">'color: #4CAF50; font-weight: bold'</span>, transformer(nextState))</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.groupEnd()</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'—— log end ——'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      prevState = nextState</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">repeat</span> (<span class=\"params\">str, times</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(times + <span class=\"number\">1</span>)).join(str)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pad</span> (<span class=\"params\">num, maxLength</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> repeat(<span class=\"string\">'0'</span>, maxLength - num.toString().length) + num</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插件对外暴露的是 createLogger 方法，它实际上接受 3 个参数，它们都有默认值，通常我们用默认值就可以。createLogger 的返回的是一个函数，当我执行 logger 插件的时候，实际上执行的是这个函数，下面来看一下这个函数做了哪些事情。</p>\n<p>函数首先执行了 let prevState = deepCopy(store.state) 深拷贝当前 store 的 rootState。这里为什么要深拷贝，因为如果是单纯的引用，那么 store.state 的任何变化都会影响这个引用，这样就无法记录上一个状态了。我们来了解一下 deepCopy 的实现，在 src/util.js 里定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span> (<span class=\"params\">list, f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list.filter(f)[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span> (<span class=\"params\">obj, cache = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// just return if obj is immutable value</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// if obj is hit, it is in circular structure</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hit = find(cache, c =&gt; c.original === obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hit.copy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// put the copy into cache at first</span></span><br><span class=\"line\">  <span class=\"comment\">// because we want to refer it in recursive deepCopy</span></span><br><span class=\"line\">  cache.push(&#123;</span><br><span class=\"line\">    original: obj,</span><br><span class=\"line\">    copy</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    copy[key] = deepCopy(obj[key], cache)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>deepCopy 并不陌生，很多开源库如 loadash、jQuery 都有类似的实现，原理也不难理解，主要是构造一个新的对象，遍历原对象或者数组，递归调用 deepCopy。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过<code>find(cache, c =&gt; c.original === obj)</code>发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。</p>\n<p>回到 loggerPlugin 函数，通过 deepCopy 拷贝了当前 state 的副本并用 prevState 变量保存，接下来调用 store.subscribe 方法订阅 store 的 state 的变。 在回调函数中，也是先通过 deepCopy 方法拿到当前的 state 的副本，并用 nextState 变量保存。接下来获取当前格式化时间已经格式化的 mutation 变化的字符串，然后利用 console.group 以及 console.log 分组输出 prevState、mutation以及 nextState，这里可以通过我们 createLogger 的参数 collapsed、transformer 以及 mutationTransformer 来控制我们最终 log 的显示效果。在函数的最后，我们把 nextState 赋值给 prevState，便于下一次 mutation。</p>\n","plink":"https://vincentdou.github.io/blog/post/2018-07-26-Vuex源码分析/","type":"post","toc":[{"title":"目录结构","id":"目录结构","index":"1"},{"title":"源码分析","id":"源码分析","index":"2","children":[{"title":"从入口开始","id":"从入口开始","index":"2.1"},{"title":"认识 Store 构造函数","id":"认识-Store-构造函数","index":"2.2"},{"title":"Vuex 的初始化核心","id":"Vuex-的初始化核心","index":"2.3","children":[{"title":"installModule","id":"installModule","index":"2.3.1"},{"title":"registerMutation","id":"registerMutation","index":"2.3.2"},{"title":"registerAction","id":"registerAction","index":"2.3.3"},{"title":"wrapGetters","id":"wrapGetters","index":"2.3.4"},{"title":"resetStoreVM","id":"resetStoreVM","index":"2.3.5"}]},{"title":"Vuex API 分析","id":"Vuex-API-分析","index":"2.4","children":[{"title":"watch(getter, cb, options)","id":"watch-getter-cb-options","index":"2.4.1"},{"title":"registerModule(path, module)","id":"registerModule-path-module","index":"2.4.2"},{"title":"unregisterModule(path)","id":"unregisterModule-path","index":"2.4.3"},{"title":"hotUpdate(newOptions)","id":"hotUpdate-newOptions","index":"2.4.4"},{"title":"replaceState","id":"replaceState","index":"2.4.5"}]},{"title":"辅助函数","id":"辅助函数","index":"2.5","children":[{"title":"mapState","id":"mapState","index":"2.5.1"},{"title":"mapGetters","id":"mapGetters","index":"2.5.2"},{"title":"mapActions","id":"mapActions","index":"2.5.3"},{"title":"mapMutations","id":"mapMutations","index":"2.5.4"}]},{"title":"插件","id":"插件","index":"2.6","children":[{"title":"devtoolPlugin","id":"devtoolPlugin","index":"2.6.1"},{"title":"loggerPlugin","id":"loggerPlugin","index":"2.6.2"}]}]}]}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjz2epje60007n3w57a5fk9pp","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epje8000an3w5cb7nvhb0"},{"post_id":"cjz2epje60007n3w57a5fk9pp","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epje9000bn3w5shz9s94a"},{"post_id":"cjz2epjdt0000n3w51nhm1125","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjed000dn3w5mntf3s9f"},{"post_id":"cjz2epjdt0000n3w51nhm1125","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjed000en3w51yl8mqyj"},{"post_id":"cjz2epjdt0000n3w51nhm1125","tag_id":"cjz2epje80009n3w521p0wgan","_id":"cjz2epjee000gn3w5hsagyvtd"},{"post_id":"cjz2epjdy0001n3w58wh1d39c","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjef000in3w52ctcu4jc"},{"post_id":"cjz2epjdy0001n3w58wh1d39c","tag_id":"cjz2epjed000fn3w5glnxomwx","_id":"cjz2epjef000jn3w5ipx84284"},{"post_id":"cjz2epje20003n3w5xl9436aj","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjeh000mn3w5bnorlvfa"},{"post_id":"cjz2epje20003n3w5xl9436aj","tag_id":"cjz2epjed000fn3w5glnxomwx","_id":"cjz2epjeh000nn3w5a4polhwk"},{"post_id":"cjz2epje30004n3w50xtxcfm8","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjei000pn3w5idoxvtlf"},{"post_id":"cjz2epje30004n3w50xtxcfm8","tag_id":"cjz2epjeg000ln3w53pudhevg","_id":"cjz2epjei000qn3w5g223ny2f"},{"post_id":"cjz2epje40005n3w5deq5ok08","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjei000sn3w5547f5pfx"},{"post_id":"cjz2epje40005n3w5deq5ok08","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjei000tn3w5lztk7gkh"},{"post_id":"cjz2epje70008n3w5if8r2xwf","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjej000vn3w5pjrnlje9"},{"post_id":"cjz2epje70008n3w5if8r2xwf","tag_id":"cjz2epjei000rn3w5hltmm0ty","_id":"cjz2epjej000wn3w5t0jpgpaw"},{"post_id":"cjz2epje70008n3w5if8r2xwf","tag_id":"cjz2epjej000un3w5skx1fk4m","_id":"cjz2epjej000xn3w5zz30dz7o"},{"post_id":"cjz2epjf3000zn3w53jskhovh","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfa0012n3w55i6z3q33"},{"post_id":"cjz2epjf3000zn3w53jskhovh","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjfd0014n3w5xqv8erwg"},{"post_id":"cjz2epjf3000zn3w53jskhovh","tag_id":"cjz2epje80009n3w521p0wgan","_id":"cjz2epjfh0017n3w5sk27o9d7"},{"post_id":"cjz2epjf70011n3w5a2f81d0g","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfi0019n3w5awaatrae"},{"post_id":"cjz2epjf70011n3w5a2f81d0g","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjfj001cn3w5q0g8uww2"},{"post_id":"cjz2epjf70011n3w5a2f81d0g","tag_id":"cjz2epje80009n3w521p0wgan","_id":"cjz2epjfk001dn3w56r6x09ex"},{"post_id":"cjz2epjf1000yn3w5k0rvng1t","tag_id":"cjz2epjf60010n3w5nvm1lte1","_id":"cjz2epjfk001fn3w5jb89pw9x"},{"post_id":"cjz2epjf1000yn3w5k0rvng1t","tag_id":"cjz2epjfe0016n3w5cqk97oy3","_id":"cjz2epjfl001gn3w5oi1gc5y1"},{"post_id":"cjz2epjfb0013n3w5exrsqy73","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfl001hn3w5wfov7el9"},{"post_id":"cjz2epjfb0013n3w5exrsqy73","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjfm001jn3w5y9egsggc"},{"post_id":"cjz2epjfb0013n3w5exrsqy73","tag_id":"cjz2epjfj001bn3w5diqgd8w9","_id":"cjz2epjfn001kn3w5k04vwl2f"},{"post_id":"cjz2epjfd0015n3w5u5lpszla","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfo001mn3w50fd175kg"},{"post_id":"cjz2epjfd0015n3w5u5lpszla","tag_id":"cjz2epjfk001en3w5rnixux55","_id":"cjz2epjfo001nn3w5pt0ivhws"},{"post_id":"cjz2epjfh0018n3w5vvxno4ul","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfp001pn3w50eistecz"},{"post_id":"cjz2epjfh0018n3w5vvxno4ul","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjfp001qn3w5ay8yi3do"},{"post_id":"cjz2epjfh0018n3w5vvxno4ul","tag_id":"cjz2epjfm001in3w5dw6o6xry","_id":"cjz2epjfp001rn3w56o6ctxp3"},{"post_id":"cjz2epjfi001an3w5pkvpilx7","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfq001sn3w5w65tfvip"},{"post_id":"cjz2epjfi001an3w5pkvpilx7","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjfq001tn3w5kmwgkc00"},{"post_id":"cjz2epjfi001an3w5pkvpilx7","tag_id":"cjz2epjfn001ln3w5qvg3ldtm","_id":"cjz2epjfq001un3w5ql3o7yu9"},{"post_id":"cjz2epjfi001an3w5pkvpilx7","tag_id":"cjz2epjfo001on3w5adxypwgb","_id":"cjz2epjfr001vn3w5rmz22znf"},{"post_id":"cjz2epjfv001wn3w51yjarq6j","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfx001yn3w5u7phiudr"},{"post_id":"cjz2epjfv001wn3w51yjarq6j","tag_id":"cjz2epjeg000ln3w53pudhevg","_id":"cjz2epjfx001zn3w56w43gusk"},{"post_id":"cjz2epjfw001xn3w54mqytm4o","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjfx0020n3w5ttqf4agr"},{"post_id":"cjz2epjfw001xn3w54mqytm4o","tag_id":"cjz2epje50006n3w547i5jssk","_id":"cjz2epjfx0021n3w5qetyoi5o"},{"post_id":"cjz2epjfw001xn3w54mqytm4o","tag_id":"cjz2epje80009n3w521p0wgan","_id":"cjz2epjfx0022n3w51bqzulon"},{"post_id":"cjz2epjg10023n3w574iff9lm","tag_id":"cjz2epje00002n3w5r6ubux5x","_id":"cjz2epjg20024n3w5w7veu8hb"},{"post_id":"cjz2epjg10023n3w574iff9lm","tag_id":"cjz2epjeg000ln3w53pudhevg","_id":"cjz2epjg20025n3w5zdu83t5d"}],"Tag":[{"name":"前端开发","_id":"cjz2epje00002n3w5r6ubux5x"},{"name":"JavaScript","_id":"cjz2epje50006n3w547i5jssk"},{"name":"你不知道的JS","_id":"cjz2epje80009n3w521p0wgan"},{"name":"性能优化","_id":"cjz2epjed000fn3w5glnxomwx"},{"name":"vue","_id":"cjz2epjeg000ln3w53pudhevg"},{"name":"CSS","_id":"cjz2epjei000rn3w5hltmm0ty"},{"name":"flex布局","_id":"cjz2epjej000un3w5skx1fk4m"},{"name":"碎碎念","_id":"cjz2epjf60010n3w5nvm1lte1"},{"name":"年度总结","_id":"cjz2epjfe0016n3w5cqk97oy3"},{"name":"JS机制","_id":"cjz2epjfj001bn3w5diqgd8w9"},{"name":"缓存","_id":"cjz2epjfk001en3w5rnixux55"},{"name":"前端模块化","_id":"cjz2epjfm001in3w5dw6o6xry"},{"name":"ES6","_id":"cjz2epjfn001ln3w5qvg3ldtm"},{"name":"Promise","_id":"cjz2epjfo001on3w5adxypwgb"}]}}
{"title":"前端性能优化-1","date":"2018-07-22T16:00:00.000Z","author":"Vincent","excerpt":"","slug":"2018-07-23-前端性能优化-1","tags":["前端开发","性能优化"],"updated":"2019-01-02T08:49:00.221Z","content":"<h2 id=\"DOM-操作篇\"><a href=\"#DOM-操作篇\" class=\"headerlink\" title=\"DOM 操作篇\"></a>DOM 操作篇</h2><h4 id=\"缓存DOM对象\"><a href=\"#缓存DOM对象\" class=\"headerlink\" title=\"缓存DOM对象\"></a>缓存DOM对象</h4><p>很基本的一个做法，在 for 循环前把要操作的 DOM 节点先获取到，而不是每次遍历都重新获取。</p>\n<h4 id=\"在内存中操作元素\"><a href=\"#在内存中操作元素\" class=\"headerlink\" title=\"在内存中操作元素\"></a>在内存中操作元素</h4><p>利用<code>document.createDocumentFragment()</code>可以创建内存节点。</p>\n<p>由于 DOM 操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ulNode = document.getElementById(&quot;container&quot;);</span><br><span class=\"line\">var liNode, i, m;</span><br><span class=\"line\">var fragment = document.createDocumentFragment();</span><br><span class=\"line\">for (i = 0, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    liNode = document.createElement(&quot;li&quot;);</span><br><span class=\"line\">    liNode.innerText = data[i];</span><br><span class=\"line\">    fragment.appendChild(liNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ulNode.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<p>这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（<code>cloneNode()</code>），在内存中进行操作后再替换原来的节点。</p>\n<p>避免过多的触发回流，是性能优化的一个思路。</p>\n<h4 id=\"通过事件代理批量操作事件\"><a href=\"#通过事件代理批量操作事件\" class=\"headerlink\" title=\"通过事件代理批量操作事件\"></a>通过事件代理批量操作事件</h4><p>我们可以通过事件代理的方式，将事件绑定在父节点上，然后通过<code>event.target</code>来确定被点击的元素是否是要绑定的子节点。</p>\n<p>这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了。</p>\n<h2 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a>Javascript</h2><h4 id=\"垃圾回收器回收机制\"><a href=\"#垃圾回收器回收机制\" class=\"headerlink\" title=\"垃圾回收器回收机制\"></a>垃圾回收器回收机制</h4><ul>\n<li><code>delete</code>这种方式可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化；而通过将变量或对象的属性设为<code>null</code>这种方式，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。相对而言，设为<code>null</code>这种方式不会改变对象的结构，比使用delete要好。</li>\n<li>垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收，而全局对象就是根对象。</li>\n</ul>\n<h4 id=\"对象的优化\"><a href=\"#对象的优化\" class=\"headerlink\" title=\"对象的优化\"></a>对象的优化</h4><p>JavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 &gt; 数组下标获取（对象的整数索引获取） &gt; 对象属性获取（对象非整数索引获取）。因\b此我们可以通过缓存需要被使用的对象的某属性的方式\b进行优化。</p>\n<h4 id=\"使用原生方法\"><a href=\"#使用原生方法\" class=\"headerlink\" title=\"使用原生方法\"></a>使用原生方法</h4><p>在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如Math之类的原生对象和方法。</p>\n","prev":{"title":"[转]Vuex框架原理与源码分析","slug":"2018-07-25-Vuex框架原理与源码分析"},"next":{"title":"前端性能优化-2","slug":"2018-07-23-前端性能优化-2"},"link":"/blog/post","toc":[{"title":"DOM 操作篇","id":"DOM-操作篇","index":"1"},{"title":"Javascript","id":"Javascript","index":"2"}]}
{"title":"JS机制梳理总结","date":"2018-06-19T16:00:00.000Z","author":"Vincent","excerpt":"","slug":"2018-06-20-JS机制梳理总结","tags":["JS机制","JavaScript","前端开发"],"updated":"2019-01-02T08:49:00.245Z","content":"<blockquote>\n<p>原文：<a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>\n</blockquote>\n<h3 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h3><ul>\n<li><p>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</p>\n</li>\n<li><p>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p>\n</li>\n</ul>\n<h3 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h3><p>以 Chrome 浏览器为例，它到底包含这些主要进程：</p>\n<ol>\n<li><p>Browser进程：浏览器的主进程（负责协调、主控）。负责浏览器界面显示，与用户交互。如前进，后退等；负责各个页面的管理，创建和销毁其他进程；将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；网络资源的管理，下载等</p>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程</p>\n</li>\n<li><p>GPU进程：最多一个，用于3D绘制等</p>\n</li>\n<li><p>浏览器渲染进程（浏览器内核）（Renderer进程）：默认每个Tab页面一个进程，互不影响，内部是多线程的。负责页面渲染，脚本执行，事件处理等。<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p>\n</li>\n</ol>\n<h3 id=\"浏览器渲染进程（浏览器内核）（Renderer进程）\"><a href=\"#浏览器渲染进程（浏览器内核）（Renderer进程）\" class=\"headerlink\" title=\"浏览器渲染进程（浏览器内核）（Renderer进程）\"></a>浏览器渲染进程（浏览器内核）（Renderer进程）</h3><ol>\n<li><p>GUI渲染线程</p>\n<ul>\n<li><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</p>\n</li>\n<li><p>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</p>\n</li>\n<li><p>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>\n</li>\n</ul>\n</li>\n<li><p>JS引擎线程</p>\n<ul>\n<li><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</p>\n</li>\n<li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p>\n</li>\n<li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p>\n</li>\n<li><p>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n</li>\n</ul>\n</li>\n<li><p>事件触发线程</p>\n<ul>\n<li><p>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</p>\n</li>\n<li><p>当JS引擎执行代码块如<code>setTimeOut</code>时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</p>\n</li>\n<li><p>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p>\n</li>\n<li><p>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p>\n</li>\n</ul>\n</li>\n<li><p>定时触发器线程</p>\n<ul>\n<li><p>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</p>\n</li>\n<li><p>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</p>\n</li>\n<li><p>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p>\n</li>\n<li><p>注意，W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms。</p>\n</li>\n</ul>\n</li>\n<li><p>异步http请求线程</p>\n<ul>\n<li><p>在<code>XMLHttpRequest</code>在连接后是通过浏览器新开一个线程请求</p>\n</li>\n<li><p>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d39a5b2?imageslim\" alt=\"\"></p>\n<h3 id=\"浏览器渲染流程\"><a href=\"#浏览器渲染流程\" class=\"headerlink\" title=\"浏览器渲染流程\"></a>浏览器渲染流程</h3><ol>\n<li><p>解析html建立dom树</p>\n</li>\n<li><p>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</p>\n</li>\n<li><p>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p>\n</li>\n<li><p>绘制render树（paint），绘制页面像素信息</p>\n</li>\n<li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</p>\n</li>\n</ol>\n<h5 id=\"load事件与DOMContentLoaded事件的先后\"><a href=\"#load事件与DOMContentLoaded事件的先后\" class=\"headerlink\" title=\"load事件与DOMContentLoaded事件的先后\"></a>load事件与DOMContentLoaded事件的先后</h5><ul>\n<li><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p>\n</li>\n<li><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p>\n</li>\n</ul>\n<p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p>\n<h5 id=\"css加载是否会阻塞dom树渲染？\"><a href=\"#css加载是否会阻塞dom树渲染？\" class=\"headerlink\" title=\"css加载是否会阻塞dom树渲染？\"></a>css加载是否会阻塞dom树渲染？</h5><p>css是由单独的下载线程异步下载的。</p>\n<ul>\n<li><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</p>\n</li>\n<li><p>css加载会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>\n</li>\n</ul>\n<h3 id=\"复合图层和硬件加速\"><a href=\"#复合图层和硬件加速\" class=\"headerlink\" title=\"复合图层和硬件加速\"></a>复合图层和硬件加速</h3><h5 id=\"复合图层\"><a href=\"#复合图层\" class=\"headerlink\" title=\"复合图层\"></a>复合图层</h5><ul>\n<li><p>普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</p>\n</li>\n<li><p><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p>\n</li>\n<li><p>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>\n</li>\n</ul>\n<h5 id=\"如何变成复合图层（硬件加速）\"><a href=\"#如何变成复合图层（硬件加速）\" class=\"headerlink\" title=\"如何变成复合图层（硬件加速）\"></a>如何变成复合图层（硬件加速）</h5><p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p>\n<ul>\n<li><p>最常用的方式：<code>translate3d</code>、<code>translateZ</code></p>\n</li>\n<li><p><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</p>\n</li>\n<li><p><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），<br>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p>\n</li>\n<li><p><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</p>\n</li>\n<li><p>其它，譬如以前的flash插件</p>\n</li>\n</ul>\n<h3 id=\"从Event-Loop谈JS的运行机制\"><a href=\"#从Event-Loop谈JS的运行机制\" class=\"headerlink\" title=\"从Event Loop谈JS的运行机制\"></a>从Event Loop谈JS的运行机制</h3><ul>\n<li><p>JS分为同步任务和异步任务</p>\n</li>\n<li><p>同步任务都在<code>主线程</code>上执行，形成一个<code>执行栈</code></p>\n</li>\n<li><p>主线程之外，<code>事件触发线程</code>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件。</p>\n</li>\n<li><p>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到<code>可执行栈</code>中，开始执行。</p>\n</li>\n</ul>\n<h3 id=\"macrotask与microtask\"><a href=\"#macrotask与microtask\" class=\"headerlink\" title=\"macrotask与microtask\"></a>macrotask与microtask</h3><p><code>microtask</code>是<code>Promise</code>里的一个新的概念</p>\n<ul>\n<li><p>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>\n<ul>\n<li><p>每一个 task 会从头到尾将这个任务执行完毕，不会执行其它</p>\n</li>\n<li><p>浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染（task-&gt;渲染-&gt;task-&gt;…）</p>\n</li>\n<li><p>主代码块，<code>setTimeout</code>，<code>setInterval</code>等可以形成 macrotask（可以看到，事件队列中的每一个事件都是一个 macrotask）</p>\n</li>\n</ul>\n</li>\n<li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p>\n<ul>\n<li><p>也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前</p>\n</li>\n<li><p>所以它的响应速度相比<code>setTimeout</code>（<code>setTimeout</code>是 task）会更快，因为无需等渲染</p>\n</li>\n<li><p>也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）</p>\n</li>\n<li><p><code>Promise</code>，<code>process.nextTick</code>等可以形成 microtask</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>根据线程来理解下：</p>\n<ul>\n<li><p>macrotask 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护</p>\n</li>\n<li><p>microtask 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 macrotask 执行完毕后执行，而这个队列由 JS 引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/1/21/1611938b96e93485?imageslim\" alt=\"\"></p>\n<p>另外，要注意 Promise 的 polyfill 与官方版本的区别：</p>\n<ul>\n<li><p>官方版本中，是标准的 microtask 形式</p>\n</li>\n<li><p>polyfill，一般都是通过 setTimeout 模拟的，所以是 macrotask 形式</p>\n</li>\n</ul>\n<h5 id=\"使用MutationObserver实现microtask\"><a href=\"#使用MutationObserver实现microtask\" class=\"headerlink\" title=\"使用MutationObserver实现microtask\"></a>使用MutationObserver实现microtask</h5><p>MutationObserver 可以用来实现 microtask（它属于 microtask，优先级小于Promise，一般是 Promise 不支持时才会这样做）</p>\n<p>它是 HTML5 中的新特性，作用是：监听一个 DOM 变动，当 DOM 对象树发生任何变动时，Mutation Observer 会得到通知</p>\n<p>像以前的Vue源码中就是利用它来模拟 nextTick 的，具体原理是，创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容，如下：（Vue的源码，未修改）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var counter = 1</span><br><span class=\"line\">var observer = new MutationObserver(nextTickHandler)</span><br><span class=\"line\">var textNode = document.createTextNode(String(counter))</span><br><span class=\"line\"></span><br><span class=\"line\">observer.observe(textNode, &#123;</span><br><span class=\"line\">    characterData: true</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">timerFunc = () =&gt; &#123;</span><br><span class=\"line\">    counter = (counter + 1) % 2</span><br><span class=\"line\">    textNode.data = String(counter)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"前端性能优化-2","slug":"2018-07-23-前端性能优化-2"},"next":{"title":"你不知道的JS-异步与性能","slug":"2018-06-10-你不知道的JS-4"},"link":"/blog/post"}
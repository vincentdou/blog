{"title":"Vuex源码读后感","date":"2018-07-26T16:00:00.000Z","author":"Vincent","link":"post/2018-07-27-Vuex源码读后感","tags":["vue","前端开发"],"updated":"2019-01-02T08:49:00.262Z","content":"<blockquote>\n<p>这是一篇感想，不是 vuex 源码的导读。除了总结几个对 Vuex 的疑问，还有一些阅读源码的方法论可以分享。</p>\n</blockquote>\n<h2 id=\"推荐两篇文章\">推荐两篇文章<a href=\"post/2018-07-27-Vuex源码读后感#推荐两篇文章\"></a></h2><p>推荐两篇导读的文章：</p>\n<ol>\n<li><p><a href=\"https://juejin.im/entry/5af5d048f265da0b7b35f94e\" target=\"_blank\" rel=\"noopener\">Vuex 框架原理与源码分析</a></p>\n<blockquote>\n<p>美团前端团队的一篇文章，这篇文章是提出问题、解决问题的叙事风格，比较容易看的进去。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/DDFE/DDFE-blog/issues/8\" target=\"_blank\" rel=\"noopener\">Vuex 2.0 源码分析</a></p>\n<blockquote>\n<p>相对来说，这篇文章像是记叙文的风格，从暴露出的 API 开始进行接近逐行的分析，十分详细。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Q-amp-A\">Q&amp;A<a href=\"post/2018-07-27-Vuex源码读后感#Q-amp-A\"></a></h2><blockquote>\n<p>阅读源码前的几个疑惑，在阅读后得到了答案。</p>\n</blockquote>\n<h3 id=\"1-Vue-use-Vuex-发生了什么？\">1. <code>Vue.use(Vuex)</code>发生了什么？<a href=\"post/2018-07-27-Vuex源码读后感#1-Vue-use-Vuex-发生了什么？\"></a></h3><p><code>Vue.use()</code>是 Vue 安装插件的方法，先看下它的代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">plugin: Function | Object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.installed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// additional parameters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = toArray(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  args.unshift(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.install === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际执行插件的 install 方法</span></span><br><span class=\"line\">    plugin.install.apply(plugin, args)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    plugin.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  plugin.installed = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里核心就是执行<code>plugin.install.apply(plugin, args)</code>，所以下一步看 Vuex 的 install 方法：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">        <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>再看 applyMixin：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>所以 Vuex 的 install 方法的核心就是在每个 Vue 组件初始化的时候执行 <code>vuexInit</code>，Vue 版本如果在 2.0 以上是在 init 或 beforeCreate 生命周期上，2.0 以下版本是修改 Vue 对象原型的_init方法。</p>\n<h3 id=\"2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？\">2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？<a href=\"post/2018-07-27-Vuex源码读后感#2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？\"></a></h3><p>看下 vuexInit 方法：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">  <span class=\"comment\">// store injection</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这个函数将初始化 Vue 根组件时传入的 store 设置到 this 对象的<code>$store</code>属性上，子组件从其父组件引用<code>$store</code>属性，层层嵌套进行设置。这样，在任意组件中执行<code>this.$store</code>都能找到装载的那个 store 对象。这里的 this 指向一个 Vue 组件。</p>\n<h3 id=\"3-strict-模式下不能直接修改-state，怎么做到的？\">3. strict 模式下不能直接修改 state，怎么做到的？<a href=\"post/2018-07-27-Vuex源码读后感#3-strict-模式下不能直接修改-state，怎么做到的？\"></a></h3><p>在 resetStoreVM 方法中如果是严格模式会执行<code>enableStrictMode(store)</code>，看下这个函数：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._data.$$state &#125;, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      assert(store._committing, <span class=\"string\">`do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>很短的一段代码，主要就是利用 Vue 的 watch 监测 state 的变化，用到断言函数，在 _committing 为<code>false</code>的时候进行报错。我们通过 mutation 修改 state 的时候都会经过 _withCommit：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这就是通过 mutation 修改 state 不会报错的原因。</p>\n<h3 id=\"4-vm-的主要意义是什么？\">4. _vm 的主要意义是什么？<a href=\"post/2018-07-27-Vuex源码读后感#4-vm-的主要意义是什么？\"></a></h3><p>_vm 是一个 Vue 组件，它的作用除了上面的 watch 以外，还有：</p>\n<ul>\n<li>把 state 存在<code>_vm</code>的<code>_data</code>的<code>$$state</code>属性上，并且让 store 的 state 指向这里。</li>\n<li>把 getter 存在<code>_vm</code>的<code>computed</code>上。</li>\n</ul>\n<h2 id=\"启发\">启发<a href=\"post/2018-07-27-Vuex源码读后感#启发\"></a></h2><h3 id=\"1-assert断言函数\">1. <code>assert</code>断言函数<a href=\"post/2018-07-27-Vuex源码读后感#1-assert断言函数\"></a></h3><p>assert函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>用在条件的检测或者表单的校验上还是很方便的。</p>\n<h3 id=\"2-deepCopy深拷贝\">2. <code>deepCopy</code>深拷贝<a href=\"post/2018-07-27-Vuex源码读后感#2-deepCopy深拷贝\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span> (<span class=\"params\">obj, cache = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// just return if obj is immutable value</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// if obj is hit, it is in circular structure</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hit = find(cache, c =&gt; c.original === obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hit.copy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// put the copy into cache at first</span></span><br><span class=\"line\">  <span class=\"comment\">// because we want to refer it in recursive deepCopy</span></span><br><span class=\"line\">  cache.push(&#123;</span><br><span class=\"line\">    original: obj,</span><br><span class=\"line\">    copy</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">    copy[key] = deepCopy(obj[key], cache)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里的 deepCopy 也是采用构造一个新的对象，遍历原对象或者数组，递归调用自身的方式。不过这里的实现有一个有意思的地方，在每次执行 deepCopy 的时候，会用 cache 数组缓存当前嵌套的对象，以及执行 deepCopy 返回的 copy。如果在 deepCopy 的过程中通过<code>find(cache, c =&gt; c.original === obj)</code>发现有循环引用的时候，直接返回 cache 中对应的 copy，这样就避免了无限循环的情况。</p>\n<h3 id=\"3-阅读源码的方法\">3. 阅读源码的方法<a href=\"post/2018-07-27-Vuex源码读后感#3-阅读源码的方法\"></a></h3><p>一开始图省事，安装了一个叫 octotree 的 chrome 扩展，发现其实很麻烦，最好还是把源码 clone 下来用编辑器打开。另外把实例在控制台 console 出来也是很高效的一个做法。</p>\n<p>所以我在看代码的时候开了三个编辑器：看源码、打开一个用到 Vuex 的项目、写 markdown。切来切去有点懵的。</p>\n","prev":{"title":"浏览器缓存知识小结及应用","link":"post/2018-08-03-浏览器缓存知识小结及应用"},"next":{"title":"[转]Vuex 2.0 源码分析","link":"post/2018-07-26-Vuex源码分析"},"plink":"https://vincentdou.github.io/blog/post/2018-07-27-Vuex源码读后感/","toc":[{"title":"推荐两篇文章","id":"推荐两篇文章","index":"1"},{"title":"Q&amp;A","id":"Q-amp-A","index":"2","children":[{"title":"1. <code>Vue.use(Vuex)</code>发生了什么？","id":"1-Vue-use-Vuex-发生了什么？","index":"2.1"},{"title":"2. Vuex 是怎么做到在每个 vue 文件中都能访问到的？","id":"2-Vuex-是怎么做到在每个-vue-文件中都能访问到的？","index":"2.2"},{"title":"3. strict 模式下不能直接修改 state，怎么做到的？","id":"3-strict-模式下不能直接修改-state，怎么做到的？","index":"2.3"},{"title":"4. _vm 的主要意义是什么？","id":"4-vm-的主要意义是什么？","index":"2.4"}]},{"title":"启发","id":"启发","index":"3","children":[{"title":"1. <code>assert</code>断言函数","id":"1-assert断言函数","index":"3.1"},{"title":"2. <code>deepCopy</code>深拷贝","id":"2-deepCopy深拷贝","index":"3.2"},{"title":"3. 阅读源码的方法","id":"3-阅读源码的方法","index":"3.3"}]}]}
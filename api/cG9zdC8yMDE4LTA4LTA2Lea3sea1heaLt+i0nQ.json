{"title":"JS 中的深浅拷贝","date":"2018-08-05T16:00:00.000Z","author":"Vincent","link":"post/2018-08-06-深浅拷贝","tags":["JavaScript","前端开发"],"updated":"2019-01-02T08:49:00.261Z","content":"<h2 id=\"前言\">前言<a href=\"post/2018-08-06-深浅拷贝#前言\"></a></h2><p>JavaScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值是指那些保存堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。</p>\n<p>目前基本类型有：Boolean、Null、Undefined、Number、String、Symbol，引用类型有：Object、Array、Function。</p>\n<p>对于引用类型，简单的<code>=</code>赋值只是调一下指针，如果给\b两个变量赋值同一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p>\n<p>通常在开发中我们不希望出现这样的问题，这就牵涉到深浅拷贝。</p>\n<h2 id=\"浅拷贝\">浅拷贝<a href=\"post/2018-08-06-深浅拷贝#浅拷贝\"></a></h2><ul>\n<li>Array.slice()、Array.concat()、Array.from()、展开运算符（…）能实现数组的浅拷贝；</li>\n<li>Object.assign()、展开运算符<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; 浅拷贝只解决第一层的问题，如果接下去的值中还有对象的话，就要用到深拷贝。</span><br><span class=\"line\"></span><br><span class=\"line\">## 深拷贝</span><br><span class=\"line\"></span><br><span class=\"line\">通常有下面两种方法实现深拷贝：</span><br><span class=\"line\"></span><br><span class=\"line\">- 序列化反序列化法</span><br><span class=\"line\">- MessageChannel 法</span><br><span class=\"line\">- 迭代递归法</span><br><span class=\"line\"></span><br><span class=\"line\">都会用到的一个函数：</span><br><span class=\"line\"></span><br><span class=\"line\">```js</span><br><span class=\"line\">// 判断是否为对象</span><br><span class=\"line\">function isObject(o) &#123;</span><br><span class=\"line\">    return (typeof o === &apos;object&apos; || typeof o === &apos;function&apos;) &amp;&amp; o !== null)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n<h3 id=\"序列化反序列化法\">序列化反序列化法<a href=\"post/2018-08-06-深浅拷贝#序列化反序列化法\"></a></h3><p>先把代码序列化成数据，再反序列化回对象：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 序列化反序列化法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数、RegExp等特殊对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n<li>原形链上的属性也不会被追踪以及复制</li>\n</ul>\n<p>在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。所以如果你的数据中不含有以下三种情况，这个方法是很好的：</p>\n<ul>\n<li>有 undefined</li>\n<li>有函数、RegExp等特殊对象</li>\n<li>有循环引用的对象</li>\n</ul>\n<h3 id=\"MessageChannel-法\">MessageChannel 法<a href=\"post/2018-08-06-深浅拷贝#MessageChannel-法\"></a></h3><p>MessageChannel 接口是信道通信 API 的一个接口，它允许我们创建一个新的信道并通过信道的两个 MessagePort 属性来传递数据。简单来说，MessageChannel 创建了一个通信的管道，这个管道有两个口子，每个口子都可以通过 postMessage 发送数据，而一个口子只要绑定了 onmessage 回调方法，就可以接收从另一个口子传过来的数据。</p>\n<p>我们可用利用他这个两个口子完成克隆：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">structuralClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;port1, port2&#125; = <span class=\"keyword\">new</span> MessageChannel()</span><br><span class=\"line\">    port2.onmessage = <span class=\"function\"><span class=\"params\">ev</span> =&gt;</span> resolve(ev.data)</span><br><span class=\"line\">    port1.postMessage(obj)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: &#123;</span><br><span class=\"line\">    c: b</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意该方法是异步的</span></span><br><span class=\"line\"><span class=\"comment\">// 可以处理 undefined 和循环引用对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = <span class=\"keyword\">await</span> structuralClone(obj)</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>数据中包含函数、Error时会报错</li>\n<li>循环引用会造成\b栈溢出</li>\n</ul>\n<p>这个方法能很好的保留 RegExp、Error 这些的构造函数。</p>\n<h3 id=\"迭代递归法\">迭代递归法<a href=\"post/2018-08-06-深浅拷贝#迭代递归法\"></a></h3><p>这是最常规的方法，思想很简单：就是对对象进行迭代操作，对它的每个值进行递归深拷贝。</p>\n<h4 id=\"for…in-法\">for…in 法<a href=\"post/2018-08-06-深浅拷贝#for…in-法\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代递归法：深拷贝对象与数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'obj 不是一个对象！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [] : &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n</ul>\n<p>\bfor…in 会追踪原型链上的属性，而其它三种方法(Object.keys、Reflect.ownKeys 和 JSON 方法)都不会追踪原型链上的属性。</p>\n<h4 id=\"Reflect-法\">Reflect 法<a href=\"post/2018-08-06-深浅拷贝#Reflect-法\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'obj 不是一个对象！'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [...obj] : &#123; ...obj &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Reflect</span>.ownKeys(cloneObj).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>局限性：</p>\n<ul>\n<li>无法实现对函数 、Date、RegExp、Error等有特殊的构造函数的对象的克隆</li>\n<li>循环引用会造成\b栈溢出</li>\n<li>原形链上的属性也不会被追踪以及复制</li>\n</ul>\n<h4 id=\"lodash-中的深拷贝\">lodash 中的深拷贝<a href=\"post/2018-08-06-深浅拷贝#lodash-中的深拷贝\"></a></h4><p>著名的 lodash 中的 cloneDeep 方法同样是使用迭代递归法实现的，它支持的对象种类更多，具体的实现过程读者可以参考 <a href=\"https://github.com/lodash/lodash/blob/master/.internal/baseClone.js\" target=\"_blank\" rel=\"noopener\">lodash 的 baseClone</a> 方法。</p>\n<p>局限：</p>\n<ul>\n<li>不会对 Error 和 Function 类型进行拷贝</li>\n</ul>\n<h3 id=\"思考\">思考<a href=\"post/2018-08-06-深浅拷贝#思考\"></a></h3><h4 id=\"对象成环怎么办？\">对象成环怎么办？<a href=\"post/2018-08-06-深浅拷贝#对象成环怎么办？\"></a></h4><p>我们给 test 加一个 loopObj 键，值指向自身：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.loopObj = test</span><br></pre></td></tr></table></div></figure>\n<p>这时我们使用迭代递归法中的 for..in 实现和 Reflect 实现还有序列化反序列化法都会栈溢出，但 lodash 却可以得到正确结果。</p>\n<p>为什么呢？我们去 <a href=\"https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L200\" target=\"_blank\" rel=\"noopener\">lodash 源码</a>看看：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/18/162d6bbd8d654360?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>因为 lodash 使用的是栈把对象存储起来了，如果有环对象，就会从栈里检测到，从而直接返回结果，悬崖勒马。</p>\n<p>当然，设置一个哈希表存储已拷贝过的对象同样可以达到同样的目的：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 查表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hash.has(obj)) <span class=\"keyword\">return</span> hash.get(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isArray = <span class=\"built_in\">Array</span>.isArray(obj)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cloneObj = isArray ? [] : &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表设值</span></span><br><span class=\"line\">    hash.set(obj, cloneObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"built_in\">Object</span>.keys(obj).map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            [key]: deepClone(obj[key], hash)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(cloneObj, ...result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里我们使用 WeakMap 作为哈希表，因为它的键是弱引用的，而我们这个场景里键恰好是对象，需要弱引用。</p>\n<blockquote>\n<p>参考：<br><a href=\"https://juejin.im/post/5abb55ee6fb9a028e33b7e0a?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">面试官:请你实现一个深克隆</a><br><a href=\"https://juejin.im/post/5ad5b908f265da23870f540d?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">低门槛彻底理解JavaScript中的深拷贝和浅拷贝</a><br><a href=\"https://juejin.im/post/5ad6b72f6fb9a028d375ecf6?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">深入深入再深入 js 深拷贝对象</a><br><a href=\"https://yuchengkai.cn/docs/zh/frontend/#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D\" target=\"_blank\" rel=\"noopener\">前端面试图谱-深浅拷贝</a></p>\n</blockquote>\n","prev":{"title":"JS 中的 NaN","link":"post/2018-08-07-NaN"},"next":{"title":"浏览器缓存知识小结及应用","link":"post/2018-08-03-浏览器缓存知识小结及应用"},"plink":"https://vincentdou.github.io/blog/post/2018-08-06-深浅拷贝/","toc":[{"title":"前言","id":"前言","index":"1"},{"title":"浅拷贝","id":"浅拷贝","index":"2","children":[{"title":"序列化反序列化法","id":"序列化反序列化法","index":"2.1"},{"title":"MessageChannel 法","id":"MessageChannel-法","index":"2.2"},{"title":"迭代递归法","id":"迭代递归法","index":"2.3","children":[{"title":"for…in 法","id":"for…in-法","index":"2.3.1"},{"title":"Reflect 法","id":"Reflect-法","index":"2.3.2"},{"title":"lodash 中的深拷贝","id":"lodash-中的深拷贝","index":"2.3.3"}]},{"title":"思考","id":"思考","index":"2.4","children":[{"title":"对象成环怎么办？","id":"对象成环怎么办？","index":"2.4.1"}]}]}]}
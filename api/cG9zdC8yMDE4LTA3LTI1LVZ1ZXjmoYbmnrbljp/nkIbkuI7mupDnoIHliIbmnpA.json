{"title":"[转]Vuex框架原理与源码分析","date":"2018-07-24T16:00:00.000Z","author":"Vincent","link":"post/2018-07-25-Vuex框架原理与源码分析","tags":["vue","前端开发"],"updated":"2019-01-02T08:49:00.261Z","content":"<blockquote>\n<p>原文：<a href=\"https://juejin.im/entry/5af5d048f265da0b7b35f94e\" target=\"_blank\" rel=\"noopener\">Vuex 框架原理与源码分析</a></p>\n</blockquote>\n<p>Vuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过 action–mutation–state change 的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。</p>\n<p>最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。</p>\n<p>先将问题抛出来，使学习和研究更有针对性：</p>\n<p><strong>1. 使用 Vuex 只需执行<code>Vue.use(Vuex)</code>，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</strong><br><strong>2. state 内部是如何实现支持模块配置和模块嵌套的？</strong><br><strong>3. 在执行 dispatch 触发 action（commit 同理）的时候，只需传入<code>（type, payload）</code>，action 执行函数中第一个参数 store 从哪里获取的？</strong><br><strong>4. 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</strong><br><strong>5. 调试时的“时空穿梭”功能是如何实现的？</strong></p>\n<blockquote>\n<p>注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex 官方文档进行基础概念的学习。</p>\n</blockquote>\n<h2 id=\"一、框架核心流程\">一、框架核心流程<a href=\"post/2018-07-25-Vuex框架原理与源码分析#一、框架核心流程\"></a></h2><p>进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb55247?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：</p>\n<ul>\n<li>Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。</li>\n<li>dispatch：操作行为触发方法，是唯一能执行 action 的方法。</li>\n<li>actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了<code>Promise</code>的封装，以支持 action 的链式触发。</li>\n<li>commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。</li>\n<li>mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。</li>\n<li>state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。</li>\n<li>getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了  render 中，Vue Components 通过该方法读取全局 state 对象。</li>\n<li>Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。</li>\n</ul>\n<h2 id=\"二、目录结构介绍\">二、目录结构介绍<a href=\"post/2018-07-25-Vuex框架原理与源码分析#二、目录结构介绍\"></a></h2><p>打开 Vuex 项目，看下源码目录结构。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bb88ab4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>Vuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：</p>\n<ul>\n<li>module：提供 module 对象与 module 对象树的创建功能；</li>\n<li>plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；</li>\n<li>helpers.js：提供 action、mutations 以及 getters 的查找 API；</li>\n<li>index.js：是源码主入口文件，提供 store 的各 module 构建安装；</li>\n<li>mixin.js：提供了 store 在 Vue 实例上的装载注入；</li>\n<li>util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。</li>\n</ul>\n<h2 id=\"三、初始化装载与注入\">三、初始化装载与注入<a href=\"post/2018-07-25-Vuex框架原理与源码分析#三、初始化装载与注入\"></a></h2><p>了解大概的目录及对应功能后，下面开始进行源码分析。index.js 中包含了所有的核心代码，从该文件入手进行分析。</p>\n<h3 id=\"3-1-装载实例\">3.1 装载实例<a href=\"post/2018-07-25-Vuex框架原理与源码分析#3-1-装载实例\"></a></h3><p>先看个简单的例子：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  store.js 文件</span></span><br><span class=\"line\"><span class=\"comment\"> *  创建 store 对象，配置 state、action、mutation 以及 getter</span></span><br><span class=\"line\"><span class=\"comment\"> *   </span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// install Vuex 框架</span></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 创建并导出 store 对象。为了方便，不配置任何参数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store()</span><br></pre></td></tr></table></div></figure>\n<p>store.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  vue-index.js 文件</span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./../pages/app.vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#root'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  store, </span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。</p>\n<p>如<strong>问题1</strong>所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。</p>\n<h3 id=\"3-2-装载分析\">3.2 装载分析<a href=\"post/2018-07-25-Vuex框架原理与源码分析#3-2-装载分析\"></a></h3><p>index.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Vue</span><br></pre></td></tr></table></div></figure>\n<p>然后判断若处于浏览器环境下且加载过 Vue，则执行<code>install</code>方法。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// auto install in dist mode</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">window</span>.Vue) &#123;</span><br><span class=\"line\">  install(<span class=\"built_in\">window</span>.Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><code>install</code>方法将 Vuex 装载到 Vue 对象上，<code>Vue.use(Vuex)</code>也是通过它执行，先看下<code>Vue.use</code>方法实现：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">plugin: Function | Object</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.installed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// additional parameters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> args = toArray(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  args.unshift(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.install === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际执行插件的 install 方法</span></span><br><span class=\"line\">    plugin.install.apply(plugin, args)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    plugin.apply(<span class=\"literal\">null</span>, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  plugin.installed = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行<code>applyMixin</code>方法，<code>install</code>实现如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">install</span> (<span class=\"params\">_Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Vue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(</span><br><span class=\"line\">      <span class=\"string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>来看下<code>applyMixin</code>方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的<code>_init</code>方法，实现注入。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> version = <span class=\"built_in\">Number</span>(Vue.version.split(<span class=\"string\">'.'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> usesInit = Vue.config._lifecycleHooks.indexOf(<span class=\"string\">'init'</span>) &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">    Vue.mixin(usesInit ? &#123; <span class=\"attr\">init</span>: vuexInit &#125; : &#123; <span class=\"attr\">beforeCreate</span>: vuexInit &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override init and inject vuex init procedure</span></span><br><span class=\"line\">    <span class=\"comment\">// for 1.x backwards compatibility.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(<span class=\"keyword\">this</span>, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的 <code>$store</code>属性上，子组件从其父组件引用<code>$store</code>属性，层层嵌套进行设置。在任意组件中执行<code>this.$store</code>都能找到装载的那个 store 对象，<code>vuexInit</code>方法实现如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuexInit</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">  <span class=\"comment\">// store injection</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.store</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store = options.parent.$store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>看个图例理解下 store 的传递。</p>\n<p>页面 Vue 结构图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4ba6e4a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>对应 store 流向：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b4bc0c0a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<h2 id=\"四、store-对象构造\">四、store 对象构造<a href=\"post/2018-07-25-Vuex框架原理与源码分析#四、store-对象构造\"></a></h2><p>上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了<strong>问题1</strong>。接下来详细分析 store 对象的内部功能和具体实现，来解答 <strong>为什么actions、getters、mutations 中能从 arguments[0] 中拿到 store 的相关数据?</strong> 等问题。</p>\n<p>store 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b774c3c40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<h3 id=\"4-1-环境判断\">4.1 环境判断<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-1-环境判断\"></a></h3><p>开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  assert(Vue, <span class=\"string\">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class=\"line\">  assert(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span>, <span class=\"string\">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：</p>\n<ol>\n<li>已经执行安装函数进行装载；</li>\n<li>支持<code>Promise</code>语法。</li>\n</ol>\n<p><code>assert</code>函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assert</span> (<span class=\"params\">condition, msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!condition) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`[vuex] <span class=\"subst\">$&#123;msg&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"4-2-数据初始化、module-树构造\">4.2 数据初始化、module 树构造<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-2-数据初始化、module-树构造\"></a></h3><p>环境判断后，根据<code>new</code>构造传入的<code>options</code>或默认值，初始化内部数据。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    state = &#123;&#125;,</span><br><span class=\"line\">    plugins = [],</span><br><span class=\"line\">    strict = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125; = options</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// store internal state</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._committing = <span class=\"literal\">false</span> <span class=\"comment\">// 是否在进行提交状态标识</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._actions = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// acitons 操作对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._mutations = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// mutations 操作对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._wrappedGetters = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// 封装后的 getters 集合对象</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._modules = <span class=\"keyword\">new</span> ModuleCollection(options) <span class=\"comment\">// Vuex 支持 store 分模块传入，存储分析后的 modules</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._modulesNamespaceMap = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>) <span class=\"comment\">// 模块命名空间 map</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._subscribers = [] <span class=\"comment\">// 订阅函数集合，Vuex 提供了 subscribe 功能</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>._watcherVM = <span class=\"keyword\">new</span> Vue() <span class=\"comment\">// Vue 组件用于 watch 监视变化</span></span><br></pre></td></tr></table></div></figure>\n<p>调用<code>new Vuex.store(options)</code>时传入的<code>options</code>对象，用于构造<code>ModuleCollection</code>类，下面看看其功能。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span> (rawRootModule) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// register root module (Vuex.Store options)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> Module(rawRootModule, <span class=\"literal\">false</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// register all nested modules</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rawRootModule.modules) &#123;</span><br><span class=\"line\">    forEachValue(rawRootModule.modules, (rawModule, key) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.register([key], rawModule, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><code>ModuleCollection</code>主要将传入的<code>options</code>对象整个构造为一个 module 对象，并循环调用<code>this.register([key], rawModule, false)</code>为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后<code>options</code>对象被构造成一个完整的组件树。<code>ModuleCollection</code>类还提供了 modules 的更替功能，详细实现可以查看源文件 <a href=\"https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js\" target=\"_blank\" rel=\"noopener\">module-collection.js</a>。</p>\n<h3 id=\"4-3-dispatch-与-commit-设置\">4.3 dispatch 与 commit 设置<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-3-dispatch-与-commit-设置\"></a></h3><p>继续回到 store 的构造函数代码。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind commit and dispatch to self</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; dispatch, commit &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">this</span>.dispatch = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundDispatch</span> (<span class=\"params\">type, payload</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch.call(store, type, payload)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">this</span>.commit = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">boundCommit</span> (<span class=\"params\">type, payload, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> commit.call(store, type, payload, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>封装替换原型中的 dispatch 和 commit 方法，<strong>将 this 指向当前 store 对象</strong>。dispatch 和 commit 方法具体实现如下：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch (_type, _payload) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      type,</span><br><span class=\"line\">      payload</span><br><span class=\"line\">  &#125; = unifyObjectStyle(_type, _payload) <span class=\"comment\">// 配置参数处理</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 当前 type 下所有 action 处理函数集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._actions[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown action type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> entry.length &gt; <span class=\"number\">1</span></span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.all(entry.map(<span class=\"function\"><span class=\"params\">handler</span> =&gt;</span> handler(payload)))</span><br><span class=\"line\">      : entry[<span class=\"number\">0</span>](payload)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>前面提到，dispatch 的功能是触发并传递一些参数<code>(payload)</code>给对应 type 的 action 。因为其支持2种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的<code>this._actions[type]</code>以及下面的<code>this._mutations[type]</code>均是处理过的函数集合，具体内容留到后面进行分析）。</p>\n<p>commit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit (_type, _payload, _options) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// check object-style commit</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      type,</span><br><span class=\"line\">      payload,</span><br><span class=\"line\">      options</span><br><span class=\"line\">  &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> mutation = &#123; type, payload &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = <span class=\"keyword\">this</span>._mutations[type]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!entry) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] unknown mutation type: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 专用修改 state 方法，其他修改 state 方法均是非法修改</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    entry.forEach(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitIterator</span> (<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">      handler(payload)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 订阅者函数遍历执行，传入当前的 mutation 对象和当前的 state</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._subscribers.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> sub(mutation, <span class=\"keyword\">this</span>.state))</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options &amp;&amp; options.silent) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.warn(</span><br><span class=\"line\">        <span class=\"string\">`[vuex] mutation type: <span class=\"subst\">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class=\"line\">        <span class=\"string\">'Use the filter functionality in the vue-devtools'</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>该方法同样支持2种调用方法。先进行参数适配，判断触发 mutation type，利用<code>_withCommit</code>方法执行本次批量触发<code>mutation</code>处理函数，并传入<code>payload</code>参数。执行完成后，通知所有 <code>_subscribers</code>（订阅函数）本次操作的<code>mutation</code>对象以及当前的 state 状态，如果传入了已经移除的<code>silent</code>选项则进行提示警告。</p>\n<h3 id=\"4-4-state修改方法\">4.4 state修改方法<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-4-state修改方法\"></a></h3><p><code>_withCommit</code>是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withCommit (fn) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 保存之前的提交状态</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> committing = <span class=\"keyword\">this</span>._committing</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 进行本次提交，若不设置为 true，直接修改 state，strict 模式下，Vuex 将会产生非法修改 state 的警告</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = <span class=\"literal\">true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 执行 state 的修改操作</span></span><br><span class=\"line\">  fn()</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 修改完成，还原本次修改之前的状态</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>._committing = committing</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>缓存执行时的<code>committing</code>状态将当前状态设置为<code>true</code>后进行本次提交操作，待操作完毕后，将<code>committing</code>状态还原为之前的状态。</p>\n<h3 id=\"4-5-module安装\">4.5 module安装<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-module安装\"></a></h3><p>绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（<code>installModule</code>）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strict mode</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.strict = strict</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// init root module.</span></span><br><span class=\"line\"><span class=\"comment\">// this also recursively registers all sub-modules</span></span><br><span class=\"line\"><span class=\"comment\">// and collects all module getters inside this._wrappedGetters</span></span><br><span class=\"line\">installModule(<span class=\"keyword\">this</span>, state, [], <span class=\"keyword\">this</span>._modules.root)</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"4-5-1-初始化rootState\">4.5.1 初始化rootState<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-1-初始化rootState\"></a></h4><p>上述代码的备注中，提到<code>installModule</code>方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到<code>this._wrappedGetters</code>属性中，让我们看看其中的代码实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">installModule</span> (<span class=\"params\">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isRoot = !path.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespace = store._modules.getNamespace(path)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// register in namespace map</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (namespace) &#123;</span><br><span class=\"line\">    store._modulesNamespaceMap[namespace] = <span class=\"built_in\">module</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 非根组件设置 state 方法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parentState = getNestedState(rootState, path.slice(<span class=\"number\">0</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">const</span> moduleName = path[path.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      Vue.set(parentState, moduleName, <span class=\"built_in\">module</span>.state)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  ······</span><br></pre></td></tr></table></div></figure>\n<p><code>installModule</code>函数可接收5个参数，<code>store</code>、<code>rootState</code>、<code>path</code>、<code>module</code>、<code>hot</code>。<code>store</code>表示当前 Store 实例，<code>rootState</code>表示根 state，<code>path</code>表示当前嵌套模块的路径数组，<code>module</code>表示当前安装的模块，<code>hot</code>当动态改变 modules 或者热更新的时候为<code>true</code>。</p>\n<p>判断是否是根目录，以及是否设置了命名空间，若存在则在<code>namespace</code>中进行 module 的存储，在不是根组件且不是<code>hot</code>条件的情况下，通过<code>getNestedState</code>方法拿到该 module 父级的 state，拿到其所在的 moduleName，调用<code>Vue.set(parentState, moduleName, module.state)</code>方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。<code>getNestedState</code>方法代码很简单，分析 path 拿到 state，如下。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNestedState</span> (<span class=\"params\">state, path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> path.length</span><br><span class=\"line\">    ? path.reduce(<span class=\"function\">(<span class=\"params\">state, key</span>) =&gt;</span> state[key], state)</span><br><span class=\"line\">    : state</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"4-5-2-module上下文环境设置\">4.5.2 module上下文环境设置<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-2-module上下文环境设置\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> local = <span class=\"built_in\">module</span>.context = makeLocalContext(store, namespace, path)</span><br></pre></td></tr></table></div></figure>\n<p>命名空间和根目录条件判断完毕后，接下来定义<code>local</code>变量和<code>module.context</code>的值，执行<code>makeLocalContext</code>方法，<strong>为该 module 设置局部的<code>dispatch</code>、<code>commit</code>方法以及<code>getters</code>和<code>state</code></strong>（由于<code>namespace</code>的存在需要做兼容处理）。</p>\n<h4 id=\"4-5-3-mutations、actions以及getters注册\">4.5.3 mutations、actions以及getters注册<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-3-mutations、actions以及getters注册\"></a></h4><p>定义<code>local</code>环境后，循环注册我们在<code>options</code>中配置的<code>action</code>以及<code>mutation</code>等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b78b2b58f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>下面分析代码逻辑：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册对应模块的 mutation，供 state 修改使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachMutation(<span class=\"function\">(<span class=\"params\">mutation, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerMutation(store, namespacedType, mutation, local)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 注册对应模块的 action，供数据操作、提交 mutation 等异步操作使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachAction(<span class=\"function\">(<span class=\"params\">action, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerAction(store, namespacedType, action, local)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 注册对应模块的 getters，供 state 读取使用</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.forEachGetter(<span class=\"function\">(<span class=\"params\">getter, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> namespacedType = namespace + key</span><br><span class=\"line\">  registerGetter(store, namespacedType, getter, local)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p><code>registerMutation</code>方法中，获取 store 中的对应<code>mutation type</code>的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行<code>commit(‘xxx’, payload)</code>的时候，type 为 xxx 的<code>mutation</code>的所有 handler 都会接收到<code>state</code>以及<code>payload</code>，这就是在 handler 里面拿到 state 的原因。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerMutation</span> (<span class=\"params\">store, type, handler, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取出对应 type 的 mutations-handler 集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class=\"line\">  <span class=\"comment\">// commit 实际调用的不是我们传入的 handler，而是经过封装的</span></span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedMutationHandler</span> (<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 handler 并将 state 传入</span></span><br><span class=\"line\">    handler(local.state, payload)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>action 和 getter 的注册也是同理的，看一下代码（注：前面提到的 <code>this.actions</code>以及<code>this.mutations</code>在此处进行设置）。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerAction</span> (<span class=\"params\">store, type, handler, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 取出对应 type 的 actions-handler 集合</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class=\"line\">  <span class=\"comment\">// 存储新的封装过的 action-handler</span></span><br><span class=\"line\">  entry.push(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入 state 等对象供我们原 action-handler 使用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">      dispatch: local.dispatch,</span><br><span class=\"line\">      commit: local.commit,</span><br><span class=\"line\">      getters: local.getters,</span><br><span class=\"line\">      state: local.state,</span><br><span class=\"line\">      rootGetters: store.getters,</span><br><span class=\"line\">      rootState: store.state</span><br><span class=\"line\">    &#125;, payload, cb)</span><br><span class=\"line\">    <span class=\"comment\">// action 需要支持 promise 进行链式调用，这里进行兼容处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">      res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerGetter</span> (<span class=\"params\">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// getters 只允许存在一个处理函数，若重复需要报错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">`[vuex] duplicate getter key: <span class=\"subst\">$&#123;type&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 存储封装过的 getters 处理函数</span></span><br><span class=\"line\">  store._wrappedGetters[type] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedGetter</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为原 getters 传入对应状态</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> rawGetter(</span><br><span class=\"line\">      local.state, <span class=\"comment\">// local state</span></span><br><span class=\"line\">      local.getters, <span class=\"comment\">// local getters</span></span><br><span class=\"line\">      store.state, <span class=\"comment\">// root state</span></span><br><span class=\"line\">      store.getters <span class=\"comment\">// root getters</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><strong>action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。</strong></p>\n<h4 id=\"4-5-4-子module安装\">4.5.4 子module安装<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-4-子module安装\"></a></h4><p>注册完了根组件的<code>actions</code>、<code>mutations</code>以及<code>getters</code>后，递归调用自身，为子组件注册其<code>state</code>、<code>actions</code>、<code>mutations</code>以及<code>getters</code>等。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.forEachChild(<span class=\"function\">(<span class=\"params\">child, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  installModule(store, rootState, path.concat(key), child, hot)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"4-5-5-实例结合\">4.5.5 实例结合<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-5-5-实例结合\"></a></h4><p>前面介绍了<code>dispatch</code>和<code>commit</code>方法以及<code>actions</code>等的实现，下面结合一个官方的购物车实例中的部分代码来加深理解。</p>\n<p>Vuex 配置代码：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/</span><br><span class=\"line\"> *  store-index.js store 配置文件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> /</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> getters <span class=\"keyword\">from</span> <span class=\"string\">'./getters'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cart <span class=\"keyword\">from</span> <span class=\"string\">'./modules/cart'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> products <span class=\"keyword\">from</span> <span class=\"string\">'./modules/products'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createLogger <span class=\"keyword\">from</span> <span class=\"string\">'../../../src/plugins/logger'</span></span><br><span class=\"line\"> </span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> debug = process.env.NODE_ENV !== <span class=\"string\">'production'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    cart,</span><br><span class=\"line\">    products</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  strict: debug,</span><br><span class=\"line\">  plugins: debug ? [createLogger()] : []</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>Vuex 组件 module 中各模块 state 配置代码部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  cart.js</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  added: [],</span><br><span class=\"line\">  checkoutStatus: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  products.js</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  all: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>加载上述配置后，页面 state 结构如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/12/1635035b79f8a6e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" class=\"article-img\"></p>\n<p>state 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。</p>\n<p>Vuecart 组件代码部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Cart.vue 省略 template 代码，只看 script 部分</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch 方法</span></span><br><span class=\"line\">    checkout (products) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$store.dispatch(<span class=\"string\">'checkout'</span>, products)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Vuexcart.js 组件 action 配置代码部分：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</span><br><span class=\"line\">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> savedCartItems = [...state.added] <span class=\"comment\">// 存储添加到购物车的商品</span></span><br><span class=\"line\">    commit(types.CHECKOUT_REQUEST) <span class=\"comment\">// 设置提交结算状态</span></span><br><span class=\"line\">    shop.buyProducts( <span class=\"comment\">// 提交 api 请求，并传入成功与失败的 cb-func</span></span><br><span class=\"line\">      products,</span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_SUCCESS), <span class=\"comment\">// 请求返回成功则设置提交成功状态</span></span><br><span class=\"line\">      () =&gt; commit(types.CHECKOUT_FAILURE, &#123; savedCartItems &#125;) <span class=\"comment\">// 请求返回失败则设置提交失败状态</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Vue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 <code>checkout</code>，payload 值为<code>products</code>，在源码中 dispatch 方法在所有注册过的 actions 中查找<code>checkout</code>的对应执行数组，取出循环执行。执行的是被封装过的被命名为<code>wrappedActionHandler</code>的方法，真正传入的<code>checkout</code>的执行函数在<code>wrappedActionHandler</code>这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrappedActionHandler</span> (<span class=\"params\">payload, cb</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = handler(&#123;</span><br><span class=\"line\">    dispatch: local.dispatch,</span><br><span class=\"line\">    commit: local.commit,</span><br><span class=\"line\">    getters: local.getters,</span><br><span class=\"line\">    state: local.state,</span><br><span class=\"line\">    rootGetters: store.getters,</span><br><span class=\"line\">    rootState: store.state</span><br><span class=\"line\">  &#125;, payload, cb)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isPromise(res)) &#123;</span><br><span class=\"line\">    res = <span class=\"built_in\">Promise</span>.resolve(res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store._devtoolHook) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      store._devtoolHook.emit(<span class=\"string\">'vuex:error'</span>, err)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>handler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为<code>types.CHECKOUT_REQUEST</code>的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用<code>function wrappedMutationHandler (payload) { handler(local.state, payload)}</code>封装函数来实际调用配置的 mutation 方法。</p>\n<p>看到完源码分析和上面的小实例，应该能理解<code>dispatch</code>、<code>action</code>、<code>commit</code> 和<code>mutation</code>的工作原理了。接着看源码，看看<code>getters</code>是如何实现 state 实时访问的。</p>\n<h3 id=\"4-6-store-vm组件设置\">4.6 store._vm组件设置<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-6-store-vm组件设置\"></a></h3><p>执行完各 module 的 install 后，执行<code>resetStoreVM</code>方法，进行 store 组件的初始化。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class=\"line\"><span class=\"comment\">// (also registers _wrappedGetters as computed properties)</span></span><br><span class=\"line\">resetStoreVM(<span class=\"keyword\">this</span>, state)</span><br></pre></td></tr></table></div></figure>\n<p>综合前面的分析可以了解到，<strong>Vuex 其实构建的就是一个名为<code>store</code>的<code>vm</code>组件，所有配置的<code>state</code>、<code>actions</code>、<code>mutations</code>以及<code>getters</code>都是其组件的属性，所有的操作都是对这个<code>vm</code>组件进行的。</strong></p>\n<p>一起看下<code>resetStoreVM</code>方法的内部实现。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resetStoreVM</span> (<span class=\"params\">store, state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldVm = store._vm <span class=\"comment\">// 缓存前 vm 组件</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// bind store public getters</span></span><br><span class=\"line\">  store.getters = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrappedGetters = store._wrappedGetters</span><br><span class=\"line\">  <span class=\"keyword\">const</span> computed = &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 循环所有处理过的 getters，并新建 computed 对象进行存储，通过Object.defineProperty 方法为 getters 对象建立属性，使得我们通过 this.$store.getters.xxxgetter 能够访问到该 getters</span></span><br><span class=\"line\">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// use computed to leverage its lazy-caching mechanism</span></span><br><span class=\"line\">    computed[key] = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn(store)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">      get: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store._vm[key],</span><br><span class=\"line\">      enumerable: <span class=\"literal\">true</span> <span class=\"comment\">// for local getters</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// use a Vue instance to store the state tree</span></span><br><span class=\"line\">  <span class=\"comment\">// suppress warnings just in case the user has added</span></span><br><span class=\"line\">  <span class=\"comment\">// some funky global mixins</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> silent = Vue.config.silent</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 暂时将 Vue 设为静默模式，避免报出用户加载的某些插件触发的警告</span></span><br><span class=\"line\">  Vue.config.silent = <span class=\"literal\">true</span>   </span><br><span class=\"line\">  <span class=\"comment\">// 设置新的 storeVm，将当前初始化的 state 以及 getters 作为 computed 属性（刚刚遍历生成的）</span></span><br><span class=\"line\">  store._vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    data: &#123; state &#125;,</span><br><span class=\"line\">    computed</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 恢复 Vue 的模式</span></span><br><span class=\"line\">  Vue.config.silent = silent</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// enable strict mode for new vm</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (store.strict) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该方法对 state 执行 $watch 以禁止从 mutation 外部修改 state</span></span><br><span class=\"line\">    enableStrictMode(store)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 若不是初始化过程执行的该方法，将旧的组件 state 设置为 null，强制更新所有监听者(watchers)，待更新生效，DOM 更新完成后，执行 vm 组件的 destroy 方法进行销毁，减少内存的占用</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldVm) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// dispatch changes in all subscribed watchers</span></span><br><span class=\"line\">    <span class=\"comment\">// to force getter re-evaluation.</span></span><br><span class=\"line\">    store._withCommit(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      oldVm.state = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><code>resetStoreVm</code>方法创建了当前<code>store</code>实例的<code>_vm</code>组件，至此<code>store</code>就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enableStrictMode</span> (<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  store._vm.$watch(<span class=\"string\">'state'</span>, () =&gt; &#123;</span><br><span class=\"line\">    assert(store._committing, <span class=\"string\">`Do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class=\"line\">  &#125;, &#123; <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sync</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>很简单的应用，监视 state 的变化，如果没有通过<code>this._withCommit()</code>方法进行 state 修改，则报错。</p>\n<h3 id=\"4-7-plugin注入\">4.7 plugin注入<a href=\"post/2018-07-25-Vuex框架原理与源码分析#4-7-plugin注入\"></a></h3><p>最后执行<code>plugin</code>的植入。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins.concat(devtoolPlugin).forEach(<span class=\"function\"><span class=\"params\">plugin</span> =&gt;</span> plugin(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></div></figure>\n<p><code>devtoolPlugin</code>提供的功能有3个：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 触发 Vuex 组件初始化的 hook</span></span><br><span class=\"line\">devtoolHook.emit(<span class=\"string\">'vuex:init'</span>, store)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 2. 提供“时空穿梭”功能，即 state 操作的前进和倒退</span></span><br><span class=\"line\">devtoolHook.on(<span class=\"string\">'vuex:travel-to-state'</span>, targetState =&gt; &#123;</span><br><span class=\"line\">  store.replaceState(targetState)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 3. mutation 被执行时，触发 hook，并提供被触发的 mutation 函数和当前的 state 状态</span></span><br><span class=\"line\">store.subscribe(<span class=\"function\">(<span class=\"params\">mutation, state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  devtoolHook.emit(<span class=\"string\">'vuex:mutation'</span>, mutation, state)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。</p>\n<h3 id=\"五、总结\">五、总结<a href=\"post/2018-07-25-Vuex框架原理与源码分析#五、总结\"></a></h3><p>最后我们回过来看文章开始提出的5个问题。</p>\n<p><strong>1. 问：使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？</strong></p>\n<blockquote>\n<p>答：<code>Vue.use(Vuex)</code>方法执行的是<code>install</code>方法，它实现了 Vue 实例对象的<code>init</code>方法封装和注入，使传入的<code>store</code>对象被设置到 Vue 上下文环境的<code>$store</code>中。因此在 Vue Component 任意地方都能够通过<code>this.$store</code>访问到该<code>store</code>。</p>\n</blockquote>\n<p><strong>2. 问：state内部支持模块配置和模块嵌套，如何实现的？</strong></p>\n<blockquote>\n<p>答：在<code>store</code>构造方法中有<code>makeLocalContext</code>方法，所有<code>module</code>都会有一个<code>local context</code>，根据配置时的<code>path</code>进行匹配。所以执行如<code>dispatch(‘submitOrder’, payload)</code>这类<code>action</code>时，默认的拿到都是<code>module</code>的<code>local state</code> ，如果要访问最外层或者是其他<code>module</code>的<code>state</code>，只能从<code>rootState</code>按照<code>path</code>路径逐步进行访问。</p>\n</blockquote>\n<p><strong>3.  问：在执行dispatch触发action(commit同理)的时候，只需传入(type, payload)，action执行函数中第一个参数store从哪里获取的？</strong></p>\n<blockquote>\n<p>答：<code>store</code>初始化时，所有配置的<code>action</code>和<code>mutation</code>以及<code>getters</code>均被封装过。在执行如<code>dispatch(‘submitOrder’, payload)</code>的时候，<code>actions</code>中<code>type</code>为<code>submitOrder</code>的所有处理方法都是被封装后的，其第一个参数为当前的<code>store</code>对象，所以能够获取到<code>{ dispatch, commit, state, rootState }</code>等数据。</p>\n</blockquote>\n<p><strong>4. 问：Vuex如何区分state是外部直接修改，还是通过mutation方法修改的？</strong></p>\n<blockquote>\n<p>答：Vuex 中修改<code>state</code>的唯一渠道就是执行<code>commit(‘xx’, payload)</code>方法，其底层通过执行<code>this._withCommit(fn)</code>设置<code>_committing</code>标志变量为<code>true</code>，然后才能修改<code>state</code>，修改完毕还需要还原<code>_committing</code>变量。外部修改虽然能够直接修改<code>state</code>，但是并没有修改<code>_committing</code>标志位，所以只要<code>watch</code>一下<code>state</code>，<code>state</code> change 时判断是否<code>_committing</code>值为<code>true</code>，即可判断修改的合法性。</p>\n</blockquote>\n<p><strong>5. 问：调试时的”时空穿梭”功能是如何实现的？</strong></p>\n<blockquote>\n<p>答：<code>devtoolPlugin</code>中提供了此功能。因为<code>dev</code>模式下所有的<code>state</code> change 都会被记录下来，’时空穿梭’功能其实就是将当前的<code>state</code>替换为记录中某个时刻的<code>state</code>状态，利用<code>store.replaceState(targetState)</code>方法将执行<code>this._vm.state = state</code>实现。</p>\n</blockquote>\n<p>源码中还有一些工具函数类似<code>registerModule</code>、<code>unregisterModule</code>、<code>hotUpdate</code>、<code>watch</code>以及<code>subscribe</code>等，如有兴趣可以打开源码看看，这里不再细述。</p>\n","prev":{"title":"[转]Vuex 2.0 源码分析","link":"post/2018-07-26-Vuex源码分析"},"next":{"title":"前端性能优化-2","link":"post/2018-07-23-前端性能优化-2"},"plink":"https://vincentdou.github.io/blog/post/2018-07-25-Vuex框架原理与源码分析/","toc":[{"title":"一、框架核心流程","id":"一、框架核心流程","index":"1"},{"title":"二、目录结构介绍","id":"二、目录结构介绍","index":"2"},{"title":"三、初始化装载与注入","id":"三、初始化装载与注入","index":"3","children":[{"title":"3.1 装载实例","id":"3-1-装载实例","index":"3.1"},{"title":"3.2 装载分析","id":"3-2-装载分析","index":"3.2"}]},{"title":"四、store 对象构造","id":"四、store-对象构造","index":"4","children":[{"title":"4.1 环境判断","id":"4-1-环境判断","index":"4.1"},{"title":"4.2 数据初始化、module 树构造","id":"4-2-数据初始化、module-树构造","index":"4.2"},{"title":"4.3 dispatch 与 commit 设置","id":"4-3-dispatch-与-commit-设置","index":"4.3"},{"title":"4.4 state修改方法","id":"4-4-state修改方法","index":"4.4"},{"title":"4.5 module安装","id":"4-5-module安装","index":"4.5","children":[{"title":"4.5.1 初始化rootState","id":"4-5-1-初始化rootState","index":"4.5.1"},{"title":"4.5.2 module上下文环境设置","id":"4-5-2-module上下文环境设置","index":"4.5.2"},{"title":"4.5.3 mutations、actions以及getters注册","id":"4-5-3-mutations、actions以及getters注册","index":"4.5.3"},{"title":"4.5.4 子module安装","id":"4-5-4-子module安装","index":"4.5.4"},{"title":"4.5.5 实例结合","id":"4-5-5-实例结合","index":"4.5.5"}]},{"title":"4.6 store._vm组件设置","id":"4-6-store-vm组件设置","index":"4.6"},{"title":"4.7 plugin注入","id":"4-7-plugin注入","index":"4.7"},{"title":"五、总结","id":"五、总结","index":"4.8"}]}]}
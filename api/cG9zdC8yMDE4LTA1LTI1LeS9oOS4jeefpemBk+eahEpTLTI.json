{"title":"你不知道的JS-this与对象原型-this","date":"2018-05-24T16:00:00.000Z","author":"Vincent","link":"post/2018-05-25-你不知道的JS-2","tags":["JavaScript","你不知道的JS","前端开发"],"updated":"2019-01-02T08:49:00.266Z","content":"<h2 id=\"this是什么？\">this是什么？<a href=\"post/2018-05-25-你不知道的JS-2#this是什么？\"></a></h2><ul>\n<li>函数内部的<code>this</code>并不是指向函数自己；</li>\n<li><code>this</code>不会以任何方式指向函数的词法作用域；</li>\n<li><code>this</code>不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。<code>this</code>绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</li>\n</ul>\n<p>当一个函数被调用时，会建立 <strong>活动记录</strong> （有时也称为执行上下文）。这个记录包含函数是从何处（调用栈 —— call-stack）被调用的，函数是如何被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的<code>this</code>引用。</p>\n<h2 id=\"this全面解析\">this全面解析<a href=\"post/2018-05-25-你不知道的JS-2#this全面解析\"></a></h2><h3 id=\"调用点（Call-site）\">调用点（Call-site）<a href=\"post/2018-05-25-你不知道的JS-2#调用点（Call-site）\"></a></h3><p>寻找调用点就是寻找函数被调用的位置，最重要的是分析调用栈，调用点就在当前执行中的函数的前一个调用中。</p>\n<blockquote>\n<p>调用栈: 使我们到达当前执行位置而被调用的所有方法的堆栈</p>\n</blockquote>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用栈是: `baz`</span></span><br><span class=\"line\">\t<span class=\"comment\">// 我们的调用点是 global scope（全局作用域）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"baz\"</span> );</span><br><span class=\"line\">\tbar(); <span class=\"comment\">// &lt;-- `bar` 的调用点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用栈是: `baz` -&gt; `bar`</span></span><br><span class=\"line\">\t<span class=\"comment\">// 我们的调用点位于 `baz`</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"string\">\"bar\"</span> );</span><br><span class=\"line\">\tfoo(); <span class=\"comment\">// &lt;-- `foo` 的 call-site</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用栈是: `baz` -&gt; `bar` -&gt; `foo`</span></span><br><span class=\"line\">  <span class=\"comment\">// 我们的调用点位于 `bar`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo\"</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); <span class=\"comment\">// &lt;-- `baz` 的调用点</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"绑定规则\">绑定规则<a href=\"post/2018-05-25-你不知道的JS-2#绑定规则\"></a></h3><h4 id=\"默认绑定（Default-Binding）\">默认绑定（Default Binding）<a href=\"post/2018-05-25-你不知道的JS-2#默认绑定（Default-Binding）\"></a></h4><p>当我们直接使用不带任何修饰的函数引用进行调用时，对应默认绑定。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里 this 指向全局对象</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n<p>strict 模式下对于默认绑定来说全局对象是不合法的，所以<code>this</code>将被设置为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: `this` is `undefined`</span></span><br></pre></td></tr></table></div></figure>\n<p>注意：this的绑定规则基于调用点，但判断是否在 strict 模式则是取决于函数体。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里不是严格模式</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"隐式绑定（Implicit-Binding）\">隐式绑定（Implicit Binding）<a href=\"post/2018-05-25-你不知道的JS-2#隐式绑定（Implicit-Binding）\"></a></h4><p>另一种要考虑的规则是：调用点是否有上下文对象，或者说是否被某个对象拥有或者包含。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里函数 foo() 是先定义然后作为引用属性添加到 obj 中的，严格说函数 foo() 不属于 obj。</span></span><br><span class=\"line\"><span class=\"comment\">// 然而调用栈会使用 obj 上下文来引用函数，因此可以说函数被调用的时候 obj “拥有”或“包含”它。</span></span><br></pre></td></tr></table></div></figure>\n<p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的<code>this</code>绑定到这个上下文对象。因此<code>this.a</code>和<code>obj.a</code>是一样的。</p>\n<blockquote>\n<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</p>\n</blockquote>\n<p><strong>隐式丢失</strong></p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo; <span class=\"comment\">// 函数引用！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// `a` 也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></div></figure>\n<p>尽管<code>bar</code>似乎是<code>obj.foo</code>的引用，但实际上它只是另一个<code>foo</code>本身的引用而已。另外，起作用的调用点是<code>bar()</code>，一个直白，毫无修饰的调用，因此这里适用默认绑定。</p>\n<p>当我们传递一个回调函数时，参数传递其实就是一种隐式赋值，因此我们在传入参数时也会被隐式的引用赋值：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">  fn(); <span class=\"comment\">// &lt;-- 调用点!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// `a` 也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">doFoo( obj.foo ); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></div></figure>\n<h4 id=\"显式绑定（Explicit-Binding）\">显式绑定（Explicit Binding）<a href=\"post/2018-05-25-你不知道的JS-2#显式绑定（Explicit-Binding）\"></a></h4><p>JavaScript 中绝大多数内置的函数以及你创建的所有的函数，都可以访问<code>call(..)</code>和<code>apply(..)</code>。我们可以通过它来进行显式绑定。不过单独依靠明确绑定仍然不能解决函数“丢失”自己原本的<code>this</code>绑定的问题。</p>\n<p><strong>硬绑定（Hard Binding）</strong></p>\n<p>ES5 的内建工具提供<code>Function.prototype.bind</code>进行硬绑定：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></div></figure>\n<p><code>bind(..)</code>返回一个硬编码的新函数，它使用你指定的<code>this</code>环境来调用原本的函数。</p>\n<p>它的思想来自这里：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单的 `bind` 帮助函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = bind( foo, obj );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></div></figure>\n<p>这里创建了一个函数，在它的内部手动调用<code>fn.apply(obj, arguments)</code>，由此强制<code>this</code>绑定到<code>obj</code>并调用<code>fn</code>。无论你过后怎样调用函数，它总是手动使用<code>obj</code>调用<code>foo</code>。</p>\n<h4 id=\"new-绑定（new-Binding）\">new 绑定（new Binding）<a href=\"post/2018-05-25-你不知道的JS-2#new-绑定（new-Binding）\"></a></h4><p>在 JavaScript 中，构造函数只是一些使用<code>new</code>操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，他们只是被<code>new</code>操作符调用的普通函数而已。</p>\n<p>可以说任何函数，都可以在前面加上<code>new</code>来被调用，这使函数调用成为一个构造器调用（constructor call）。这是一个重要而微妙的区别：实际上不存在“构造器函数”这样的东西，而只有函数的构造器调用。</p>\n<h3 id=\"优先级\">优先级<a href=\"post/2018-05-25-你不知道的JS-2#优先级\"></a></h3><p>判定<code>this</code>的顺序：</p>\n<ol>\n<li>函数是通过<code>new</code>被调用的吗（new 绑定）？如果是，<code>this</code>就是新构建的对象。</li>\n<li>函数是通过<code>call</code>或<code>apply</code>被调用（明确绑定），甚至是隐藏在<code>bind</code>硬绑定之中吗？如果是，<code>this</code>就是那个被明确指定的对象。</li>\n<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，<code>this</code>就是那个环境对象。</li>\n<li>否则，使用默认的<code>this</code>（默认绑定）。如果在 strict mode 下，就是<code>undefined</code>，否则是<code>global</code>对象。</li>\n</ol>\n<h3 id=\"绑定的特例\">绑定的特例<a href=\"post/2018-05-25-你不知道的JS-2#绑定的特例\"></a></h3><h4 id=\"被忽略的-this\">被忽略的 this<a href=\"post/2018-05-25-你不知道的JS-2#被忽略的-this\"></a></h4><p>如果你传递<code>null</code>或<code>undefined</code>作为<code>call</code>、<code>apply</code>或<code>bind</code>的<code>this</code>绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call( <span class=\"literal\">null</span> ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n<p>进行<code>this</code>绑定的时候故意传<code>null</code>可以对参数进行柯里化：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组散开作为参数</span></span><br><span class=\"line\">foo.apply( <span class=\"literal\">null</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `bind(..)` 进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( <span class=\"literal\">null</span>, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></div></figure>\n<p><strong>更安全的this</strong></p>\n<p>对于那些确实使用了<code>this</code>引用的函数，默认绑定规则会把<code>this</code>绑定到全局对象（在浏览器中是 window）上，这将导致不可预计的后果（比如修改全局对象）。</p>\n<blockquote>\n<p>DMZ（demilitarized zone，非军事区）对象：空的非委托的对象</p>\n</blockquote>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们的 DMZ 空对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ø = <span class=\"built_in\">Object</span>.create( <span class=\"literal\">null</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将数组散开作为参数</span></span><br><span class=\"line\">foo.apply( ø, [<span class=\"number\">2</span>, <span class=\"number\">3</span>] ); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 `bind(..)` 进行 currying</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( ø, <span class=\"number\">2</span> );</span><br><span class=\"line\">bar( <span class=\"number\">3</span> ); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p><code>Object.create(null)</code>是创建完全为空的对象的最简单方法。<code>Object.create(null)</code>和<code>{}</code>很相似，但是没有指向<code>Object.prototype</code>的委托，所以它比<code>{}</code>“空得更彻底”。</p>\n</blockquote>\n<h4 id=\"间接\">间接<a href=\"post/2018-05-25-你不知道的JS-2#间接\"></a></h4><p>对函数的“间接引用”适用默认绑定规则：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">foo</span>: foo &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = &#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o.foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">(p.foo = o.foo)(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n<p>赋值表达式<code>p.foo = o.foo</code>的返回值是目标函数的引用。所以调用点就是<code>foo()</code>而不是<code>p.foo()</code>或<code>o.foo()</code>。所以这里适用默认绑定。</p>\n<h3 id=\"词法this\">词法this<a href=\"post/2018-05-25-你不知道的JS-2#词法this\"></a></h3><p>ES6 引入的箭头函数不适用于这些规则，箭头函数从外层作用域来决定<code>this</code>绑定。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个箭头函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// this 遵从词法作用域继承自 foo()</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); <span class=\"comment\">// 2, 不是3!</span></span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>箭头函数的绑定是无法被修改的（<code>new</code>也不行！）</p>\n</blockquote>\n","prev":{"title":"你不知道的JS-this与对象原型-对象","link":"post/2018-06-03-你不知道的JS-3"},"next":{"title":"你不知道的JS-作用域与闭包","link":"post/2018-05-14-你不知道的JS-1"},"plink":"https://vincentdou.github.io/blog/post/2018-05-25-你不知道的JS-2/","toc":[{"title":"this是什么？","id":"this是什么？","index":"1"},{"title":"this全面解析","id":"this全面解析","index":"2","children":[{"title":"调用点（Call-site）","id":"调用点（Call-site）","index":"2.1"},{"title":"绑定规则","id":"绑定规则","index":"2.2","children":[{"title":"默认绑定（Default Binding）","id":"默认绑定（Default-Binding）","index":"2.2.1"},{"title":"隐式绑定（Implicit Binding）","id":"隐式绑定（Implicit-Binding）","index":"2.2.2"},{"title":"显式绑定（Explicit Binding）","id":"显式绑定（Explicit-Binding）","index":"2.2.3"},{"title":"new 绑定（new Binding）","id":"new-绑定（new-Binding）","index":"2.2.4"}]},{"title":"优先级","id":"优先级","index":"2.3"},{"title":"绑定的特例","id":"绑定的特例","index":"2.4","children":[{"title":"被忽略的 this","id":"被忽略的-this","index":"2.4.1"},{"title":"间接","id":"间接","index":"2.4.2"}]},{"title":"词法this","id":"词法this","index":"2.5"}]}]}
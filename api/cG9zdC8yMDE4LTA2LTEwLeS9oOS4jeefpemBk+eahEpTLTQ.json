{"title":"你不知道的JS-异步与性能","date":"2018-06-09T16:00:00.000Z","author":"Vincent","link":"post/2018-06-10-你不知道的JS-4","tags":["JavaScript","你不知道的JS","前端开发"],"updated":"2019-01-02T08:49:00.220Z","content":"<h3 id=\"异步-现在与稍后\">异步: 现在与稍后<a href=\"post/2018-06-10-你不知道的JS-4#异步-现在与稍后\"></a></h3><p>每当你将一部分代码包进 function 并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax应答等等），你就创建了一个<strong>稍后</strong>代码块儿，也因此在你的程序中引入了异步。</p>\n<h4 id=\"异步控制台\">异步控制台<a href=\"post/2018-06-10-你不知道的JS-4#异步控制台\"></a></h4><p>使用 console 可能会遇到这样的情况：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\tindex: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 稍后</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 可能&#123; index: 1 &#125;，也可能&#123; index: 2 &#125;。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再稍后</span></span><br><span class=\"line\">a.index++;</span><br></pre></td></tr></table></div></figure>\n<p>console 不是 JavaScript 官方的一部分，而是由宿主环境添加到JS上的。所以关于它如何工作，没有相应的语言规范或一组需求。某些条件下，有些浏览器为了更好的性能选择在后台异步地处理 console I/O。所以有时候 console.log(..) 实际上不会立即输出它得到的东西。</p>\n<blockquote>\n<p>如果你遇到了这种罕见的情况，最好的选择是使用JS调试器的断点，而不是依赖console的输出。第二好的选择是通过将目标对象序列化为一个string强制取得一个它的快照，比如用JSON.stringify(..)。</p>\n</blockquote>\n<h4 id=\"事件轮询（Event-Loop）\">事件轮询（Event Loop）<a href=\"post/2018-06-10-你不知道的JS-4#事件轮询（Event-Loop）\"></a></h4><p>JS 引擎对时间没有天生的感觉，反而是一个任意 JS 代码段的按需执行环境。是它周围的环境在不停地安排“事件”。</p>\n<p>通过一些伪代码来对它形成一个概念：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `eventLoop`是一个像队列一样的数组（先进先出）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> eventLoop = [ ];</span><br><span class=\"line\"><span class=\"keyword\">var</span> event;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// “永远”执行</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行一个\"tick\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (eventLoop.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 在队列中取得下一个事件</span></span><br><span class=\"line\">\t\tevent = eventLoop.shift();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 现在执行下一个事件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tevent();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">\t\t\treportError(err);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>有一个通过 while 循环来表现的持续不断的循环，这个循环的每一次迭代称为一个“tick”。在每一个“tick”中，如果队列中有一个事件在等待，它就会被取出执行。这些事件就是你的函数回调。</p>\n<h4 id=\"协作并发\">协作并发<a href=\"post/2018-06-10-你不知道的JS-4#协作并发\"></a></h4><p>将一个长时间运行的“进程”打断为许多步骤或批处理，使得其他的并发“进程”有机会将它们的操作穿插进事件轮询队列。</p>\n<p>想象这种场景：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `response(..)`从Ajax调用收到一个结果数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 连接到既存的`res`数组上</span></span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t<span class=\"comment\">// 制造一个新的变形过的数组，所有的`data`值都翻倍</span></span><br><span class=\"line\">\t\tdata.map( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.1\"</span>, response );</span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.2\"</span>, response );</span><br></pre></td></tr></table></div></figure>\n<p>如果 “<a href=\"http://some.url.1&quot;\" target=\"_blank\" rel=\"noopener\">http://some.url.1&quot;</a> 首先返回它的结果，整个结果列表将会一次性映射进 res。如果只有几千或更少的结果记录，一般来说不是什么大事。但假如有1千万个记录，那么就可能会花一段时间运行。当这样的“处理”运行时，页面上没有任何事情可以发生，包括不能有另一个 response(..) 调用，不能有 UI 更新，甚至不能有用户事件比如滚动，打字，按钮点击等。非常痛苦。</p>\n<p>为了制造协作性更强、更友好而且不独占事件轮询队列的并发系统，你可以在一个异步批处理中处理这些结果，在批处理的每一步都“让出”事件轮询来让其他等待的事件发生：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `response(..)`从Ajax调用收到一个结果数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">response</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 我们一次只处理1000件</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> chunk = data.splice( <span class=\"number\">0</span>, <span class=\"number\">1000</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 连接到既存的`res`数组上</span></span><br><span class=\"line\">\tres = res.concat(</span><br><span class=\"line\">\t\t<span class=\"comment\">// 制造一个新的变形过的数组，所有的`data`值都翻倍</span></span><br><span class=\"line\">\t\tchunk.map( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> val * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125; )</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 还有东西要处理吗？</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (data.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 异步规划下一个批处理</span></span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\tresponse( data );</span><br><span class=\"line\">\t\t&#125;, <span class=\"number\">0</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ajax(..) 是某个包中任意的Ajax函数</span></span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.1\"</span>, response );</span><br><span class=\"line\">ajax( <span class=\"string\">\"http://some.url.2\"</span>, response );</span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>从技术上讲，setTimeout(..0) 没有直接将一条记录插入事件轮询队列。计时器将会在下一个运行机会将事件插入。比如，两个连续的 setTimeout(..0) 调用不会严格保证以调用的顺序被处理，所以我们可能看到各种时间偏移的情况，使这样的事件的顺序是不可预知的。</p>\n</blockquote>\n<h3 id=\"回调\">回调<a href=\"post/2018-06-10-你不知道的JS-4#回调\"></a></h3>","prev":{"title":"JS机制梳理总结","link":"post/2018-06-20-JS机制梳理总结"},"next":{"title":"你不知道的JS-this与对象原型-对象","link":"post/2018-06-03-你不知道的JS-3"},"plink":"https://vincentdou.github.io/blog/post/2018-06-10-你不知道的JS-4/"}
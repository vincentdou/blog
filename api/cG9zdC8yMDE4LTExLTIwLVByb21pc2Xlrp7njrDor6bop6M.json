{"title":"[转]写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise","date":"2018-11-19T16:00:00.000Z","author":"Vincent","link":"post/2018-11-20-Promise实现详解","tags":["ES6","JavaScript","Promise","前端开发"],"updated":"2019-01-02T08:49:00.261Z","content":"<h3 id=\"Promise-只是一个-Event-Loop-中的-microtask\">Promise 只是一个 Event Loop 中的 microtask<a href=\"post/2018-11-20-Promise实现详解#Promise-只是一个-Event-Loop-中的-microtask\"></a></h3><p>深入了解过 Promise 的人都知道，Promise 所说的异步执行，只是将 Promise 构造函数中 resolve，reject 方法和注册的 callback 转化为 eventLoop的 microtask/Promise Job，并放到 Event Loop 队列中等待执行，也就是 Javascript 单线程中的“异步执行”。</p>\n<p><a href=\"https://promisesaplus.com/#point-67\" target=\"_blank\" rel=\"noopener\">Promise/A+ 规范</a>中，并没有明确是以 microtask 还是 macrotask 形式放入队列，对没有 microtask 概念的宿主环境采用 setTimeout 等 task/Job 类的任务。规范中另外明确的一点也非常重要：回调函数的异步调用必须在当前 context，也就是 JS stack 为空之后执行。</p>\n<p>在最新的 <a href=\"http://www.ecma-international.org/ecma-262/7.0/index.html#sec-promisereactionjob\" target=\"_blank\" rel=\"noopener\">ECMAScript 规范</a>中，明确了 Promise 必须以 Promise Job 的形式入 Job 队列（也就是 microtask），并仅在没有运行的 stack(stack 为空的情况下)才可以初始化执行。</p>\n<p>HTML 规范也提出，在 stack 清空后，执行 microtask 的检查方法。也就是必须在 stack 为空的情况下才能执行。</p>\n<p>Google Chrome 的开发者 Jake Archibald （ES6-promise 作者）的文章将这个区分的问题描述得很清楚。假如要在 Javascript 平台或者引擎中实现 Promise，优先以 microtask/Promise Job 方式实现。目前主流浏览器的 Javascript 引擎原生实现，主流的 Promise 库（es6-promise，bluebrid）基本都是使用 microtask/Promise Job 的形式将 Promise 放入队列。</p>\n<p>其他以 microtask/Promise Job 形式实现的方法还有：process.nextTick，setImmediate，postMessage，MessageChannel 等</p>\n<p>根据规范，microtask 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 microtask。原生的 setTimeout 就算是将延迟设置为 0 也会有 4 ms 的延迟，会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 microtask。</p>\n<p>对于在不通宿主环境中选择合适的 microtask，可以选择 asap 和 setImmediate的代码作为参考。</p>\n<h3 id=\"Promise-的中的同步与异步\">Promise 的中的同步与异步<a href=\"post/2018-11-20-Promise实现详解#Promise-的中的同步与异步\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  resolve(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a, c, b</span></span><br></pre></td></tr></table></div></figure>\n<p>使用过 Promise 的人都知道输出 a, c, b，但有多少人可以清楚地说出从创建 Promise 对象到执行完回调的过程？下面是一个完整的解释：</p>\n<p><strong>构造函数中的输出执行是同步的，输出 a, 执行 resolve 函数，将 Promise 对象状态置为 resolved，输出 c。同时注册这个 Promise 对象的回调 then 函数。整个脚本执行完，stack 清空。event loop 检查到 stack 为空，再检查 microtask 队列中是否有任务，发现了 Promise 对象的 then 回调函数产生的 microtask，推入 stack，执行。输出 b，event loop的列队为空，stack 为空，脚本执行完毕。</strong></p>\n<h3 id=\"Promise-构造函数，选择平台的-microtask-实现\">Promise 构造函数，选择平台的 microtask 实现<a href=\"post/2018-11-20-Promise实现详解#Promise-构造函数，选择平台的-microtask-实现\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Simply choose a microtask</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncFn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> process === <span class=\"string\">'object'</span> &amp;&amp; process !== <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">typeof</span>(process.nextTick) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> process.nextTick</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(setImmediate) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setImmediate</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> setTimeout</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// States</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'PENDING'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">'RESOLVED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'REJECTED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Constructor</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MimiPromise</span>(<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = PENDING</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.executedData = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.multiPromise2 = []</span><br><span class=\"line\"></span><br><span class=\"line\">  resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    settlePromise(<span class=\"keyword\">this</span>, RESOLVED, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  reject = <span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    settlePromise(<span class=\"keyword\">this</span>, REJECTED, reason)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  executor(resolve, reject)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>state 和 executedData 都容易理解，但是必须要理解一下为什么要维护一个 multiPromise2 数组。由于规范中说明，每个调用过 then 方法的 promise 对象必须返回一个新的 promise2 对象，所以最好的方法是当调用 then 方法的时候将一个属于这个 then 方法的 promise2 加入队列，在 promise 对象中维护这些新的 promise2 的状态。</p>\n<ul>\n<li>executor： promise 构造函数的执行函数参数</li>\n<li>state：promise 的状态</li>\n<li>multiPromise2：维护的每个注册 then 方法需要返回的新 promise2</li>\n<li>resolve：函数定义了将对象设置为 RESOLVED 的过程</li>\n<li>reject：函数定义了将对象设置为 REJECTED 的过程</li>\n</ul>\n<p>最后执行构造函数 executor，并调用 promise 内部的私有方法 resolve 和 reject。</p>\n<h3 id=\"settlePromise-如何将一个新建的-Promise-settled\">settlePromise 如何将一个新建的 Promise settled<a href=\"post/2018-11-20-Promise实现详解#settlePromise-如何将一个新建的-Promise-settled\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Settle any promise, set state and value, check if there is</span></span><br><span class=\"line\"><span class=\"comment\">// any then callback and async process them with the origin promise,</span></span><br><span class=\"line\"><span class=\"comment\">// return promise2(aka promise2), and callback itself.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settlePromise</span>(<span class=\"params\">promise, executedState, executedData</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (promise.state !== PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  promise.state = executedState</span><br><span class=\"line\">  promise.executedData = executedData</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (promise.multiPromise2.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> callbackType = executedState === RESOLVED ? <span class=\"string\">\"resolvedCallback\"</span> : <span class=\"string\">\"rejectedCallback\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (promise2 <span class=\"keyword\">of</span> promise.multiPromise2) &#123;</span><br><span class=\"line\">      asyncProcessCallback(promise, promise2, promise2[callbackType])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>第一个判断条件很重要，因为 Promise 的状态是不可逆的。在 settlePromise 的过程中假如状态不是 PENDING，则不需要继续执行下去。</p>\n<p>当前 settlePromise 的环境，可以有三种情况：</p>\n<ul>\n<li>异步延迟执行 settlePromise 方法，线程已经同步注册好 then 方法，需要执行所有注册的 then 回调函数；</li>\n<li>同步执行 settlePromise 方法，then 方法未执行，后面需要执行的 then方法会在注册的过程中直接执行；</li>\n<li>无论执行异步 settlePromise 还是同步 settlePromise 方法，并没有注册的 then 方法需要执行，只需要将本 Promise 对象的状态设置好即可。</li>\n</ul>\n<h3 id=\"then-方法的注册和立即执行\">then 方法的注册和立即执行<a href=\"post/2018-11-20-Promise实现详解#then-方法的注册和立即执行\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MimiPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolvedCallback, rejectedCallback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2 = <span class=\"keyword\">new</span> MimiPromise(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> resolvedCallback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    promise2.resolvedCallback = resolvedCallback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> rejectedCallback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    promise2.rejectedCallback = rejectedCallback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.multiPromise2.push(promise2)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === RESOLVED) &#123;</span><br><span class=\"line\">    asyncProcessCallback(<span class=\"keyword\">this</span>, promise2, promise2.resolvedCallback)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === REJECTED) &#123;</span><br><span class=\"line\">    asyncProcessCallback(<span class=\"keyword\">this</span>, promise2, promise2.rejectedCallback)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>每个注册 then 方法都需要返回一个新的 promise2 对象，根据当前 promise 对象的 state，会出现三种情况：</p>\n<ul>\n<li>当前 promise 对象处于 PENDING 状态。构造函数异步执行了 settlePromise 方法，需要将这个 then 方法对应返回的 promise2 放入当前 promise 的 multiPromise2 队列当中，返回这个 promise2。以后当 settlePromise 方法异步执行的时候，执行全部注册的 then 回调方法</li>\n<li>当前 promise 对象处于 RESOLVED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。</li>\n<li>当前 promise 对象处于 REJECTED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。</li>\n</ul>\n<h3 id=\"异步执行回调函数\">异步执行回调函数<a href=\"post/2018-11-20-Promise实现详解#异步执行回调函数\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Async process callback with origin promise and promise2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncProcessCallback</span>(<span class=\"params\">promise, promise2, callback</span>) </span>&#123;</span><br><span class=\"line\">  asyncFn(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!callback) &#123;</span><br><span class=\"line\">      settlePromise(promise2, promise.state, promise.executedData);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      x = callback(promise.executedData)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      settlePromise(promise2, REJECTED, e)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    settleWithX(promise2, x)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里用到我们之前选取的平台异步执行函数，异步执行 callback。假如 callback 没有定义，则将返回 promise2 的状态转换为当前 promise 的状态。然后将 callback 执行。最后再 settleWithX promise2 与 callback 返回的对象 x。</p>\n<h3 id=\"最后的-settleWithX-和-settleXthen\">最后的 settleWithX 和 settleXthen<a href=\"post/2018-11-20-Promise实现详解#最后的-settleWithX-和-settleXthen\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settleWithX</span> (<span class=\"params\">p, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === p &amp;&amp; x) &#123;</span><br><span class=\"line\">    settlePromise(p, REJECTED, <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"promise_circular_chain\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xthen, type = <span class=\"keyword\">typeof</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (type === <span class=\"string\">\"function\"</span> || type === <span class=\"string\">\"object\"</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xthen = x.then;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      settlePromise(p, REJECTED, err);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> xthen === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">      settleXthen(p, x, xthen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      settlePromise(p, RESOLVED, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    settlePromise(p, RESOLVED, x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">settleXthen</span> (<span class=\"params\">p, x, xthen</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xthen.call(x, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      settleWithX(p, y);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      settlePromise(p, REJECTED, r);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x) &#123;</span><br><span class=\"line\">      settlePromise(p, REJECTED, err);</span><br><span class=\"line\">      x = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n","prev":{"title":"flex 演算法总结","link":"post/2018-11-21-flex演算法总结"},"next":{"title":"JavaScript 模块化七日谈","link":"post/2018-08-08-JavaScript模块化七日谈"},"plink":"https://vincentdou.github.io/blog/post/2018-11-20-Promise实现详解/"}
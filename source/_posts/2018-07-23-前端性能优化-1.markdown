---
layout:     post
title:      "前端性能优化-1"
date:       2018-07-23
author:     "Vincent"
catalog:    true
tags:
    - 前端开发
    - 性能优化
---

## DOM 操作篇

#### 缓存DOM对象

很基本的一个做法，在 for 循环前把要操作的 DOM 节点先获取到，而不是每次遍历都重新获取。

#### 在内存中操作元素

利用`document.createDocumentFragment()`可以创建内存节点。

由于 DOM 操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。

```
var ulNode = document.getElementById("container");
var liNode, i, m;
var fragment = document.createDocumentFragment();
for (i = 0, m = data.length; i < m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    fragment.appendChild(liNode);
}
ulNode.appendChild(fragment);
```

这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（`cloneNode()`），在内存中进行操作后再替换原来的节点。

避免过多的触发回流，是性能优化的一个思路。

#### 通过事件代理批量操作事件

我们可以通过事件代理的方式，将事件绑定在父节点上，然后通过`event.target`来确定被点击的元素是否是要绑定的子节点。

这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了。

## Javascript

#### 垃圾回收器回收机制

- `delete`这种方式可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化；而通过将变量或对象的属性设为`null`这种方式，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。相对而言，设为`null`这种方式不会改变对象的结构，比使用delete要好。
- 垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收，而全局对象就是根对象。

#### 对象的优化

JavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 > 数组下标获取（对象的整数索引获取） > 对象属性获取（对象非整数索引获取）。因此我们可以通过缓存需要被使用的对象的某属性的方式进行优化。

#### 使用原生方法

在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如Math之类的原生对象和方法。
